<div class="coverageReportDiv">
<h1>coverage-report</h1>
<div style="background: #fff; border: 1px solid #000; margin 0; padding: 0;">


<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for All files</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header low">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-babel-plugin-typecheck">npmtest-babel-plugin-typecheck (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">All files</span></h1>
    <h2>
        
        Statements: <span class="metric">9.27% <small>(654 / 7054)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">2.35% <small>(138 / 5875)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">6.48% <small>(46 / 710)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">69.27% <small>(266 / 384)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric">26 statements, 1 function, 30 branches</span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"></div>
</div>
<div class="body">
<div class="coverage-summary">
<table>
<thead>
<tr>
   <th data-col="file" data-fmt="html" data-html="true" class="file">File</th>
   <th data-col="pic" data-type="number" data-fmt="html" data-html="true" class="pic"></th>
   <th data-col="statements" data-type="number" data-fmt="pct" class="pct">Statements</th>
   <th data-col="statements_raw" data-type="number" data-fmt="html" class="abs"></th>
   <th data-col="branches" data-type="number" data-fmt="pct" class="pct">Branches</th>
   <th data-col="branches_raw" data-type="number" data-fmt="html" class="abs"></th>
   <th data-col="functions" data-type="number" data-fmt="pct" class="pct">Functions</th>
   <th data-col="functions_raw" data-type="number" data-fmt="html" class="abs"></th>
   <th data-col="lines" data-type="number" data-fmt="pct" class="pct">Lines</th>
   <th data-col="lines_raw" data-type="number" data-fmt="html" class="abs"></th>
</tr>
</thead>
<tbody><tr>
	<td class="file high" data-value="node-npmtest-babel-plugin-typecheck/"><a href="node-npmtest-babel-plugin-typecheck/index.html">node-npmtest-babel-plugin-typecheck/</a></td>
	<td data-value="100" class="pic high"><span class="cover-fill cover-full" style="width: 100px;"></span><span class="cover-empty" style="width:0px;"></span></td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="153" class="abs high">(153&nbsp;/&nbsp;153)</td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="126" class="abs high">(126&nbsp;/&nbsp;126)</td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="28" class="abs high">(28&nbsp;/&nbsp;28)</td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="153" class="abs high">(153&nbsp;/&nbsp;153)</td>
	</tr>

<tr>
	<td class="file low" data-value="node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib-checked/"><a href="node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib-checked/index.html">node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib-checked/</a></td>
	<td data-value="8.67" class="pic low"><span class="cover-fill" style="width: 8px;"></span><span class="cover-empty" style="width:92px;"></span></td>
	<td data-value="8.67" class="pct low">8.67%</td>
	<td data-value="2882" class="abs low">(250&nbsp;/&nbsp;2882)</td>
	<td data-value="0.24" class="pct low">0.24%</td>
	<td data-value="2503" class="abs low">(6&nbsp;/&nbsp;2503)</td>
	<td data-value="4.23" class="pct low">4.23%</td>
	<td data-value="307" class="abs low">(13&nbsp;/&nbsp;307)</td>
	<td data-value="86.49" class="pct high">86.49%</td>
	<td data-value="37" class="abs high">(32&nbsp;/&nbsp;37)</td>
	</tr>

<tr>
	<td class="file low" data-value="node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/"><a href="node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/index.html">node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/</a></td>
	<td data-value="6.25" class="pic low"><span class="cover-fill" style="width: 6px;"></span><span class="cover-empty" style="width:94px;"></span></td>
	<td data-value="6.25" class="pct low">6.25%</td>
	<td data-value="4019" class="abs low">(251&nbsp;/&nbsp;4019)</td>
	<td data-value="0.18" class="pct low">0.18%</td>
	<td data-value="3246" class="abs low">(6&nbsp;/&nbsp;3246)</td>
	<td data-value="1.33" class="pct low">1.33%</td>
	<td data-value="375" class="abs low">(5&nbsp;/&nbsp;375)</td>
	<td data-value="41.75" class="pct low">41.75%</td>
	<td data-value="194" class="abs low">(81&nbsp;/&nbsp;194)</td>
	</tr>

</tbody>
</table>
</div></div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 23:52:58 GMT+0000 (UTC)</div>
</div>
</body>
</html>


<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-babel-plugin-typecheck/</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header high">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-babel-plugin-typecheck">npmtest-babel-plugin-typecheck (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-babel-plugin-typecheck/</span></h1>
    <h2>
        
        Statements: <span class="metric">100% <small>(153 / 153)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">100% <small>(126 / 126)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">100% <small>(28 / 28)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">100% <small>(153 / 153)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric">26 statements, 1 function, 30 branches</span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../index.html">All files</a> &#187; node-npmtest-babel-plugin-typecheck/</div>
</div>
<div class="body">
<div class="coverage-summary">
<table>
<thead>
<tr>
   <th data-col="file" data-fmt="html" data-html="true" class="file">File</th>
   <th data-col="pic" data-type="number" data-fmt="html" data-html="true" class="pic"></th>
   <th data-col="statements" data-type="number" data-fmt="pct" class="pct">Statements</th>
   <th data-col="statements_raw" data-type="number" data-fmt="html" class="abs"></th>
   <th data-col="branches" data-type="number" data-fmt="pct" class="pct">Branches</th>
   <th data-col="branches_raw" data-type="number" data-fmt="html" class="abs"></th>
   <th data-col="functions" data-type="number" data-fmt="pct" class="pct">Functions</th>
   <th data-col="functions_raw" data-type="number" data-fmt="html" class="abs"></th>
   <th data-col="lines" data-type="number" data-fmt="pct" class="pct">Lines</th>
   <th data-col="lines_raw" data-type="number" data-fmt="html" class="abs"></th>
</tr>
</thead>
<tbody><tr>
	<td class="file high" data-value="example.js"><a href="example.js.html">example.js</a></td>
	<td data-value="100" class="pic high"><span class="cover-fill cover-full" style="width: 100px;"></span><span class="cover-empty" style="width:0px;"></span></td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="83" class="abs high">(83&nbsp;/&nbsp;83)</td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="73" class="abs high">(73&nbsp;/&nbsp;73)</td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="12" class="abs high">(12&nbsp;/&nbsp;12)</td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="83" class="abs high">(83&nbsp;/&nbsp;83)</td>
	</tr>

<tr>
	<td class="file high" data-value="lib.npmtest_babel_plugin_typecheck.js"><a href="lib.npmtest_babel_plugin_typecheck.js.html">lib.npmtest_babel_plugin_typecheck.js</a></td>
	<td data-value="100" class="pic high"><span class="cover-fill cover-full" style="width: 100px;"></span><span class="cover-empty" style="width:0px;"></span></td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="16" class="abs high">(16&nbsp;/&nbsp;16)</td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="14" class="abs high">(14&nbsp;/&nbsp;14)</td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="3" class="abs high">(3&nbsp;/&nbsp;3)</td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="16" class="abs high">(16&nbsp;/&nbsp;16)</td>
	</tr>

<tr>
	<td class="file high" data-value="test.js"><a href="test.js.html">test.js</a></td>
	<td data-value="100" class="pic high"><span class="cover-fill cover-full" style="width: 100px;"></span><span class="cover-empty" style="width:0px;"></span></td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="54" class="abs high">(54&nbsp;/&nbsp;54)</td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="39" class="abs high">(39&nbsp;/&nbsp;39)</td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="13" class="abs high">(13&nbsp;/&nbsp;13)</td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="54" class="abs high">(54&nbsp;/&nbsp;54)</td>
	</tr>

</tbody>
</table>
</div></div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 23:52:58 GMT+0000 (UTC)</div>
</div>
</body>
</html>


<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-babel-plugin-typecheck/example.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header high">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-babel-plugin-typecheck">npmtest-babel-plugin-typecheck (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-babel-plugin-typecheck/example.js</span></h1>
    <h2>
        
        Statements: <span class="metric">100% <small>(83 / 83)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">100% <small>(73 / 73)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">100% <small>(12 / 12)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">100% <small>(83 / 83)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric">26 statements, 1 function, 30 branches</span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../index.html">All files</a> &#187; <a href="index.html">node-npmtest-babel-plugin-typecheck/</a> &#187; example.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328</td><td class="line-coverage"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">3</span>
<span class="cline-any cline-yes">3</span>
<span class="cline-any cline-yes">3</span>
<span class="cline-any cline-yes">3</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">3</span>
<span class="cline-any cline-yes">3</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">3</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">3</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">6</span>
<span class="cline-any cline-yes">6</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">/*
example.js
&nbsp;
quickstart example
&nbsp;
instruction
    1. save this script as example.js
    2. run the shell command:
        $ npm install npmtest-babel-plugin-typecheck &amp;&amp; PORT=8081 node example.js
    3. play with the browser-demo on http://127.0.0.1:8081
*/
&nbsp;
&nbsp;
&nbsp;
/* istanbul instrument in package npmtest_babel_plugin_typecheck */
/*jslint
    bitwise: true,
    browser: true,
    maxerr: 8,
    maxlen: 96,
    node: true,
    nomen: true,
    regexp: true,
    stupid: true
*/
(function () {
    'use strict';
    var local;
&nbsp;
&nbsp;
&nbsp;
    // run shared js-env code - pre-init
    (function () {
        // init local
        local = {};
        // init modeJs
        local.modeJs = (function () {
            try {
                return typeof navigator.userAgent === 'string' &amp;&amp;
                    typeof document.querySelector('body') === 'object' &amp;&amp;
                    typeof XMLHttpRequest.prototype.open === 'function' &amp;&amp;
                    'browser';
            } catch (errorCaughtBrowser) {
                return module.exports &amp;&amp;
                    typeof process.versions.node === 'string' &amp;&amp;
                    typeof require('http').createServer === 'function' &amp;&amp;
                    'node';
            }
        }());
        // init global
        local.global = local.modeJs === 'browser'
            ? window
            : global;
        // init utility2_rollup
        local = local.global.utility2_rollup || (local.modeJs === 'browser'
            ? local.global.utility2_npmtest_babel_plugin_typecheck
            : global.utility2_moduleExports);
        // export local
        local.global.local = local;
    }());
    switch (local.modeJs) {
&nbsp;
&nbsp;
&nbsp;
    // post-init
    // run browser js-env code - post-init
    /* istanbul ignore next */
    case 'browser':
        local.testRunBrowser = function (event) {
            <span class="skip-if-branch" title="else path not taken" >E</span>if (!event || (event &amp;&amp;
                    event.currentTarget &amp;&amp;
                    event.currentTarget.className &amp;&amp;
                    event.currentTarget.className.includes &amp;&amp;
                    event.currentTarget.className.includes('onreset'))) {
                // reset output
                Array.from(
                    document.querySelectorAll('body &gt; .resettable')
                ).forEach(function (element) {
                    switch (element.tagName) {
<span class="branch-0 cbranch-skip" title="branch not covered" >                    case 'INPUT':</span>
                    case 'TEXTAREA':
                        element.value = '';
                        break;
<span class="branch-2 cbranch-skip" title="branch not covered" >                    default:</span>
<span class="cstat-skip" title="statement not covered" >                        element.textContent = '';</span>
                    }
                });
            }
            switch (event &amp;&amp; event.currentTarget &amp;&amp; event.currentTarget.id) {
            case 'testRunButton1':
                // show tests
                <span class="skip-if-branch" title="else path not taken" >E</span>if (document.querySelector('#testReportDiv1').style.display === 'none') {
                    document.querySelector('#testReportDiv1').style.display = 'block';
                    document.querySelector('#testRunButton1').textContent =
                        'hide internal test';
                    local.modeTest = true;
                    local.testRunDefault(local);
                // hide tests
                } else {
<span class="cstat-skip" title="statement not covered" >                    document.querySelector('#testReportDiv1').style.display = 'none';</span>
<span class="cstat-skip" title="statement not covered" >                    document.querySelector('#testRunButton1').textContent = 'run internal test';</span>
                }
                break;
            // custom-case
            default:
                break;
            }
            <span class="skip-if-branch" title="if path not taken" >I</span>if (document.querySelector('#inputTextareaEval1') &amp;&amp; (<span class="branch-1 cbranch-skip" title="branch not covered" >!event </span>|| (<span class="branch-2 cbranch-skip" title="branch not covered" >event </span>&amp;&amp;
<span class="branch-3 cbranch-skip" title="branch not covered" >                    event.currentTarget </span>&amp;&amp;
<span class="branch-4 cbranch-skip" title="branch not covered" >                    event.currentTarget.className </span>&amp;&amp;
<span class="branch-5 cbranch-skip" title="branch not covered" >                    event.currentTarget.className.includes </span>&amp;&amp;
<span class="branch-6 cbranch-skip" title="branch not covered" >                    event.currentTarget.className.includes('oneval'))</span>)) {
                // try to eval input-code
<span class="cstat-skip" title="statement not covered" >                try {</span>
                    /*jslint evil: true*/
<span class="cstat-skip" title="statement not covered" >                    eval(document.querySelector('#inputTextareaEval1').value);</span>
                } catch (errorCaught) {
<span class="cstat-skip" title="statement not covered" >                    console.error(errorCaught);</span>
                }
            }
        };
        // log stderr and stdout to #outputTextareaStdout1
        ['error', 'log'].forEach(function (key) {
            console[key + '_original'] = console[key];
            console[key] = function () {
                var element;
                console[key + '_original'].apply(console, arguments);
                element = document.querySelector('#outputTextareaStdout1');
                <span class="skip-if-branch" title="if path not taken" >I</span>if (!element) {
<span class="cstat-skip" title="statement not covered" >                    return;</span>
                }
                // append text to #outputTextareaStdout1
                element.value += Array.from(arguments).map(function (arg) {
                    return typeof arg === 'string'
                        ? arg
                        : <span class="branch-1 cbranch-skip" title="branch not covered" >JSON.stringify(arg, null, 4);</span>
                }).join(' ') + '\n';
                // scroll textarea to bottom
                element.scrollTop = element.scrollHeight;
            };
        });
        // init event-handling
        ['change', 'click', 'keyup'].forEach(function (event) {
            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {
                element.addEventListener(event, local.testRunBrowser);
            });
        });
        // run tests
        local.testRunBrowser();
        break;
&nbsp;
&nbsp;
&nbsp;
    // run node js-env code - post-init
    /* istanbul ignore next */
    case 'node':
        // export local
        module.exports = local;
        // require modules
        local.fs = require('fs');
        local.http = require('http');
        local.url = require('url');
        // init assets
        local.assetsDict = local.assetsDict || {};
        /* jslint-ignore-begin */
        local.assetsDict['/assets.index.template.html'] = '\
&lt;!doctype html&gt;\n\
&lt;html lang="en"&gt;\n\
&lt;head&gt;\n\
&lt;meta charset="UTF-8"&gt;\n\
&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;\n\
&lt;title&gt;{{env.npm_package_name}} (v{{env.npm_package_version}})&lt;/title&gt;\n\
&lt;style&gt;\n\
/*csslint\n\
    box-sizing: false,\n\
    universal-selector: false\n\
*/\n\
* {\n\
    box-sizing: border-box;\n\
}\n\
body {\n\
    background: #dde;\n\
    font-family: Arial, Helvetica, sans-serif;\n\
    margin: 2rem;\n\
}\n\
body &gt; * {\n\
    margin-bottom: 1rem;\n\
}\n\
.utility2FooterDiv {\n\
    margin-top: 20px;\n\
    text-align: center;\n\
}\n\
&lt;/style&gt;\n\
&lt;style&gt;\n\
/*csslint\n\
*/\n\
textarea {\n\
    font-family: monospace;\n\
    height: 10rem;\n\
    width: 100%;\n\
}\n\
textarea[readonly] {\n\
    background: #ddd;\n\
}\n\
&lt;/style&gt;\n\
&lt;/head&gt;\n\
&lt;body&gt;\n\
&lt;!-- utility2-comment\n\
&lt;div id="ajaxProgressDiv1" style="background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;"&gt;&lt;/div&gt;\n\
utility2-comment --&gt;\n\
&lt;h1&gt;\n\
&lt;!-- utility2-comment\n\
    &lt;a\n\
        {{#if env.npm_package_homepage}}\n\
        href="{{env.npm_package_homepage}}"\n\
        {{/if env.npm_package_homepage}}\n\
        target="_blank"\n\
    &gt;\n\
utility2-comment --&gt;\n\
        {{env.npm_package_name}} (v{{env.npm_package_version}})\n\
&lt;!-- utility2-comment\n\
    &lt;/a&gt;\n\
utility2-comment --&gt;\n\
&lt;/h1&gt;\n\
&lt;h3&gt;{{env.npm_package_description}}&lt;/h3&gt;\n\
&lt;!-- utility2-comment\n\
&lt;h4&gt;&lt;a download href="assets.app.js"&gt;download standalone app&lt;/a&gt;&lt;/h4&gt;\n\
&lt;button class="onclick onreset" id="testRunButton1"&gt;run internal test&lt;/button&gt;&lt;br&gt;\n\
&lt;div id="testReportDiv1" style="display: none;"&gt;&lt;/div&gt;\n\
utility2-comment --&gt;\n\
\n\
\n\
\n\
&lt;label&gt;stderr and stdout&lt;/label&gt;\n\
&lt;textarea class="resettable" id="outputTextareaStdout1" readonly&gt;&lt;/textarea&gt;\n\
&lt;!-- utility2-comment\n\
{{#if isRollup}}\n\
&lt;script src="assets.app.js"&gt;&lt;/script&gt;\n\
{{#unless isRollup}}\n\
utility2-comment --&gt;\n\
&lt;script src="assets.utility2.rollup.js"&gt;&lt;/script&gt;\n\
&lt;script src="jsonp.utility2._stateInit?callback=window.utility2._stateInit"&gt;&lt;/script&gt;\n\
&lt;script src="assets.npmtest_babel_plugin_typecheck.rollup.js"&gt;&lt;/script&gt;\n\
&lt;script src="assets.example.js"&gt;&lt;/script&gt;\n\
&lt;script src="assets.test.js"&gt;&lt;/script&gt;\n\
&lt;!-- utility2-comment\n\
{{/if isRollup}}\n\
utility2-comment --&gt;\n\
&lt;div class="utility2FooterDiv"&gt;\n\
    [ this app was created with\n\
    &lt;a href="https://github.com/kaizhu256/node-utility2" target="_blank"&gt;utility2&lt;/a&gt;\n\
    ]\n\
&lt;/div&gt;\n\
&lt;/body&gt;\n\
&lt;/html&gt;\n\
';
        /* jslint-ignore-end */
        <span class="skip-if-branch" title="if path not taken" >I</span>if (local.templateRender) {
<span class="cstat-skip" title="statement not covered" >            local.assetsDict['/'] = local.templateRender(</span>
                local.assetsDict['/assets.index.template.html'],
                {
                    env: local.objectSetDefault(local.env, {
                        npm_package_description: 'the greatest app in the world!',
                        npm_package_name: 'my-app',
                        npm_package_nameAlias: 'my_app',
                        npm_package_version: '0.0.1'
                    })
                }
            );
        } else {
            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']
                .replace((/\{\{env\.(\w+?)\}\}/g), function (match0, match1) {
                    // jslint-hack
                    String(match0);
                    switch (match1) {
                    case 'npm_package_description':
                        return 'the greatest app in the world!';
                    case 'npm_package_name':
                        return 'my-app';
<span class="branch-2 cbranch-skip" title="branch not covered" >                    case 'npm_package_nameAlias':</span>
<span class="cstat-skip" title="statement not covered" >                        return 'my_app';</span>
                    case 'npm_package_version':
                        return '0.0.1';
                    }
                });
        }
        // run the cli
        <span class="skip-if-branch" title="else path not taken" >E</span>if (local.global.utility2_rollup || module !== require.main) {
            break;
        }
<span class="cstat-skip" title="statement not covered" >        local.assetsDict['/assets.example.js'] =</span>
            local.assetsDict['/assets.example.js'] ||
            local.fs.readFileSync(__filename, 'utf8');
        // bug-workaround - long $npm_package_buildCustomOrg
        /* jslint-ignore-begin */
<span class="cstat-skip" title="statement not covered" >        local.assetsDict['/assets.npmtest_babel_plugin_typecheck.rollup.js'] =</span>
            local.assetsDict['/assets.npmtest_babel_plugin_typecheck.rollup.js'] ||
            local.fs.readFileSync(
                local.npmtest_babel_plugin_typecheck.__dirname + '/lib.npmtest_babel_plugin_typecheck.js',
                'utf8'
            ).replace((/^#!/), '//');
        /* jslint-ignore-end */
<span class="cstat-skip" title="statement not covered" >        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';</span>
        // if $npm_config_timeout_exit exists,
        // then exit this process after $npm_config_timeout_exit ms
<span class="cstat-skip" title="statement not covered" >        if (Number(process.env.npm_config_timeout_exit)) {</span>
<span class="cstat-skip" title="statement not covered" >            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));</span>
        }
        // start server
<span class="cstat-skip" title="statement not covered" >        if (local.global.utility2_serverHttp1) {</span>
<span class="cstat-skip" title="statement not covered" >            break;</span>
        }
<span class="cstat-skip" title="statement not covered" >        process.env.PORT = process.env.PORT || '8081';</span>
<span class="cstat-skip" title="statement not covered" >        console.error('server starting on port ' + process.env.PORT);</span>
<span class="cstat-skip" title="statement not covered" >        local.http.createServer(<span class="fstat-skip" title="function not covered" >function (request, response) {</span></span>
<span class="cstat-skip" title="statement not covered" >            request.urlParsed = local.url.parse(request.url);</span>
<span class="cstat-skip" title="statement not covered" >            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {</span>
<span class="cstat-skip" title="statement not covered" >                response.end(local.assetsDict[request.urlParsed.pathname]);</span>
<span class="cstat-skip" title="statement not covered" >                return;</span>
            }
<span class="cstat-skip" title="statement not covered" >            response.statusCode = 404;</span>
<span class="cstat-skip" title="statement not covered" >            response.end();</span>
        }).listen(process.env.PORT);
<span class="cstat-skip" title="statement not covered" >        break;</span>
    }
}());
&nbsp;
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 23:52:58 GMT+0000 (UTC)</div>
</div>
</body>
</html>


<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-babel-plugin-typecheck/lib.npmtest_babel_plugin_typecheck.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header high">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-babel-plugin-typecheck">npmtest-babel-plugin-typecheck (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-babel-plugin-typecheck/lib.npmtest_babel_plugin_typecheck.js</span></h1>
    <h2>
        
        Statements: <span class="metric">100% <small>(16 / 16)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">100% <small>(14 / 14)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">100% <small>(3 / 3)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">100% <small>(16 / 16)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../index.html">All files</a> &#187; <a href="index.html">node-npmtest-babel-plugin-typecheck/</a> &#187; lib.npmtest_babel_plugin_typecheck.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55</td><td class="line-coverage"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">/* istanbul instrument in package npmtest_babel_plugin_typecheck */
/*jslint
    bitwise: true,
    browser: true,
    maxerr: 8,
    maxlen: 96,
    node: true,
    nomen: true,
    regexp: true,
    stupid: true
*/
(function () {
    'use strict';
    var local;
&nbsp;
&nbsp;
&nbsp;
    // run shared js-env code - pre-init
    (function () {
        // init local
        local = {};
        // init modeJs
        local.modeJs = (function () {
            try {
                return typeof navigator.userAgent === 'string' &amp;&amp;
                    typeof document.querySelector('body') === 'object' &amp;&amp;
                    typeof XMLHttpRequest.prototype.open === 'function' &amp;&amp;
                    'browser';
            } catch (errorCaughtBrowser) {
                return module.exports &amp;&amp;
                    typeof process.versions.node === 'string' &amp;&amp;
                    typeof require('http').createServer === 'function' &amp;&amp;
                    'node';
            }
        }());
        // init global
        local.global = local.modeJs === 'browser'
            ? window
            : global;
        // init utility2_rollup
        local = local.global.utility2_rollup || local;
        // init lib
        local.local = local.npmtest_babel_plugin_typecheck = local;
        // init exports
        if (local.modeJs === 'browser') {
            local.global.utility2_npmtest_babel_plugin_typecheck = local;
        } else {
            module.exports = local;
            module.exports.__dirname = __dirname;
            module.exports.module = module;
        }
    }());
}());
&nbsp;
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 23:52:58 GMT+0000 (UTC)</div>
</div>
</body>
</html>


<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-babel-plugin-typecheck/test.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header high">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-babel-plugin-typecheck">npmtest-babel-plugin-typecheck (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-babel-plugin-typecheck/test.js</span></h1>
    <h2>
        
        Statements: <span class="metric">100% <small>(54 / 54)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">100% <small>(39 / 39)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">100% <small>(13 / 13)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">100% <small>(54 / 54)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../index.html">All files</a> &#187; <a href="index.html">node-npmtest-babel-plugin-typecheck/</a> &#187; test.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197</td><td class="line-coverage"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-yes">2</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">/* istanbul instrument in package npmtest_babel_plugin_typecheck */
/*jslint
    bitwise: true,
    browser: true,
    maxerr: 8,
    maxlen: 96,
    node: true,
    nomen: true,
    regexp: true,
    stupid: true
*/
(function () {
    'use strict';
    var local;
&nbsp;
&nbsp;
&nbsp;
    // run shared js-env code - pre-init
    (function () {
        // init local
        local = {};
        // init modeJs
        local.modeJs = (function () {
            try {
                return typeof navigator.userAgent === 'string' &amp;&amp;
                    typeof document.querySelector('body') === 'object' &amp;&amp;
                    typeof XMLHttpRequest.prototype.open === 'function' &amp;&amp;
                    'browser';
            } catch (errorCaughtBrowser) {
                return module.exports &amp;&amp;
                    typeof process.versions.node === 'string' &amp;&amp;
                    typeof require('http').createServer === 'function' &amp;&amp;
                    'node';
            }
        }());
        // init global
        local.global = local.modeJs === 'browser'
            ? window
            : global;
        switch (local.modeJs) {
        // re-init local from window.local
        case 'browser':
            local = local.global.utility2.objectSetDefault(
                local.global.utility2_rollup || local.global.local,
                local.global.utility2
            );
            break;
        // re-init local from example.js
        case 'node':
            local = (local.global.utility2_rollup || require('utility2'))
                .requireReadme();
            break;
        }
        // export local
        local.global.local = local;
    }());
&nbsp;
&nbsp;
&nbsp;
    // run shared js-env code - function
    (function () {
        return;
    }());
    switch (local.modeJs) {
&nbsp;
&nbsp;
&nbsp;
    // run browser js-env code - function
    case 'browser':
        break;
&nbsp;
&nbsp;
&nbsp;
    // run node js-env code - function
    case 'node':
        break;
    }
&nbsp;
&nbsp;
&nbsp;
    // run shared js-env code - post-init
    (function () {
        return;
    }());
    switch (local.modeJs) {
&nbsp;
&nbsp;
&nbsp;
    // run browser js-env code - post-init
    case 'browser':
        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (
            options,
            onError
        ) {
        /*
         * this function will test browsers's null-case handling-behavior-behavior
         */
            onError(null, options);
        };
&nbsp;
        // run tests
        local.nop(local.modeTest &amp;&amp;
            document.querySelector('#testRunButton1') &amp;&amp;
            document.querySelector('#testRunButton1').click());
        break;
&nbsp;
&nbsp;
&nbsp;
    // run node js-env code - post-init
    /* istanbul ignore next */
    case 'node':
        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (
            options,
            onError
        ) {
        /*
         * this function will test buildApidoc's default handling-behavior-behavior
         */
            options = { modulePathList: module.paths };
            local.buildApidoc(options, onError);
        };
&nbsp;
        local.testCase_buildApp_default = local.testCase_buildApp_default || function (
            options,
            onError
        ) {
        /*
         * this function will test buildApp's default handling-behavior-behavior
         */
            local.testCase_buildReadme_default(options, local.onErrorThrow);
            local.testCase_buildLib_default(options, local.onErrorThrow);
            local.testCase_buildTest_default(options, local.onErrorThrow);
            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);
            options = [];
            local.buildApp(options, onError);
        };
&nbsp;
        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||
            function (options, onError) {
            /*
             * this function will test buildCustomOrg's default handling-behavior
             */
                options = {};
                local.buildCustomOrg(options, onError);
            };
&nbsp;
        local.testCase_buildLib_default = local.testCase_buildLib_default || function (
            options,
            onError
        ) {
        /*
         * this function will test buildLib's default handling-behavior
         */
            options = {};
            local.buildLib(options, onError);
        };
&nbsp;
        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (
            options,
            onError
        ) {
        /*
         * this function will test buildReadme's default handling-behavior-behavior
         */
            options = {};
            local.buildReadme(options, onError);
        };
&nbsp;
        local.testCase_buildTest_default = local.testCase_buildTest_default || function (
            options,
            onError
        ) {
        /*
         * this function will test buildTest's default handling-behavior
         */
            options = {};
            local.buildTest(options, onError);
        };
&nbsp;
        local.testCase_webpage_default = local.testCase_webpage_default || function (
            options,
            onError
        ) {
        /*
         * this function will test webpage's default handling-behavior
         */
            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };
            local.browserTest(options, onError);
        };
&nbsp;
        // run test-server
        local.testRunServer(local);
        break;
    }
}());
&nbsp;
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 23:52:58 GMT+0000 (UTC)</div>
</div>
</body>
</html>


<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib-checked/</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header low">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-babel-plugin-typecheck">npmtest-babel-plugin-typecheck (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib-checked/</span></h1>
    <h2>
        
        Statements: <span class="metric">8.67% <small>(250 / 2882)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">0.24% <small>(6 / 2503)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">4.23% <small>(13 / 307)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">86.49% <small>(32 / 37)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../../../../index.html">All files</a> &#187; node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib-checked/</div>
</div>
<div class="body">
<div class="coverage-summary">
<table>
<thead>
<tr>
   <th data-col="file" data-fmt="html" data-html="true" class="file">File</th>
   <th data-col="pic" data-type="number" data-fmt="html" data-html="true" class="pic"></th>
   <th data-col="statements" data-type="number" data-fmt="pct" class="pct">Statements</th>
   <th data-col="statements_raw" data-type="number" data-fmt="html" class="abs"></th>
   <th data-col="branches" data-type="number" data-fmt="pct" class="pct">Branches</th>
   <th data-col="branches_raw" data-type="number" data-fmt="html" class="abs"></th>
   <th data-col="functions" data-type="number" data-fmt="pct" class="pct">Functions</th>
   <th data-col="functions_raw" data-type="number" data-fmt="html" class="abs"></th>
   <th data-col="lines" data-type="number" data-fmt="pct" class="pct">Lines</th>
   <th data-col="lines_raw" data-type="number" data-fmt="html" class="abs"></th>
</tr>
</thead>
<tbody><tr>
	<td class="file low" data-value="index.js"><a href="index.js.html">index.js</a></td>
	<td data-value="8.67" class="pic low"><span class="cover-fill" style="width: 8px;"></span><span class="cover-empty" style="width:92px;"></span></td>
	<td data-value="8.67" class="pct low">8.67%</td>
	<td data-value="2882" class="abs low">(250&nbsp;/&nbsp;2882)</td>
	<td data-value="0.24" class="pct low">0.24%</td>
	<td data-value="2503" class="abs low">(6&nbsp;/&nbsp;2503)</td>
	<td data-value="4.23" class="pct low">4.23%</td>
	<td data-value="307" class="abs low">(13&nbsp;/&nbsp;307)</td>
	<td data-value="86.49" class="pct high">86.49%</td>
	<td data-value="37" class="abs high">(32&nbsp;/&nbsp;37)</td>
	</tr>

</tbody>
</table>
</div></div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 23:52:58 GMT+0000 (UTC)</div>
</div>
</body>
</html>


<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib-checked/index.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header low">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-babel-plugin-typecheck">npmtest-babel-plugin-typecheck (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib-checked/index.js</span></h1>
    <h2>
        
        Statements: <span class="metric">8.67% <small>(250 / 2882)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">0.24% <small>(6 / 2503)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">4.23% <small>(13 / 307)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">86.49% <small>(32 / 37)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../../../../index.html">All files</a> &#187; <a href="index.html">node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib-checked/</a> &#187; index.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77</td><td class="line-coverage"><span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _slicedToArray=function(){<span class="fstat-no" title="function not covered" >function sliceIterator(arr,i){<span class="cstat-no" title="statement not covered" ></span>var _arr=[];<span class="cstat-no" title="statement not covered" >v</span>ar _n=true;<span class="cstat-no" title="statement not covered" >v</span>ar _d=false;<span class="cstat-no" title="statement not covered" >v</span>ar _e=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){<span class="cstat-no" title="statement not covered" >_arr.push(_s.value);<span class="cstat-no" title="statement not covered" >i</span>f(i&amp;&amp;_arr.length===i)<span class="cstat-no" title="statement not covered" >break;}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_d=true;<span class="cstat-no" title="statement not covered" >_</span>e=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_n&amp;&amp;_i["return"])<span class="cstat-no" title="statement not covered" >_i["return"]();}</span></span>finally {<span class="cstat-no" title="statement not covered" >if(_d)<span class="cstat-no" title="statement not covered" >throw _e;}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _arr;}</span>return <span class="fstat-no" title="function not covered" >function(arr,i){<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(arr)){<span class="cstat-no" title="statement not covered" >return arr;}</span>else <span class="cstat-no" title="statement not covered" >if(Symbol.iterator in Object(arr)){<span class="cstat-no" title="statement not covered" >return sliceIterator(arr,i);}</span>else {<span class="cstat-no" title="statement not covered" >throw new TypeError("Invalid attempt to destructure non-iterable instance");}</span>}</span></span>;}();var _typeof=typeof Symbol==="function"&amp;&amp;typeof Symbol.iterator==="symbol"?<span class="fstat-no" title="function not covered" >function(obj){<span class="cstat-no" title="statement not covered" ></span>return typeof obj;}</span>:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >function(obj){<span class="cstat-no" title="statement not covered" ></span>return obj&amp;&amp;typeof Symbol==="function"&amp;&amp;obj.constructor===Symbol?"symbol":typeof obj;}</span>;</span>exports.default=<span class="fstat-no" title="function not covered" >function(_ref102){<span class="cstat-no" title="statement not covered" ></span>var t=_ref102.types;<span class="cstat-no" title="statement not covered" >v</span>ar template=_ref102.template; </span>/**
   * Binary Operators that can only produce boolean results.
   */<span class="cstat-no" title="statement not covered" >var BOOLEAN_BINARY_OPERATORS=['==','===','&gt;=','&lt;=','&gt;','&lt;','instanceof'];<span class="cstat-no" title="statement not covered" >i</span>f(!(Array.isArray(BOOLEAN_BINARY_OPERATORS)&amp;&amp;BOOLEAN_BINARY_OPERATORS.every(<span class="fstat-no" title="function not covered" >function(item){<span class="cstat-no" title="statement not covered" ></span>return typeof item==='string';}</span>))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "BOOLEAN_BINARY_OPERATORS" violates contract.\n\nExpected:\nstring[]\n\nGot:\n'+_inspect(BOOLEAN_BINARY_OPERATORS));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checks=createChecks();<span class="cstat-no" title="statement not covered" >v</span>ar staticChecks=createStaticChecks();<span class="cstat-no" title="statement not covered" >v</span>ar checkIsArray=expression('Array.isArray(input)');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof checkIsArray==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "checkIsArray" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkIsArray));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checkIsMap=expression('input instanceof Map');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof checkIsMap==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "checkIsMap" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkIsMap));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checkIsSet=expression('input instanceof Set');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof checkIsSet==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "checkIsSet" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkIsSet));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checkIsClass=expression('typeof input === \'function\' &amp;&amp; input.prototype &amp;&amp; input.prototype.constructor === input');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof checkIsClass==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "checkIsClass" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkIsClass));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checkIsGenerator=expression('typeof input === \'function\' &amp;&amp; input.generator');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof checkIsGenerator==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "checkIsGenerator" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkIsGenerator));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checkIsIterable=expression('input &amp;&amp; (typeof input[Symbol.iterator] === \'function\' || Array.isArray(input))');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof checkIsIterable==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "checkIsIterable" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkIsIterable));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checkIsObject=expression('input != null &amp;&amp; typeof input === \'object\'');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof checkIsObject==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "checkIsObject" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkIsObject));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checkNotNull=expression('input != null');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof checkNotNull==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "checkNotNull" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkNotNull));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checkEquals=expression('input === expected');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof checkEquals==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "checkEquals" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkEquals));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar declareTypeChecker=template('\n    const id = (function () {\n      function id (input) {\n        return check;\n      };\n      Object.defineProperty(id, Symbol.hasInstance, {\n        value: function (input) {\n          return id(input);\n        }\n      });\n      return id;\n    })();\n  ');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof declareTypeChecker==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "declareTypeChecker" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(declareTypeChecker));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar guard=template('\n    if (!check) {\n      throw new TypeError(message);\n    }\n  ');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof guard==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "guard" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(guard));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar thrower=template('\n    if (check) {\n      ret;\n    }\n    else {\n      throw new TypeError(message);\n    }\n  ');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof thrower==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "thrower" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(thrower));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar guardInline=expression('\n    (id =&gt; {\n      if (!check) {\n        throw new TypeError(message);\n      }\n      return id;\n    })(input)\n  ');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof guardInline==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "guardInline" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(guardInline));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar guardFn=expression('\n    function name (id) {\n      if (!check) {\n        throw new TypeError(message);\n      }\n      return id;\n    }\n  ');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof guardFn==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "guardFn" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(guardFn));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar readableName=expression('\n    inspect(input)\n  ');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof readableName==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "readableName" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(readableName));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checkMapKeys=expression('\n    input instanceof Map &amp;&amp; Array.from(input.keys()).every(key =&gt; keyCheck)\n  ');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof checkMapKeys==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "checkMapKeys" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkMapKeys));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checkMapValues=expression('\n    input instanceof Map &amp;&amp; Array.from(input.values()).every(value =&gt; valueCheck)\n  ');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof checkMapValues==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "checkMapValues" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkMapValues));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checkMapEntries=expression('\n    input instanceof Map &amp;&amp; Array.from(input).every(([key, value]) =&gt; keyCheck &amp;&amp; valueCheck)\n  ');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof checkMapEntries==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "checkMapEntries" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkMapEntries));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checkSetEntries=expression('\n    input instanceof Set &amp;&amp; Array.from(input).every(value =&gt; valueCheck)\n  ');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof checkSetEntries==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "checkSetEntries" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkSetEntries));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checkObjectIndexers=expression('\n    Object.keys(input).every(key =&gt; {\n      const value = input[key];\n      if (~fixedKeys.indexOf(key)) {\n        return true;\n      }\n      else {\n        return check;\n      }\n    });\n  ');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof checkObjectIndexers==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "checkObjectIndexers" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkObjectIndexers));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checkObjectIndexersNoFixed=expression('\n    Object.keys(input).every(key =&gt; {\n      const value = input[key];\n      return check;\n    });\n  ');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof checkObjectIndexersNoFixed==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "checkObjectIndexersNoFixed" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(checkObjectIndexersNoFixed));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar propType=expression('\n    (function(props, name, component) {\n      var prop = props[name];\n      if(!check) {\n        return new Error(\n          "Invalid prop `" + name + "` supplied to `" + component\n          + "`.\\n\\nExpected:\\n" + expected + "\\n\\nGot:\\n" + got + "\\n\\n"\n        );\n      }\n    })\n  ');<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof propType==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "propType" violates contract.\n\nExpected:\n() =&gt; Node\n\nGot:\n'+_inspect(propType));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar PRAGMA_IGNORE_STATEMENT=/typecheck:\s*ignore\s+statement/i;<span class="cstat-no" title="statement not covered" >v</span>ar PRAGMA_IGNORE_FILE=/typecheck:\s*ignore\s+file/i;<span class="fstat-no" title="function not covered" >f</span>unction skipEnvironment(comments,opts){<span class="cstat-no" title="statement not covered" ></span>if(!opts.only){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar envs=pragmaEnvironments(comments);<span class="cstat-no" title="statement not covered" >r</span>eturn !opts.only.some(<span class="fstat-no" title="function not covered" >function(env){<span class="cstat-no" title="statement not covered" ></span>return envs[env];}</span>);}<span class="fstat-no" title="function not covered" ></span>function pragmaEnvironments(comments){<span class="cstat-no" title="statement not covered" ></span>var pragma=/@typecheck:\s*(.+)/;<span class="cstat-no" title="statement not covered" >v</span>ar environments={};<span class="cstat-no" title="statement not covered" >c</span>omments.forEach(<span class="fstat-no" title="function not covered" >function(comment){<span class="cstat-no" title="statement not covered" ></span>var m=comment.value.match(pragma);<span class="cstat-no" title="statement not covered" >i</span>f(m){<span class="cstat-no" title="statement not covered" >m[1].split(',').forEach(<span class="fstat-no" title="function not covered" >function(env){<span class="cstat-no" title="statement not covered" ></span>return environments[env.trim()]=true;}</span>);}</span>}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn environments;}<span class="cstat-no" title="statement not covered" ></span>var visitors={Statement:<span class="fstat-no" title="function not covered" >function Statement(path){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>m</span>aybeSkip(path);}</span>,TypeAlias:<span class="fstat-no" title="function not covered" >function TypeAlias(path){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.replaceWith(createTypeAliasChecks(path));}</span>,InterfaceDeclaration:<span class="fstat-no" title="function not covered" >function InterfaceDeclaration(path){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.replaceWith(createInterfaceChecks(path));}</span>,ExportNamedDeclaration:<span class="fstat-no" title="function not covered" >function ExportNamedDeclaration(path){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >i</span>f(node.declaration&amp;&amp;node.declaration.type==='TypeAlias'){<span class="cstat-no" title="statement not covered" >var declaration=path.get('declaration');<span class="cstat-no" title="statement not covered" >d</span>eclaration.replaceWith(createTypeAliasChecks(declaration));<span class="cstat-no" title="statement not covered" >n</span>ode.exportKind='value';}</span>}</span>,ImportDeclaration:<span class="fstat-no" title="function not covered" >function ImportDeclaration(path){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(path.node.importKind!=='type'){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _path$get$map$reduce=path.get('specifiers').map(<span class="fstat-no" title="function not covered" >function(specifier){<span class="cstat-no" title="statement not covered" ></span>var local=specifier.get('local');<span class="cstat-no" title="statement not covered" >v</span>ar tmpId=path.scope.generateUidIdentifierBasedOnNode(local.node);<span class="cstat-no" title="statement not covered" >v</span>ar replacement=t.importSpecifier(tmpId,specifier.node.imported);<span class="cstat-no" title="statement not covered" >v</span>ar id=t.identifier(local.node.name);<span class="cstat-no" title="statement not covered" >i</span>d.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >v</span>ar declarator=t.variableDeclarator(id,tmpId);<span class="cstat-no" title="statement not covered" >d</span>eclarator.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >r</span>eturn [declarator,replacement];}</span>).reduce(<span class="fstat-no" title="function not covered" >function(_ref103,_ref104){<span class="cstat-no" title="statement not covered" ></span>var _ref106=_slicedToArray(_ref103,2);<span class="cstat-no" title="statement not covered" >v</span>ar declarators=_ref106[0];<span class="cstat-no" title="statement not covered" >v</span>ar specifiers=_ref106[1];<span class="cstat-no" title="statement not covered" >v</span>ar _ref105=_slicedToArray(_ref104,2);<span class="cstat-no" title="statement not covered" >v</span>ar declarator=_ref105[0];<span class="cstat-no" title="statement not covered" >v</span>ar specifier=_ref105[1];<span class="cstat-no" title="statement not covered" >d</span>eclarators.push(declarator);<span class="cstat-no" title="statement not covered" >s</span>pecifiers.push(specifier);<span class="cstat-no" title="statement not covered" >r</span>eturn [declarators,specifiers];}</span>,[[],[]]);<span class="cstat-no" title="statement not covered" >v</span>ar _path$get$map$reduce2=_slicedToArray(_path$get$map$reduce,2);<span class="cstat-no" title="statement not covered" >v</span>ar declarators=_path$get$map$reduce2[0];<span class="cstat-no" title="statement not covered" >v</span>ar specifiers=_path$get$map$reduce2[1];<span class="cstat-no" title="statement not covered" >v</span>ar declaration=t.variableDeclaration('var',declarators);<span class="cstat-no" title="statement not covered" >d</span>eclaration.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >p</span>ath.replaceWithMultiple([t.importDeclaration(specifiers,path.node.source),declaration]);}</span>,ArrowFunctionExpression:<span class="fstat-no" title="function not covered" >function ArrowFunctionExpression(path){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}</span> </span>// Look for destructuring args with annotations.</span>
<span class="cstat-no" title="statement not covered" >var params=path.get('params');<span class="cstat-no" title="statement not covered" >i</span>f(!(Array.isArray(params)&amp;&amp;params.every(<span class="fstat-no" title="function not covered" >function(item){<span class="cstat-no" title="statement not covered" ></span>return NodePath(item);}</span>))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "params" violates contract.\n\nExpected:\nNodePath[]\n\nGot:\n'+_inspect(params));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!(params&amp;&amp;(typeof params[Symbol.iterator]==='function'||Array.isArray(params)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected params to be iterable, got '+_inspect(params));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator=params[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){<span class="cstat-no" title="statement not covered" >var param=_step.value;<span class="cstat-no" title="statement not covered" >i</span>f(param.isObjectPattern()&amp;&amp;param.node.typeAnnotation){<span class="cstat-no" title="statement not covered" >var _path$get5=path.get('body');<span class="cstat-no" title="statement not covered" >v</span>ar _scope=_path$get5.scope;<span class="cstat-no" title="statement not covered" >v</span>ar _id117=_scope.generateUidIdentifier('arg'+param.key);<span class="cstat-no" title="statement not covered" >v</span>ar pattern=param.node;<span class="cstat-no" title="statement not covered" >p</span>aram.replaceWith(_id117);<span class="cstat-no" title="statement not covered" >i</span>f(path.node.expression){<span class="cstat-no" title="statement not covered" >var block=t.blockStatement([t.variableDeclaration('var',[t.variableDeclarator(pattern,_id117)]),t.returnStatement(path.get('body').node)]);<span class="cstat-no" title="statement not covered" >p</span>ath.node.body=block;<span class="cstat-no" title="statement not covered" >p</span>ath.node.expression=false;}</span>else {<span class="cstat-no" title="statement not covered" >path.get('body.body')[0].insertBefore(t.variableDeclaration('var',[t.variableDeclarator(pattern,_id117)]));}</span>}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion&amp;&amp;_iterator.return){<span class="cstat-no" title="statement not covered" >_iterator.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError){<span class="cstat-no" title="statement not covered" >throw _iteratorError;}</span>}</span>}</span>}</span>,Function:{enter:<span class="fstat-no" title="function not covered" >function enter(path,context){<span class="cstat-no" title="statement not covered" ></span>var _node$body$body;<span class="cstat-no" title="statement not covered" >i</span>f(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!VisitorContext(context)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar paramChecks=collectParamChecks(path,context);<span class="cstat-no" title="statement not covered" >i</span>f(node.type==="ArrowFunctionExpression"&amp;&amp;node.expression){<span class="cstat-no" title="statement not covered" >node.expression=false;<span class="cstat-no" title="statement not covered" >n</span>ode.body=t.blockStatement([t.returnStatement(node.body)]);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.returnType){<span class="cstat-no" title="statement not covered" >createFunctionReturnGuard(path,context);<span class="cstat-no" title="statement not covered" >c</span>reateFunctionYieldGuards(path,context);}<span class="cstat-no" title="statement not covered" ></span>(</span>_node$body$body=node.body.body).unshift.apply(_node$body$body,_toConsumableArray(paramChecks));<span class="cstat-no" title="statement not covered" >n</span>ode.savedTypeAnnotation=node.returnType;<span class="cstat-no" title="statement not covered" >n</span>ode.returnCount=0;<span class="cstat-no" title="statement not covered" >n</span>ode.yieldCount=0;}</span>,exit:<span class="fstat-no" title="function not covered" >function exit(path){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar isVoid=node.savedTypeAnnotation?maybeNullableAnnotation(node.savedTypeAnnotation):null;<span class="cstat-no" title="statement not covered" >i</span>f(!node.returnCount&amp;&amp;isVoid===false){<span class="cstat-no" title="statement not covered" >var annotation=node.savedTypeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.generator&amp;&amp;isGeneratorAnnotation(annotation)&amp;&amp;annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters.params[1];}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow path.buildCodeFrameError(buildErrorMessage('Function '+(node.id?'"'+node.id.name+'" ':'')+'did not return a value.',annotation));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.nextGuardCount){<span class="cstat-no" title="statement not covered" >path.get('body').get('body')[0].insertBefore(node.nextGuard);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.yieldGuardCount){<span class="cstat-no" title="statement not covered" >path.get('body').get('body')[0].insertBefore(node.yieldGuard);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.returnGuardCount){<span class="cstat-no" title="statement not covered" >path.get('body').get('body')[0].insertBefore(node.returnGuard);}</span>}</span>},YieldExpression:<span class="fstat-no" title="function not covered" >function YieldExpression(path,context){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!VisitorContext(context)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar fn=path.getFunctionParent();<span class="cstat-no" title="statement not covered" >i</span>f(!fn){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>f</span>n.node.yieldCount++;<span class="cstat-no" title="statement not covered" >i</span>f(!isGeneratorAnnotation(fn.node.returnType)||maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar parent=path.parent;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=fn.node.returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='NullableTypeAnnotation'||annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!annotation.typeParameters||annotation.typeParameters.params.length===0){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar yieldType=annotation.typeParameters.params[0];<span class="cstat-no" title="statement not covered" >v</span>ar nextType=annotation.typeParameters.params[2];<span class="cstat-no" title="statement not covered" >v</span>ar ok=staticCheckAnnotation(path.get("argument"),yieldType);<span class="cstat-no" title="statement not covered" >i</span>f(ok===true&amp;&amp;!nextType){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'"'+fn.node.id.name+'" ':'')+'yielded an invalid type.',yieldType,getAnnotation(path.get('argument'))));}<span class="cstat-no" title="statement not covered" ></span>f</span></span>n.node.yieldGuardCount++;<span class="cstat-no" title="statement not covered" >i</span>f(fn.node.yieldGuard){<span class="cstat-no" title="statement not covered" >var _yielder=t.yieldExpression(t.callExpression(fn.node.yieldGuardName,[node.argument||t.identifier('undefined')]));<span class="cstat-no" title="statement not covered" >_</span>yielder.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >i</span>f(fn.node.nextGuard){<span class="cstat-no" title="statement not covered" >fn.node.nextGuardCount++;<span class="cstat-no" title="statement not covered" >p</span>ath.replaceWith(t.callExpression(fn.node.nextGuardName,[_yielder]));}</span>else {<span class="cstat-no" title="statement not covered" >path.replaceWith(_yielder);}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(fn.node.nextGuard){<span class="cstat-no" title="statement not covered" >fn.node.nextGuardCount++;<span class="cstat-no" title="statement not covered" >p</span>ath.replaceWith(t.callExpression(fn.node.nextGuardName,[yielder]));}</span>}</span></span>,ReturnStatement:<span class="fstat-no" title="function not covered" >function ReturnStatement(path,context){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!VisitorContext(context)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar fn=path.getFunctionParent();<span class="cstat-no" title="statement not covered" >i</span>f(!fn){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>f</span>n.node.returnCount++;<span class="cstat-no" title="statement not covered" >i</span>f(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar parent=path.parent;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar _fn$node=fn.node;<span class="cstat-no" title="statement not covered" >v</span>ar returnType=_fn$node.returnType;<span class="cstat-no" title="statement not covered" >v</span>ar returnGuardName=_fn$node.returnGuardName;<span class="cstat-no" title="statement not covered" >i</span>f(!returnType||!returnGuardName){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!node.argument){<span class="cstat-no" title="statement not covered" >if(maybeNullableAnnotation(returnType)===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'"'+fn.node.id.name+'" ':'')+'did not return a value.',returnType));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar annotation=returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isGeneratorAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1?annotation.typeParameters.params[1]:t.anyTypeAnnotation();}</span>else <span class="cstat-no" title="statement not covered" >if(node.async&amp;&amp;annotation.type==='GenericTypeAnnotation'&amp;&amp;annotation.id.name==='Promise'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters&amp;&amp;annotation.typeParameters[0]||t.anyTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar ok=staticCheckAnnotation(path.get("argument"),annotation);<span class="cstat-no" title="statement not covered" >i</span>f(ok===true){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'"'+fn.node.id.name+'" ':'')+'returned an invalid type.',annotation,getAnnotation(path.get('argument'))));}<span class="cstat-no" title="statement not covered" ></span>f</span></span>n.node.returnGuardCount++;<span class="cstat-no" title="statement not covered" >v</span>ar returner=t.returnStatement(t.callExpression(fn.node.returnGuardName,[node.argument]));<span class="cstat-no" title="statement not covered" >r</span>eturner.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >p</span>ath.replaceWith(returner);}</span>,VariableDeclaration:<span class="fstat-no" title="function not covered" >function VariableDeclaration(path,context){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!VisitorContext(context)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar collected=[];<span class="cstat-no" title="statement not covered" >v</span>ar declarations=path.get("declarations");<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;node.declarations.length;i++){<span class="cstat-no" title="statement not covered" >var declaration=node.declarations[i];<span class="cstat-no" title="statement not covered" >v</span>ar _id118=declaration.id;<span class="cstat-no" title="statement not covered" >v</span>ar init=declaration.init;<span class="cstat-no" title="statement not covered" >i</span>f(!_id118.typeAnnotation||_id118.hasBeenTypeChecked){<span class="cstat-no" title="statement not covered" >continue;}<span class="cstat-no" title="statement not covered" ></span>_</span>id118.savedTypeAnnotation=_id118.typeAnnotation;<span class="cstat-no" title="statement not covered" >_</span>id118.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >v</span>ar ok=staticCheckAnnotation(declarations[i],_id118.typeAnnotation);<span class="cstat-no" title="statement not covered" >i</span>f(ok===true){<span class="cstat-no" title="statement not covered" >continue;}</span>else <span class="cstat-no" title="statement not covered" >if(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid assignment value for "'+_id118.name+'".',_id118.typeAnnotation,getAnnotation(declarations[i])));}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar check=checkAnnotation(_id118,_id118.typeAnnotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >collected.push(guard({check:check,message:varTypeErrorMessage(_id118,context)}));}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(collected.length&gt;0){<span class="cstat-no" title="statement not covered" >var _check=collected.reduce(<span class="fstat-no" title="function not covered" >function(check,branch){<span class="cstat-no" title="statement not covered" ></span>branch.alternate=check;<span class="cstat-no" title="statement not covered" >r</span>eturn branch;}</span>);<span class="cstat-no" title="statement not covered" >i</span>f(path.parent.type==='Program'||path.parent.type==='BlockStatement'){<span class="cstat-no" title="statement not covered" >path.insertAfter(_check);}</span>else <span class="cstat-no" title="statement not covered" >if(path.parentPath.isForXStatement()||path.parentPath.isForStatement()||path.parentPath.isForInStatement()){<span class="cstat-no" title="statement not covered" >var body=path.parentPath.get('body');<span class="cstat-no" title="statement not covered" >i</span>f(body.type!=='BlockStatement'){<span class="cstat-no" title="statement not covered" >var block=t.blockStatement([body.node]);<span class="cstat-no" title="statement not covered" >b</span>ody.replaceWith(block);<span class="cstat-no" title="statement not covered" >b</span>ody=path.parentPath.get('body');}<span class="cstat-no" title="statement not covered" ></span>v</span>ar children=body.get('body');<span class="cstat-no" title="statement not covered" >i</span>f(children.length===0){<span class="cstat-no" title="statement not covered" >body.replaceWith(_check);}</span>else {<span class="cstat-no" title="statement not covered" >children[0].insertBefore(_check);}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(path.parent.type==='ExportNamedDeclaration'||path.parent.type==='ExportDefaultDeclaration'||path.parent.type==='ExportAllDeclaration'){<span class="cstat-no" title="statement not covered" >path.parentPath.insertAfter(_check);}</span>else {<span class="cstat-no" title="statement not covered" >path.replaceWith(t.blockStatement([node,_check]));}</span>}</span></span></span>}</span>,AssignmentExpression:<span class="fstat-no" title="function not covered" >function AssignmentExpression(path,context){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!VisitorContext(context)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar left=path.get('left');<span class="cstat-no" title="statement not covered" >v</span>ar annotation=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(node.hasBeenTypeChecked||node.left.hasBeenTypeChecked){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(left.isMemberExpression()){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(left);}</span>else <span class="cstat-no" title="statement not covered" >if(t.isIdentifier(node.left)){<span class="cstat-no" title="statement not covered" >var binding=scope.getBinding(node.left.name);<span class="cstat-no" title="statement not covered" >i</span>f(!binding){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(binding.path.type!=='VariableDeclarator'){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>a</span></span>nnotation=left.getTypeAnnotation();<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='AnyTypeAnnotation'){<span class="cstat-no" title="statement not covered" >var item=binding.path.get('id');<span class="cstat-no" title="statement not covered" >a</span>nnotation=item.node.savedTypeAnnotation||item.getTypeAnnotation();}</span>}</span>else {<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>n</span></span></span>ode.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >n</span>ode.left.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.left;<span class="cstat-no" title="statement not covered" >v</span>ar right=path.get('right');<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='AnyTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar ok=staticCheckAnnotation(right,annotation);<span class="cstat-no" title="statement not covered" >i</span>f(ok===true){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid assignment value for "'+humanReadableType(id)+'".',annotation,getAnnotation(right)));}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar check=checkAnnotation(id,annotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!id.typeAnnotation){<span class="cstat-no" title="statement not covered" >id.typeAnnotation=annotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>d.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >var parent=path.getStatementParent();<span class="cstat-no" title="statement not covered" >p</span>arent.insertAfter(guard({check:check,message:varTypeErrorMessage(id,context)}));}</span>}</span>,TypeCastExpression:<span class="fstat-no" title="function not covered" >function TypeCastExpression(path){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar target=void 0;<span class="cstat-no" title="statement not covered" >s</span>witch(node.expression.type){case 'Identifier':<span class="cstat-no" title="statement not covered" >target=node.expression;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 'AssignmentExpression':<span class="cstat-no" title="statement not covered" >target=node.expression.left;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault: // unsupported.</span>
<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>var id=path.scope.getBindingIdentifier(target.name);<span class="cstat-no" title="statement not covered" >i</span>f(!id){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>d.savedTypeAnnotation=path.getTypeAnnotation();}</span>,ForOfStatement:<span class="fstat-no" title="function not covered" >function ForOfStatement(path,context){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!VisitorContext(context)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar left=path.get('left');<span class="cstat-no" title="statement not covered" >i</span>f(!NodePath(left)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "left" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(left));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar right=path.get('right');<span class="cstat-no" title="statement not covered" >i</span>f(!NodePath(right)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "right" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(right));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar rightAnnotation=getAnnotation(right);<span class="cstat-no" title="statement not covered" >i</span>f(!TypeAnnotation(rightAnnotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "rightAnnotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(rightAnnotation));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar leftAnnotation=left.isVariableDeclaration()?getAnnotation(left.get('declarations')[0].get('id')):getAnnotation(left);<span class="cstat-no" title="statement not covered" >i</span>f(!TypeAnnotation(leftAnnotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "leftAnnotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(leftAnnotation));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(rightAnnotation.type!=='VoidTypeAnnotation'&amp;&amp;rightAnnotation.type!=='NullLiteralTypeAnnotation'){<span class="cstat-no" title="statement not covered" >var ok=maybeIterableAnnotation(rightAnnotation);<span class="cstat-no" title="statement not covered" >i</span>f(!(ok==null||typeof ok==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "ok" violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(ok));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError('Cannot iterate '+humanReadableType(rightAnnotation)+'.');}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar id=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(!(id==null||Identifier(id))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "id" violates contract.\n\nExpected:\n?Identifier\n\nGot:\n'+_inspect(id));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(right.isIdentifier()){<span class="cstat-no" title="statement not covered" >id=right.node;<span class="cstat-no" title="statement not covered" >i</span>f(!(id==null||Identifier(id))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "id" violates contract.\n\nExpected:\n?Identifier\n\nGot:\n'+_inspect(id));}</span>}</span>else {<span class="cstat-no" title="statement not covered" >id=path.scope.generateUidIdentifierBasedOnNode(right.node);<span class="cstat-no" title="statement not covered" >i</span>f(!(id==null||Identifier(id))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "id" violates contract.\n\nExpected:\n?Identifier\n\nGot:\n'+_inspect(id));}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.scope.push({id:id});<span class="cstat-no" title="statement not covered" >v</span>ar replacement=t.expressionStatement(t.assignmentExpression('=',id,right.node));<span class="cstat-no" title="statement not covered" >i</span>f(!Node(replacement)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "replacement" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(replacement));}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.insertBefore(replacement);<span class="cstat-no" title="statement not covered" >r</span>ight.replaceWith(id);}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.insertBefore(guard({check:checks.iterable({input:id}),message:t.binaryExpression('+',t.stringLiteral('Expected '+humanReadableType(right.node)+' to be iterable, got '),readableName({inspect:context.inspect,input:id}))}));<span class="cstat-no" title="statement not covered" >i</span>f(rightAnnotation.type!=='GenericTypeAnnotation'||rightAnnotation.id.name!=='Iterable'||!rightAnnotation.typeParameters||!rightAnnotation.typeParameters.params.length){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar annotation=rightAnnotation.typeParameters.params[0];<span class="cstat-no" title="statement not covered" >i</span>f(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(compareAnnotations(annotation,leftAnnotation)===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid iterator type.',annotation,leftAnnotation));}</span>}</span>,ClassDeclaration:<span class="fstat-no" title="function not covered" >function ClassDeclaration(path,context){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!VisitorContext(context)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}</span> </span>// Convert React props to propTypes
<span class="cstat-no" title="statement not covered" >if(!path.node.superClass){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar props=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(!(props==null||NodePath(props))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "props" violates contract.\n\nExpected:\n?NodePath\n\nGot:\n'+_inspect(props));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar hasRenderMethod=false;<span class="cstat-no" title="statement not covered" >_</span>path$get=path.get('body.body');<span class="cstat-no" title="statement not covered" >i</span>f(!(_path$get&amp;&amp;(typeof _path$get[Symbol.iterator]==='function'||Array.isArray(_path$get)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _path$get to be iterable, got '+_inspect(_path$get));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion2=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError2=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError2=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator2=_path$get[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=true){<span class="cstat-no" title="statement not covered" >var _path$get;<span class="cstat-no" title="statement not covered" >v</span>ar memberPath=_step2.value;<span class="cstat-no" title="statement not covered" >v</span>ar classMember=memberPath.node;<span class="cstat-no" title="statement not covered" >i</span>f(t.isClassProperty(classMember)){<span class="cstat-no" title="statement not covered" >if(classMember.key.name==='propTypes'&amp;&amp;classMember.static){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(classMember.key.name==='props'&amp;&amp;!classMember.static){<span class="cstat-no" title="statement not covered" >props=memberPath;<span class="cstat-no" title="statement not covered" >i</span>f(!(props==null||NodePath(props))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "props" violates contract.\n\nExpected:\n?NodePath\n\nGot:\n'+_inspect(props));}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(t.isClassMethod(classMember)&amp;&amp;classMember.key.name==='render'){<span class="cstat-no" title="statement not covered" >hasRenderMethod=true;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError2=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError2=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion2&amp;&amp;_iterator2.return){<span class="cstat-no" title="statement not covered" >_iterator2.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError2){<span class="cstat-no" title="statement not covered" >throw _iteratorError2;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar type=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(!(type==null||Node(type))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "type" violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(type));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(path.node.superTypeParameters){<span class="cstat-no" title="statement not covered" >if(path.node.superTypeParameters.params.length!==3){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>t</span>ype=path.node.superTypeParameters.params[1];<span class="cstat-no" title="statement not covered" >i</span>f(!(type==null||Node(type))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "type" violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(type));}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(props){<span class="cstat-no" title="statement not covered" >type=props.node.typeAnnotation.typeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(!(type==null||Node(type))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "type" violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(type));}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!type||!hasRenderMethod){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t.isGenericTypeAnnotation(type)){<span class="cstat-no" title="statement not covered" >var binding=path.scope.getBinding(type.id.name);<span class="cstat-no" title="statement not covered" >t</span>ype=getAnnotation(binding.path);<span class="cstat-no" title="statement not covered" >i</span>f(!(type==null||Node(type))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "type" violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(type));}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!t.isObjectTypeAnnotation(type)){<span class="cstat-no" title="statement not covered" >return;}</span> </span>// Now we have a class that has a superclass, an instance method called 'render'
// and some property type annotations. We can be reasonably sure it's a React component.
<span class="cstat-no" title="statement not covered" >var propTypes=t.objectExpression(type.properties.map(<span class="fstat-no" title="function not covered" >function(prop){<span class="cstat-no" title="statement not covered" ></span>return t.objectProperty(t.identifier(prop.key.name),generatePropType(prop.value,path.scope,context));}</span>));<span class="cstat-no" title="statement not covered" >i</span>f(path.node.decorators){<span class="cstat-no" title="statement not covered" >var property=t.classProperty(t.identifier('propTypes'),propTypes);<span class="cstat-no" title="statement not covered" >p</span>roperty.static=true;<span class="cstat-no" title="statement not covered" >p</span>rops.insertAfter(property);}</span>else {<span class="cstat-no" title="statement not covered" >var root=path.parentPath.isExportDeclaration()?path.parentPath:path;<span class="cstat-no" title="statement not covered" >i</span>f(!NodePath(root)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "root" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(root));}<span class="cstat-no" title="statement not covered" ></span>r</span>oot.insertAfter(t.expressionStatement(t.assignmentExpression("=",t.memberExpression(path.node.id,t.identifier("propTypes")),propTypes)));}</span>}</span>}; /**
   * Collect all the type declarations in the given path and add references to them for retreival later.
   */<span class="fstat-no" title="function not covered" >function collectTypes(path){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.traverse({InterfaceDeclaration:<span class="fstat-no" title="function not covered" >function InterfaceDeclaration(path){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.scope.setData('typechecker:'+path.node.id.name,path);}</span>,TypeAlias:<span class="fstat-no" title="function not covered" >function TypeAlias(path){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.scope.setData('typechecker:'+path.node.id.name,path);}</span>,ImportDeclaration:<span class="fstat-no" title="function not covered" >function ImportDeclaration(path){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(path.node.importKind!=='type'){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.get('specifiers').forEach(<span class="fstat-no" title="function not covered" >function(specifier){<span class="cstat-no" title="statement not covered" ></span>var local=specifier.get('local');<span class="cstat-no" title="statement not covered" >i</span>f(local.isIdentifier()){<span class="cstat-no" title="statement not covered" >path.scope.setData('typechecker:'+local.node.name,specifier);}</span>else {<span class="cstat-no" title="statement not covered" >path.scope.setData('typechecker:'+local.node.id.name,specifier);}</span>}</span>);}</span>,"Function|Class":<span class="fstat-no" title="function not covered" >function FunctionClass(path){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.typeParameters&amp;&amp;node.typeParameters.params){<span class="cstat-no" title="statement not covered" >path.get('typeParameters').get('params').forEach(<span class="fstat-no" title="function not covered" >function(typeParam){<span class="cstat-no" title="statement not covered" ></span>path.get('body').scope.setData('typeparam:'+typeParam.node.name,typeParam);}</span>);}</span>}</span>});}<span class="cstat-no" title="statement not covered" ></span>return {visitor:{Program:<span class="fstat-no" title="function not covered" >function Program(path,_ref107){<span class="cstat-no" title="statement not covered" ></span>var opts=_ref107.opts;<span class="cstat-no" title="statement not covered" >i</span>f(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(opts&amp;&amp;opts.disable&amp;&amp;opts.disable[process.env.NODE_ENV]){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checkFile=false;<span class="cstat-no" title="statement not covered" >_</span>path$get2=path.get('body');<span class="cstat-no" title="statement not covered" >i</span>f(!(_path$get2&amp;&amp;(typeof _path$get2[Symbol.iterator]==='function'||Array.isArray(_path$get2)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _path$get2 to be iterable, got '+_inspect(_path$get2));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion3=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError3=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError3=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator3=_path$get2[Symbol.iterator](),_step3;!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=true){<span class="cstat-no" title="statement not covered" >var _path$get2;<span class="cstat-no" title="statement not covered" >v</span>ar _child=_step3.value;<span class="cstat-no" title="statement not covered" >i</span>f(mustCheckFile(_child,opts)){<span class="cstat-no" title="statement not covered" >checkFile=true;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError3=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError3=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion3&amp;&amp;_iterator3.return){<span class="cstat-no" title="statement not covered" >_iterator3.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError3){<span class="cstat-no" title="statement not covered" >throw _iteratorError3;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!checkFile){<span class="cstat-no" title="statement not covered" >_path$get3=path.get('body');<span class="cstat-no" title="statement not covered" >i</span>f(!(_path$get3&amp;&amp;(typeof _path$get3[Symbol.iterator]==='function'||Array.isArray(_path$get3)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _path$get3 to be iterable, got '+_inspect(_path$get3));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion4=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError4=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError4=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator4=_path$get3[Symbol.iterator](),_step4;!(_iteratorNormalCompletion4=(_step4=_iterator4.next()).done);_iteratorNormalCompletion4=true){<span class="cstat-no" title="statement not covered" >var _path$get3;<span class="cstat-no" title="statement not covered" >v</span>ar child=_step4.value;<span class="cstat-no" title="statement not covered" >i</span>f(maybeSkipFile(child,opts)){<span class="cstat-no" title="statement not covered" >return;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError4=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError4=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion4&amp;&amp;_iterator4.return){<span class="cstat-no" title="statement not covered" >_iterator4.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError4){<span class="cstat-no" title="statement not covered" >throw _iteratorError4;}</span>}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>c</span>ollectTypes(path);<span class="cstat-no" title="statement not covered" >v</span>ar inspect=path.scope.generateUidIdentifier('inspect');<span class="cstat-no" title="statement not covered" >v</span>ar requiresHelpers={inspect:false};<span class="cstat-no" title="statement not covered" >v</span>ar context={get inspect<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>requiresHelpers.inspect=true;<span class="cstat-no" title="statement not covered" >r</span>eturn inspect;}</span>};<span class="cstat-no" title="statement not covered" >p</span>ath.traverse(visitors,context);<span class="cstat-no" title="statement not covered" >i</span>f(requiresHelpers.inspect){<span class="cstat-no" title="statement not covered" >var body=path.get('body');<span class="cstat-no" title="statement not covered" >b</span>ody[body.length-1].insertAfter(template('\n            function id (input, depth) {\n              const maxDepth = 4;\n              const maxKeys = 15;\n              if (depth === undefined) {\n                depth = 0;\n              }\n              depth += 1;\n              if (input === null) {\n                return \'null\';\n              }\n              else if (input === undefined) {\n                return \'void\';\n              }\n              else if (typeof input === \'string\' || typeof input === \'number\' || typeof input === \'boolean\') {\n                return typeof input;\n              }\n              else if (Array.isArray(input)) {\n                if (input.length &gt; 0) {\n                  if (depth &gt; maxDepth) return \'[...]\';\n                  const first = id(input[0], depth);\n                  if (input.every(item =&gt; id(item, depth) === first)) {\n                    return first.trim() + \'[]\';\n                  }\n                  else {\n                    return \'[\' + input.slice(0, maxKeys).map(item =&gt; id(item, depth)).join(\', \') + (input.length &gt;= maxKeys ? \', ...\' : \'\') + \']\';\n                  }\n                }\n                else {\n                  return \'Array\';\n                }\n              }\n              else {\n                const keys = Object.keys(input);\n                if (!keys.length) {\n                  if (input.constructor &amp;&amp; input.constructor.name &amp;&amp; input.constructor.name !== \'Object\') {\n                    return input.constructor.name;\n                  }\n                  else {\n                    return \'Object\';\n                  }\n                }\n                if (depth &gt; maxDepth) return \'{...}\';\n                const indent = \'  \'.repeat(depth - 1);\n                let entries = keys.slice(0, maxKeys).map(key =&gt; {\n                  return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key) ? key : JSON.stringify(key)) + \': \' + id(input[key], depth) + \';\';\n                }).join(\'\\n  \' + indent);\n                if (keys.length &gt;= maxKeys) {\n                  entries += \'\\n  \' + indent + \'...\';\n                }\n                if (input.constructor &amp;&amp; input.constructor.name &amp;&amp; input.constructor.name !== \'Object\') {\n                  return input.constructor.name + \' {\\n  \' + indent + entries + \'\\n\' + indent + \'}\';\n                }\n                else {\n                  return \'{\\n  \' + indent + entries + \'\\n\' + indent + \'}\';\n                }\n              }\n            }\n          ')({id:inspect}));}</span>}</span>}}; </span>/**
   * Create a function which can verify the return type for a function.
   */<span class="fstat-no" title="function not covered" >function createFunctionReturnGuard(path,context){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!VisitorContext(context)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isGeneratorAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1?annotation.typeParameters.params[1]:t.anyTypeAnnotation();}</span>else <span class="cstat-no" title="statement not covered" >if(node.async&amp;&amp;annotation.type==='GenericTypeAnnotation'&amp;&amp;annotation.id.name==='Promise'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters&amp;&amp;annotation.typeParameters[0]||t.anyTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar name=scope.generateUidIdentifierBasedOnNode(node);<span class="cstat-no" title="statement not covered" >v</span>ar id=scope.generateUidIdentifier('id');<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(id,annotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >node.returnGuard=guardFn({id:id,name:name,check:check,message:returnTypeErrorMessage(path,path.node,id,context)});<span class="cstat-no" title="statement not covered" >n</span>ode.returnGuard.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >n</span>ode.returnGuardName=name;<span class="cstat-no" title="statement not covered" >n</span>ode.returnGuardCount=0;}</span>}<span class="fstat-no" title="function not covered" ></span>function createFunctionYieldGuards(path,context){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!VisitorContext(context)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='NullableTypeAnnotation'||annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!annotation.typeParameters||annotation.typeParameters.params.length===0){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!isGeneratorAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar yieldType=annotation.typeParameters.params[0];<span class="cstat-no" title="statement not covered" >v</span>ar nextType=annotation.typeParameters.params[2];<span class="cstat-no" title="statement not covered" >i</span>f(yieldType){<span class="cstat-no" title="statement not covered" >var _name=scope.generateUidIdentifier('check'+(node.id?node.id.name.slice(0,1).toUpperCase()+node.id.name.slice(1):'')+'Yield');<span class="cstat-no" title="statement not covered" >v</span>ar _id119=scope.generateUidIdentifier('id');<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(_id119,yieldType,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >node.yieldGuard=guardFn({id:_id119,name:_name,check:check,message:yieldTypeErrorMessage(node,yieldType,_id119,context)});<span class="cstat-no" title="statement not covered" >n</span>ode.yieldGuardName=_name;<span class="cstat-no" title="statement not covered" >n</span>ode.yieldGuardCount=0;}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(nextType){<span class="cstat-no" title="statement not covered" >var _name2=scope.generateUidIdentifier('check'+(node.id?node.id.name.slice(0,1).toUpperCase()+node.id.name.slice(1):'')+'Next');<span class="cstat-no" title="statement not covered" >v</span>ar _id120=scope.generateUidIdentifier('id');<span class="cstat-no" title="statement not covered" >v</span>ar _check2=checkAnnotation(_id120,nextType,scope);<span class="cstat-no" title="statement not covered" >i</span>f(_check2){<span class="cstat-no" title="statement not covered" >node.nextGuard=guardFn({id:_id120,name:_name2,check:_check2,message:yieldNextTypeErrorMessage(node,nextType,_id120,context)});<span class="cstat-no" title="statement not covered" >n</span>ode.nextGuardName=_name2;<span class="cstat-no" title="statement not covered" >n</span>ode.nextGuardCount=0;}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function isThisMemberExpression(path){<span class="fstat-no" title="function not covered" ></span>function _ref4(_id17){<span class="cstat-no" title="statement not covered" ></span>if(!(typeof _id17==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "isThisMemberExpression" return value violates contract.\n\nExpected:\nbool\n\nGot:\n'+_inspect(_id17));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id17;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='ThisExpression'){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='MemberExpression'){<span class="cstat-no" title="statement not covered" >return _ref4(isThisMemberExpression(path.get('object')));}</span>else {<span class="cstat-no" title="statement not covered" >return false;}</span>}<span class="fstat-no" title="function not covered" ></span></span>function isGeneratorAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>if(!(annotation==null||TypeAnnotation(annotation))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!annotation){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(annotation.type==='TypeAnnotation'||annotation.type==='NullableTypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn annotation.type==='GenericTypeAnnotation'&amp;&amp;annotation.id.name==='Generator';}<span class="fstat-no" title="function not covered" ></span>function buildErrorMessage(message,expected,got){<span class="cstat-no" title="statement not covered" ></span>if(!(typeof message==='string')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "message" violates contract.\n\nExpected:\nstring\n\nGot:\n'+_inspect(message));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!TypeAnnotation(expected)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "expected" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(expected));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!(got==null||Node(got))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "got" violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(got));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(got){<span class="cstat-no" title="statement not covered" >return message+'\n\nExpected:\n'+humanReadableType(expected)+'\n\nGot:\n'+humanReadableType(got);}</span>else {<span class="cstat-no" title="statement not covered" >return message+'\n\nExpected:\n'+humanReadableType(expected);}</span>}<span class="fstat-no" title="function not covered" ></span>function createChecks(){<span class="cstat-no" title="statement not covered" ></span>return {number:expression('typeof input === \'number\''),numericLiteral:checkNumericLiteral,boolean:expression('typeof input === \'boolean\''),booleanLiteral:checkBooleanLiteral,class:checkClass,function:expression('typeof input === \'function\''),string:expression('typeof input === \'string\''),stringLiteral:checkStringLiteral,symbol:expression('typeof input === \'symbol\''),undefined:expression('input === undefined'),null:expression('input === null'),void:expression('input == null'),instanceof:expression('input instanceof type'),type:expression('type(input)'),mixed:<span class="fstat-no" title="function not covered" >function mixed(){<span class="cstat-no" title="statement not covered" ></span>return null;}</span>,any:<span class="fstat-no" title="function not covered" >function any(){<span class="cstat-no" title="statement not covered" ></span>return null;}</span>,union:checkUnion,intersection:checkIntersection,array:checkArray,map:checkMap,set:checkSet,generator:checkGenerator,iterable:checkIterable,tuple:checkTuple,object:checkObject,nullable:checkNullable,typeof:checkTypeof,int8:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= -128 &amp;&amp; input &lt;= 127 &amp;&amp; input === Math.floor(input)'),uint8:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= 0 &amp;&amp; input &lt;= 255 &amp;&amp; input === Math.floor(input)'),int16:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= -32768 &amp;&amp; input &lt;= 32767 &amp;&amp; input === Math.floor(input)'),uint16:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= 0 &amp;&amp; input &lt;= 65535 &amp;&amp; input === Math.floor(input)'),int32:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= -2147483648 &amp;&amp; input &lt;= 2147483647 &amp;&amp; input === Math.floor(input)'),uint32:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= 0 &amp;&amp; input &lt;= 4294967295 &amp;&amp; input === Math.floor(input)'),float32:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= -3.40282347e+38 &amp;&amp; input &lt;= 3.40282347e+38'),float64:expression('typeof input === \'number\' &amp;&amp; !isNaN(input)'),double:expression('typeof input === \'number\' &amp;&amp; !isNaN(input)')};}<span class="fstat-no" title="function not covered" ></span>function createStaticChecks(){<span class="cstat-no" title="statement not covered" ></span>return {symbol:<span class="fstat-no" title="function not covered" >function symbol(path){<span class="fstat-no" title="function not covered" ></span>function _symbol(_id21){<span class="cstat-no" title="statement not covered" ></span>if(!(_id21==null||typeof _id21==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id21));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id21;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _symbol(maybeSymbolAnnotation(getAnnotation(path)));}</span>,instanceof:<span class="fstat-no" title="function not covered" >function _instanceof(_ref108){<span class="cstat-no" title="statement not covered" ></span>var path=_ref108.path;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref108.annotation;<span class="fstat-no" title="function not covered" >f</span>unction _instanceof(_id22){<span class="cstat-no" title="statement not covered" ></span>if(!(_id22==null||typeof _id22==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id22));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id22;}<span class="cstat-no" title="statement not covered" ></span>var type=createTypeExpression(annotation.id);<span class="cstat-no" title="statement not covered" >v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >i</span>f(type.name==='Object'&amp;&amp;node.type==='ObjectExpression'&amp;&amp;!scope.getBinding('Object')){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='Map'&amp;&amp;!scope.getBinding('Map')){<span class="cstat-no" title="statement not covered" >return _instanceof(null);}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='Set'&amp;&amp;!scope.getBinding('Set')){<span class="cstat-no" title="statement not covered" >return _instanceof(null);}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='Class'&amp;&amp;!scope.hasBinding('Class')){<span class="cstat-no" title="statement not covered" >return _instanceof(null);}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='int8'&amp;&amp;!scope.hasBinding('int8')){<span class="cstat-no" title="statement not covered" >return _instanceof(null);}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='uint8'&amp;&amp;!scope.hasBinding('uint8')){<span class="cstat-no" title="statement not covered" >return _instanceof(null);}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='int16'&amp;&amp;!scope.hasBinding('int16')){<span class="cstat-no" title="statement not covered" >return _instanceof(null);}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='uint16'&amp;&amp;!scope.hasBinding('uint16')){<span class="cstat-no" title="statement not covered" >return _instanceof(null);}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='int32'&amp;&amp;!scope.hasBinding('int32')){<span class="cstat-no" title="statement not covered" >return _instanceof(null);}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='uint32'&amp;&amp;!scope.hasBinding('uint32')){<span class="cstat-no" title="statement not covered" >return _instanceof(null);}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='float32'&amp;&amp;!scope.hasBinding('float32')){<span class="cstat-no" title="statement not covered" >return _instanceof(null);}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='float64'&amp;&amp;!scope.hasBinding('float64')){<span class="cstat-no" title="statement not covered" >return _instanceof(null);}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='double'&amp;&amp;!scope.hasBinding('double')){<span class="cstat-no" title="statement not covered" >return _instanceof(null);}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span></span></span></span></span></span></span></span></span></span>eturn _instanceof(maybeInstanceOfAnnotation(getAnnotation(path),type,annotation.typeParameters?annotation.typeParameters.params:[]));}</span>,type:<span class="fstat-no" title="function not covered" >function(_type2){<span class="fstat-no" title="function not covered" ></span>function type(_x){<span class="cstat-no" title="statement not covered" ></span>return _type2.apply(this,arguments);}<span class="cstat-no" title="statement not covered" ></span>type.toString=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return _type2.toString();}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn type;}</span>(<span class="fstat-no" title="function not covered" >function(_ref109){<span class="cstat-no" title="statement not covered" ></span>var path=_ref109.path;<span class="cstat-no" title="statement not covered" >v</span>ar type=_ref109.type;<span class="fstat-no" title="function not covered" >f</span>unction _type(_id23){<span class="cstat-no" title="statement not covered" ></span>if(!(_id23==null||typeof _id23==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id23));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id23;}<span class="cstat-no" title="statement not covered" ></span>return _type(null);}</span>)};}<span class="fstat-no" title="function not covered" ></span>function compareAnnotations(a,b){<span class="fstat-no" title="function not covered" ></span>function _ref8(_id24){<span class="cstat-no" title="statement not covered" ></span>if(!(_id24==null||typeof _id24==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "compareAnnotations" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id24));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id24;}<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(a)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(a));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!TypeAnnotation(b)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(b));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(a.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >a=a.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(b.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >b=b.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(a.type){case 'StringTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref8(maybeStringAnnotation(b));c</span>ase 'StringLiteral':case 'StringLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref8(compareStringLiteralAnnotations(a,b));c</span>ase 'NumberTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref8(maybeNumberAnnotation(b));c</span>ase 'NumericLiteral':case 'NumericLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref8(compareNumericLiteralAnnotations(a,b));c</span>ase 'BooleanTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref8(maybeBooleanAnnotation(b));c</span>ase 'BooleanLiteral':case 'BooleanLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref8(compareBooleanLiteralAnnotations(a,b));c</span>ase 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref8(maybeFunctionAnnotation(b));c</span>ase 'AnyTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref8(null);c</span>ase 'MixedTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref8(null);c</span>ase 'ObjectTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref8(compareObjectAnnotation(a,b));c</span>ase 'ArrayTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref8(compareArrayAnnotation(a,b));c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref8(compareGenericAnnotation(a,b));c</span>ase 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref8(compareTupleAnnotation(a,b));c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref8(compareUnionAnnotation(a,b));c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref8(compareIntersectionAnnotation(a,b));c</span>ase 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref8(compareNullableAnnotation(a,b));d</span>efault:<span class="cstat-no" title="statement not covered" >return _ref8(null);}</span>}<span class="fstat-no" title="function not covered" ></span>function compareStringLiteralAnnotations(a,b){<span class="cstat-no" title="statement not covered" ></span>if(!StringLiteralTypeAnnotation(a)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nStringLiteralTypeAnnotation\n\nGot:\n'+_inspect(a));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!TypeAnnotation(b)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(b));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(b.type==='StringLiteralTypeAnnotation'||b.type==='StringLiteral'){<span class="cstat-no" title="statement not covered" >return a.value===b.value;}</span>else {<span class="cstat-no" title="statement not covered" >return maybeStringAnnotation(b)===false?false:null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareBooleanLiteralAnnotations(a,b){<span class="cstat-no" title="statement not covered" ></span>if(!BooleanLiteralTypeAnnotation(a)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nBooleanLiteralTypeAnnotation\n\nGot:\n'+_inspect(a));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!TypeAnnotation(b)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(b));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(b.type==='BooleanLiteralTypeAnnotation'||b.type==='BooleanLiteral'){<span class="cstat-no" title="statement not covered" >return a.value===b.value;}</span>else {<span class="cstat-no" title="statement not covered" >return maybeBooleanAnnotation(b)===false?false:null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareNumericLiteralAnnotations(a,b){<span class="cstat-no" title="statement not covered" ></span>if(!NumericLiteralTypeAnnotation(a)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nNumericLiteralTypeAnnotation\n\nGot:\n'+_inspect(a));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!TypeAnnotation(b)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(b));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(b.type==='NumericLiteralTypeAnnotation'||b.type==='NumericLiteral'){<span class="cstat-no" title="statement not covered" >return a.value===b.value;}</span>else {<span class="cstat-no" title="statement not covered" >return maybeNumberAnnotation(b)===false?false:null;}</span>}<span class="fstat-no" title="function not covered" ></span>function unionComparer(a,b,comparator){<span class="fstat-no" title="function not covered" ></span>function _ref12(_id28){<span class="cstat-no" title="statement not covered" ></span>if(!(_id28==null||typeof _id28==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "unionComparer" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id28));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id28;}<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(a)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(a));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!TypeAnnotation(b)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(b));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!(typeof comparator==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "comparator" violates contract.\n\nExpected:\n(TypeAnnotation, TypeAnnotation) =&gt; ?bool\n\nGot:\n'+_inspect(comparator));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!a.types||a.types.length===0){<span class="cstat-no" title="statement not covered" >return _ref12(null);}<span class="cstat-no" title="statement not covered" ></span>v</span>ar falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar trueCount=0;<span class="cstat-no" title="statement not covered" >i</span>f(!a.types){<span class="cstat-no" title="statement not covered" >return _ref12(null);}<span class="cstat-no" title="statement not covered" ></span>_</span>a$types=a.types;<span class="cstat-no" title="statement not covered" >i</span>f(!(_a$types&amp;&amp;(typeof _a$types[Symbol.iterator]==='function'||Array.isArray(_a$types)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _a$types to be iterable, got '+_inspect(_a$types));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion5=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError5=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError5=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator5=_a$types[Symbol.iterator](),_step5;!(_iteratorNormalCompletion5=(_step5=_iterator5.next()).done);_iteratorNormalCompletion5=true){<span class="cstat-no" title="statement not covered" >var _a$types;<span class="cstat-no" title="statement not covered" >v</span>ar _type3=_step5.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=comparator(_type3,b);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >if(b.type!=='UnionTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return true;}<span class="cstat-no" title="statement not covered" ></span>t</span>rueCount++;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >if(b.type==='UnionTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>f</span>alseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError5=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError5=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion5&amp;&amp;_iterator5.return){<span class="cstat-no" title="statement not covered" >_iterator5.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError5){<span class="cstat-no" title="statement not covered" >throw _iteratorError5;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===a.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else <span class="cstat-no" title="statement not covered" >if(trueCount===a.types.length){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return _ref12(null);}</span>}<span class="fstat-no" title="function not covered" ></span></span>function intersectionComparer(a,b,comparator){<span class="fstat-no" title="function not covered" ></span>function _ref13(_id29){<span class="cstat-no" title="statement not covered" ></span>if(!(_id29==null||typeof _id29==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "intersectionComparer" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id29));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id29;}<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(a)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(a));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!TypeAnnotation(b)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(b));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!(typeof comparator==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "comparator" violates contract.\n\nExpected:\n(TypeAnnotation, TypeAnnotation) =&gt; ?bool\n\nGot:\n'+_inspect(comparator));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar trueCount=0;<span class="cstat-no" title="statement not covered" >i</span>f(!a.types){<span class="cstat-no" title="statement not covered" >return _ref13(null);}<span class="cstat-no" title="statement not covered" ></span>_</span>a$types2=a.types;<span class="cstat-no" title="statement not covered" >i</span>f(!(_a$types2&amp;&amp;(typeof _a$types2[Symbol.iterator]==='function'||Array.isArray(_a$types2)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _a$types2 to be iterable, got '+_inspect(_a$types2));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion6=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError6=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError6=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator6=_a$types2[Symbol.iterator](),_step6;!(_iteratorNormalCompletion6=(_step6=_iterator6.next()).done);_iteratorNormalCompletion6=true){<span class="cstat-no" title="statement not covered" >var _a$types2;<span class="cstat-no" title="statement not covered" >v</span>ar _type4=_step6.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=comparator(_type4,b);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >trueCount++;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >return false;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError6=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError6=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion6&amp;&amp;_iterator6.return){<span class="cstat-no" title="statement not covered" >_iterator6.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError6){<span class="cstat-no" title="statement not covered" >throw _iteratorError6;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(trueCount===a.types.length){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return _ref13(null);}</span>}<span class="fstat-no" title="function not covered" ></span>function compareObjectAnnotation(a,b){<span class="fstat-no" title="function not covered" ></span>function _ref14(_id30){<span class="cstat-no" title="statement not covered" ></span>if(!(_id30==null||typeof _id30==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "compareObjectAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id30));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id30;}<span class="cstat-no" title="statement not covered" ></span>if(!Node(a)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(a));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!Node(b)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(b));}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(b.type){case 'ObjectTypeAnnotation':<span class="cstat-no" title="statement not covered" >break;c</span>ase 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref14(compareObjectAnnotation(a,b.typeAnnotation));c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref14(unionComparer(a,b,compareObjectAnnotation));c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref14(intersectionComparer(a,b,compareObjectAnnotation));c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return _ref14(null);}</span> </span>// We're comparing two object annotations.
<span class="cstat-no" title="statement not covered" >var allTrue=true;<span class="cstat-no" title="statement not covered" >_</span>a$properties=a.properties;<span class="cstat-no" title="statement not covered" >i</span>f(!(_a$properties&amp;&amp;(typeof _a$properties[Symbol.iterator]==='function'||Array.isArray(_a$properties)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _a$properties to be iterable, got '+_inspect(_a$properties));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion7=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError7=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError7=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator7=_a$properties[Symbol.iterator](),_step7;!(_iteratorNormalCompletion7=(_step7=_iterator7.next()).done);_iteratorNormalCompletion7=true){<span class="cstat-no" title="statement not covered" >var _a$properties;<span class="cstat-no" title="statement not covered" >v</span>ar aprop=_step7.value;<span class="cstat-no" title="statement not covered" >v</span>ar found=false;<span class="cstat-no" title="statement not covered" >_</span>b$properties=b.properties;<span class="cstat-no" title="statement not covered" >i</span>f(!(_b$properties&amp;&amp;(typeof _b$properties[Symbol.iterator]==='function'||Array.isArray(_b$properties)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _b$properties to be iterable, got '+_inspect(_b$properties));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion8=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError8=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError8=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator8=_b$properties[Symbol.iterator](),_step8;!(_iteratorNormalCompletion8=(_step8=_iterator8.next()).done);_iteratorNormalCompletion8=true){<span class="cstat-no" title="statement not covered" >var _b$properties;<span class="cstat-no" title="statement not covered" >v</span>ar bprop=_step8.value;<span class="cstat-no" title="statement not covered" >i</span>f(bprop.key.name===aprop.key.name){<span class="cstat-no" title="statement not covered" >var result=compareAnnotations(aprop.value,bprop.value);<span class="cstat-no" title="statement not covered" >i</span>f(result===false&amp;&amp;!(aprop.optional&amp;&amp;(bprop.optional||maybeNullableAnnotation(bprop.value)===true))){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >found=result;}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError8=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError8=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion8&amp;&amp;_iterator8.return){<span class="cstat-no" title="statement not covered" >_iterator8.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError8){<span class="cstat-no" title="statement not covered" >throw _iteratorError8;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(found===false&amp;&amp;!aprop.optional){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>a</span>llTrue=allTrue&amp;&amp;found===true;}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError7=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError7=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion7&amp;&amp;_iterator7.return){<span class="cstat-no" title="statement not covered" >_iterator7.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError7){<span class="cstat-no" title="statement not covered" >throw _iteratorError7;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn allTrue?true:null;}<span class="fstat-no" title="function not covered" ></span>function compareArrayAnnotation(a,b){<span class="fstat-no" title="function not covered" ></span>function _ref15(_id31){<span class="cstat-no" title="statement not covered" ></span>if(!(_id31==null||typeof _id31==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "compareArrayAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id31));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id31;}<span class="cstat-no" title="statement not covered" ></span>if(!Node(a)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(a));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!Node(b)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(b));}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref15(compareArrayAnnotation(a,b.typeAnnotation));c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref15(unionComparer(a,b,compareArrayAnnotation));c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref15(intersectionComparer(a,b,compareArrayAnnotation));c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return _ref15(null);}</span>}<span class="fstat-no" title="function not covered" ></span>function compareGenericAnnotation(a,b){<span class="fstat-no" title="function not covered" ></span>function _ref16(_id32){<span class="cstat-no" title="statement not covered" ></span>if(!(_id32==null||typeof _id32==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "compareGenericAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id32));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id32;}<span class="cstat-no" title="statement not covered" ></span>if(!Node(a)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(a));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!Node(b)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(b));}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref16(compareGenericAnnotation(a,b.typeAnnotation));c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(b.id.name===a.id.name){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return _ref16(null);}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref16(unionComparer(a,b,compareGenericAnnotation));c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref16(intersectionComparer(a,b,compareGenericAnnotation));d</span>efault:<span class="cstat-no" title="statement not covered" >return _ref16(null);}</span>}<span class="fstat-no" title="function not covered" ></span>function compareTupleAnnotation(a,b){<span class="fstat-no" title="function not covered" ></span>function _ref17(_id33){<span class="cstat-no" title="statement not covered" ></span>if(!(_id33==null||typeof _id33==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "compareTupleAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id33));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id33;}<span class="cstat-no" title="statement not covered" ></span>if(!Node(a)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(a));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!Node(b)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(b));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(b.type==='TupleTypeAnnotation'){<span class="cstat-no" title="statement not covered" >if(b.types.length===0){<span class="cstat-no" title="statement not covered" >return _ref17(null);}</span>else <span class="cstat-no" title="statement not covered" >if(b.types.length&lt;a.types.length){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn _ref17(a.types.every(<span class="fstat-no" title="function not covered" >function(type,index){<span class="cstat-no" title="statement not covered" ></span>return compareAnnotations(type,b.types[index]);}</span>));}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref17(compareTupleAnnotation(a,b.typeAnnotation));c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref17(unionComparer(a,b,compareTupleAnnotation));c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref17(intersectionComparer(a,b,compareTupleAnnotation));c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return _ref17(null);}</span>}<span class="fstat-no" title="function not covered" ></span>function compareUnionAnnotation(a,b){<span class="fstat-no" title="function not covered" ></span>function _ref18(_id34){<span class="cstat-no" title="statement not covered" ></span>if(!(_id34==null||typeof _id34==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "compareUnionAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id34));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id34;}<span class="cstat-no" title="statement not covered" ></span>if(!Node(a)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(a));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!Node(b)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(b));}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(b.type){case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref18(compareUnionAnnotation(a,b.typeAnnotation));c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref18(null);d</span>efault:<span class="cstat-no" title="statement not covered" >return _ref18(unionComparer(a,b,compareAnnotations));}</span>}<span class="fstat-no" title="function not covered" ></span>function compareNullableAnnotation(a,b){<span class="fstat-no" title="function not covered" ></span>function _ref19(_id35){<span class="cstat-no" title="statement not covered" ></span>if(!(_id35==null||typeof _id35==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "compareNullableAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id35));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id35;}<span class="cstat-no" title="statement not covered" ></span>if(!Node(a)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(a));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!Node(b)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(b));}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return _ref19(compareNullableAnnotation(a,b.typeAnnotation));c</span>ase 'NullableTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref19(null);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(compareAnnotations(a.typeAnnotation,b)===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return _ref19(null);}</span>}<span class="fstat-no" title="function not covered" ></span>function arrayExpressionToTupleAnnotation(path){<span class="fstat-no" title="function not covered" ></span>function _ref20(_id36){<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(_id36)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "arrayExpressionToTupleAnnotation" return value violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(_id36));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id36;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar elements=path.get('elements');<span class="cstat-no" title="statement not covered" >r</span>eturn _ref20(t.tupleTypeAnnotation(elements.map(<span class="fstat-no" title="function not covered" >function(element){<span class="cstat-no" title="statement not covered" ></span>return getAnnotation(element);}</span>)));}<span class="fstat-no" title="function not covered" ></span>function checkNullable(_ref110){<span class="cstat-no" title="statement not covered" ></span>var input=_ref110.input;<span class="cstat-no" title="statement not covered" >v</span>ar type=_ref110.type;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref110.scope;<span class="fstat-no" title="function not covered" >f</span>unction _ref21(_id37){<span class="cstat-no" title="statement not covered" ></span>if(!(_id37==null||Node(_id37))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "checkNullable" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id37));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id37;}<span class="cstat-no" title="statement not covered" ></span>var check=checkAnnotation(input,type,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!check){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref21(t.logicalExpression("||",checks.void({input:input}),check));}<span class="fstat-no" title="function not covered" ></span>function checkTypeof(_ref111){<span class="cstat-no" title="statement not covered" ></span>var input=_ref111.input;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref111.annotation;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref111.scope;<span class="fstat-no" title="function not covered" >f</span>unction _ref22(_id38){<span class="cstat-no" title="statement not covered" ></span>if(!(_id38==null||Node(_id38))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "checkTypeof" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id38));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id38;}<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >var id=annotation.id;<span class="cstat-no" title="statement not covered" >v</span>ar path=Object.assign({},input,{type:id.type,node:id,scope:scope});<span class="cstat-no" title="statement not covered" >r</span>eturn _ref22(checkAnnotation(input,getAnnotation(path),scope));d</span>efault:<span class="cstat-no" title="statement not covered" >return _ref22(checkAnnotation(input,annotation,scope));}</span>}<span class="fstat-no" title="function not covered" ></span>function checkStringLiteral(_ref112){<span class="cstat-no" title="statement not covered" ></span>var input=_ref112.input;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref112.annotation;<span class="fstat-no" title="function not covered" >f</span>unction _ref23(_id39){<span class="cstat-no" title="statement not covered" ></span>if(!(_id39==null||Node(_id39))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "checkStringLiteral" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id39));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id39;}<span class="cstat-no" title="statement not covered" ></span>return _ref23(checkEquals({input:input,expected:t.stringLiteral(annotation.value)}));}<span class="fstat-no" title="function not covered" ></span>function checkNumericLiteral(_ref113){<span class="cstat-no" title="statement not covered" ></span>var input=_ref113.input;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref113.annotation;<span class="fstat-no" title="function not covered" >f</span>unction _ref24(_id40){<span class="cstat-no" title="statement not covered" ></span>if(!(_id40==null||Node(_id40))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "checkNumericLiteral" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id40));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id40;}<span class="cstat-no" title="statement not covered" ></span>return _ref24(checkEquals({input:input,expected:t.numericLiteral(annotation.value)}));}<span class="fstat-no" title="function not covered" ></span>function checkBooleanLiteral(_ref114){<span class="cstat-no" title="statement not covered" ></span>var input=_ref114.input;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref114.annotation;<span class="fstat-no" title="function not covered" >f</span>unction _ref25(_id41){<span class="cstat-no" title="statement not covered" ></span>if(!(_id41==null||Node(_id41))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "checkBooleanLiteral" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id41));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id41;}<span class="cstat-no" title="statement not covered" ></span>return _ref25(checkEquals({input:input,expected:t.booleanLiteral(annotation.value)}));}<span class="fstat-no" title="function not covered" ></span>function checkUnion(_ref115){<span class="cstat-no" title="statement not covered" ></span>var input=_ref115.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref115.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref115.scope;<span class="fstat-no" title="function not covered" >f</span>unction _ref26(_id42){<span class="cstat-no" title="statement not covered" ></span>if(!(_id42==null||Node(_id42))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "checkUnion" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id42));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id42;}<span class="cstat-no" title="statement not covered" ></span>var checks=types.map(<span class="fstat-no" title="function not covered" >function(type){<span class="cstat-no" title="statement not covered" ></span>return checkAnnotation(input,type,scope);}</span>).filter(identity);<span class="cstat-no" title="statement not covered" >r</span>eturn _ref26(checks.reduce(<span class="fstat-no" title="function not covered" >function(last,check,index){<span class="cstat-no" title="statement not covered" ></span>if(last==null){<span class="cstat-no" title="statement not covered" >return check;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logicalExpression("||",last,check);}</span>,null));}<span class="fstat-no" title="function not covered" ></span>function checkIntersection(_ref116){<span class="cstat-no" title="statement not covered" ></span>var input=_ref116.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref116.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref116.scope;<span class="fstat-no" title="function not covered" >f</span>unction _ref27(_id43){<span class="cstat-no" title="statement not covered" ></span>if(!(_id43==null||Node(_id43))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "checkIntersection" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id43));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id43;}<span class="cstat-no" title="statement not covered" ></span>var checks=types.map(<span class="fstat-no" title="function not covered" >function(type){<span class="cstat-no" title="statement not covered" ></span>return checkAnnotation(input,type,scope);}</span>).filter(identity);<span class="cstat-no" title="statement not covered" >r</span>eturn _ref27(checks.reduce(<span class="fstat-no" title="function not covered" >function(last,check,index){<span class="cstat-no" title="statement not covered" ></span>if(last==null){<span class="cstat-no" title="statement not covered" >return check;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logicalExpression("&amp;&amp;",last,check);}</span>,null));}<span class="fstat-no" title="function not covered" ></span>function checkMap(_ref117){<span class="cstat-no" title="statement not covered" ></span>var input=_ref117.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref117.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref117.scope;<span class="fstat-no" title="function not covered" >f</span>unction _ref28(_id44){<span class="cstat-no" title="statement not covered" ></span>if(!Node(_id44)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "checkMap" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id44));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id44;}<span class="cstat-no" title="statement not covered" ></span>var _types=_slicedToArray(types,2);<span class="cstat-no" title="statement not covered" >v</span>ar keyType=_types[0];<span class="cstat-no" title="statement not covered" >v</span>ar valueType=_types[1];<span class="cstat-no" title="statement not covered" >v</span>ar key=t.identifier('key');<span class="cstat-no" title="statement not covered" >v</span>ar value=t.identifier('value');<span class="cstat-no" title="statement not covered" >v</span>ar keyCheck=keyType?checkAnnotation(key,keyType,scope):null;<span class="cstat-no" title="statement not covered" >v</span>ar valueCheck=valueType?checkAnnotation(value,valueType,scope):null;<span class="cstat-no" title="statement not covered" >i</span>f(!keyCheck){<span class="cstat-no" title="statement not covered" >if(!valueCheck){<span class="cstat-no" title="statement not covered" >return _ref28(checkIsMap({input:input}));}</span>else {<span class="cstat-no" title="statement not covered" >return _ref28(checkMapValues({input:input,value:value,valueCheck:valueCheck}));}</span>}</span>else {<span class="cstat-no" title="statement not covered" >if(!valueCheck){<span class="cstat-no" title="statement not covered" >return _ref28(checkMapKeys({input:input,key:key,keyCheck:keyCheck}));}</span>else {<span class="cstat-no" title="statement not covered" >return _ref28(checkMapEntries({input:input,key:key,value:value,keyCheck:keyCheck,valueCheck:valueCheck}));}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function checkSet(_ref118){<span class="cstat-no" title="statement not covered" ></span>var input=_ref118.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref118.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref118.scope;<span class="fstat-no" title="function not covered" >f</span>unction _ref29(_id45){<span class="cstat-no" title="statement not covered" ></span>if(!Node(_id45)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "checkSet" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id45));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id45;}<span class="cstat-no" title="statement not covered" ></span>var _types2=_slicedToArray(types,1);<span class="cstat-no" title="statement not covered" >v</span>ar valueType=_types2[0];<span class="cstat-no" title="statement not covered" >v</span>ar value=t.identifier('value');<span class="cstat-no" title="statement not covered" >v</span>ar valueCheck=valueType?checkAnnotation(value,valueType,scope):null;<span class="cstat-no" title="statement not covered" >i</span>f(!valueCheck){<span class="cstat-no" title="statement not covered" >return _ref29(checkIsSet({input:input}));}</span>else {<span class="cstat-no" title="statement not covered" >return _ref29(checkSetEntries({input:input,value:value,valueCheck:valueCheck}));}</span>}<span class="fstat-no" title="function not covered" ></span>function checkGenerator(_ref119){<span class="cstat-no" title="statement not covered" ></span>var input=_ref119.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref119.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref119.scope;<span class="fstat-no" title="function not covered" >f</span>unction _ref30(_id46){<span class="cstat-no" title="statement not covered" ></span>if(!Node(_id46)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "checkGenerator" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id46));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id46;}<span class="cstat-no" title="statement not covered" ></span>return _ref30(checkIsGenerator({input:input}));}<span class="fstat-no" title="function not covered" ></span>function checkIterable(_ref120){<span class="cstat-no" title="statement not covered" ></span>var input=_ref120.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref120.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref120.scope;<span class="fstat-no" title="function not covered" >f</span>unction _ref31(_id47){<span class="cstat-no" title="statement not covered" ></span>if(!Node(_id47)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "checkIterable" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id47));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id47;}<span class="cstat-no" title="statement not covered" ></span>return _ref31(checkIsIterable({input:input}));}<span class="fstat-no" title="function not covered" ></span>function checkClass(_ref121){<span class="cstat-no" title="statement not covered" ></span>var input=_ref121.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref121.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref121.scope;<span class="fstat-no" title="function not covered" >f</span>unction _ref32(_id48){<span class="cstat-no" title="statement not covered" ></span>if(!Node(_id48)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "checkClass" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id48));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id48;}<span class="cstat-no" title="statement not covered" ></span>return _ref32(checkIsClass({input:input}));}<span class="fstat-no" title="function not covered" ></span>function checkArray(_ref122){<span class="cstat-no" title="statement not covered" ></span>var input=_ref122.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref122.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref122.scope;<span class="fstat-no" title="function not covered" >f</span>unction _ref33(_id49){<span class="cstat-no" title="statement not covered" ></span>if(!Node(_id49)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "checkArray" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id49));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id49;}<span class="cstat-no" title="statement not covered" ></span>if(!types||types.length===0){<span class="cstat-no" title="statement not covered" >return _ref33(checkIsArray({input:input}));}</span>else <span class="cstat-no" title="statement not covered" >if(types.length===1){<span class="cstat-no" title="statement not covered" >var item=t.identifier('item');<span class="cstat-no" title="statement not covered" >v</span>ar _type5=types[0];<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(item,_type5,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!check){<span class="cstat-no" title="statement not covered" >return _ref33(checkIsArray({input:input}));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref33(t.logicalExpression('&amp;&amp;',checkIsArray({input:input}),t.callExpression(t.memberExpression(input,t.identifier('every')),[t.functionExpression(null,[item],t.blockStatement([t.returnStatement(check)]))])));}</span>else { // This is a tuple</span></span>
<span class="cstat-no" title="statement not covered" >var _checks=types.map(<span class="fstat-no" title="function not covered" >function(type,index){<span class="cstat-no" title="statement not covered" ></span>return checkAnnotation(t.memberExpression(input,t.numericLiteral(index),true),type,scope);}</span>).filter(identity);<span class="cstat-no" title="statement not covered" >v</span>ar checkLength=t.binaryExpression('&gt;=',t.memberExpression(input,t.identifier('length')),t.numericLiteral(types.length));<span class="cstat-no" title="statement not covered" >r</span>eturn _ref33(_checks.reduce(<span class="fstat-no" title="function not covered" >function(last,check,index){<span class="cstat-no" title="statement not covered" ></span>return t.logicalExpression("&amp;&amp;",last,check);}</span>,t.logicalExpression('&amp;&amp;',checkIsArray({input:input}),checkLength)));}</span>}<span class="fstat-no" title="function not covered" >function checkTuple(_ref123){<span class="cstat-no" title="statement not covered" ></span>var input=_ref123.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref123.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref123.scope;<span class="fstat-no" title="function not covered" >f</span>unction _ref34(_id50){<span class="cstat-no" title="statement not covered" ></span>if(!Node(_id50)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "checkTuple" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id50));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id50;}<span class="cstat-no" title="statement not covered" ></span>if(types.length===0){<span class="cstat-no" title="statement not covered" >return _ref34(checkIsArray({input:input}));}</span> </span>// This is a tuple
<span class="cstat-no" title="statement not covered" >var checks=types.map(<span class="fstat-no" title="function not covered" >function(type,index){<span class="cstat-no" title="statement not covered" ></span>return checkAnnotation(t.memberExpression(input,t.numericLiteral(index),true),type,scope);}</span>).filter(identity);<span class="cstat-no" title="statement not covered" >v</span>ar checkLength=t.binaryExpression('&gt;=',t.memberExpression(input,t.identifier('length')),t.numericLiteral(types.length));<span class="cstat-no" title="statement not covered" >r</span>eturn _ref34(checks.reduce(<span class="fstat-no" title="function not covered" >function(last,check,index){<span class="cstat-no" title="statement not covered" ></span>return t.logicalExpression("&amp;&amp;",last,check);}</span>,t.logicalExpression('&amp;&amp;',checkIsArray({input:input}),checkLength)));}<span class="fstat-no" title="function not covered" ></span>function checkObject(_ref124){<span class="cstat-no" title="statement not covered" ></span>var input=_ref124.input;<span class="cstat-no" title="statement not covered" >v</span>ar properties=_ref124.properties;<span class="cstat-no" title="statement not covered" >v</span>ar indexers=_ref124.indexers;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref124.scope;<span class="fstat-no" title="function not covered" >f</span>unction _ref35(_id51){<span class="cstat-no" title="statement not covered" ></span>if(!Node(_id51)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "checkObject" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id51));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id51;}<span class="cstat-no" title="statement not covered" ></span>if(input.type==='ObjectPattern'){<span class="cstat-no" title="statement not covered" >return _ref35(checkObjectPattern({input:input,properties:properties,scope:scope}));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar propNames=[];<span class="cstat-no" title="statement not covered" >v</span>ar check=properties.length===0?checkIsObject({input:input}):properties.reduce(<span class="fstat-no" title="function not covered" >function(expr,prop,index){<span class="cstat-no" title="statement not covered" ></span>var target=prop.key.type==='Identifier'?t.memberExpression(input,prop.key):t.memberExpression(input,prop.key,true);<span class="cstat-no" title="statement not covered" >p</span>ropNames.push(prop.key.type==='Identifier'?t.stringLiteral(prop.key.name):prop.key);<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(target,prop.value,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >if(prop.optional){<span class="cstat-no" title="statement not covered" >check=t.logicalExpression('||',checks.undefined({input:target}),check);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logicalExpression("&amp;&amp;",expr,check);}</span>else {<span class="cstat-no" title="statement not covered" >return expr;}</span>}</span>,checkNotNull({input:input}));<span class="cstat-no" title="statement not covered" >i</span>f(indexers.length){<span class="cstat-no" title="statement not covered" >return _ref35(indexers.reduceRight(<span class="fstat-no" title="function not covered" >function(expr,indexer){<span class="cstat-no" title="statement not covered" ></span>if(indexer.value.type==='AnyTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return expr;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar value=scope.generateUidIdentifier(indexer.id.name);<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(value,indexer.value,scope);<span class="cstat-no" title="statement not covered" >v</span>ar fixedKeys=t.arrayExpression(propNames);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >if(propNames.length){<span class="cstat-no" title="statement not covered" >return t.logicalExpression('&amp;&amp;',expr,checkObjectIndexers({input:input,value:value,check:check,fixedKeys:fixedKeys}));}</span>else {<span class="cstat-no" title="statement not covered" >return t.logicalExpression('&amp;&amp;',expr,checkObjectIndexersNoFixed({input:input,value:value,check:check,fixedKeys:fixedKeys}));}</span>}</span>else {<span class="cstat-no" title="statement not covered" >return expr;}</span>}</span>,check));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref35(check);}<span class="fstat-no" title="function not covered" ></span>function checkObjectPattern(_ref125){<span class="cstat-no" title="statement not covered" ></span>var input=_ref125.input;<span class="cstat-no" title="statement not covered" >v</span>ar properties=_ref125.properties;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref125.scope;<span class="fstat-no" title="function not covered" >f</span>unction _ref36(_id52){<span class="cstat-no" title="statement not covered" ></span>if(!(_id52==null||Node(_id52))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "checkObjectPattern" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id52));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id52;}<span class="cstat-no" title="statement not covered" ></span>var propNames=properties.reduce(<span class="fstat-no" title="function not covered" >function(names,prop){<span class="cstat-no" title="statement not covered" ></span>names[prop.key.name]=prop;<span class="cstat-no" title="statement not covered" >r</span>eturn names;}</span>,{});<span class="cstat-no" title="statement not covered" >v</span>ar propChecks={};<span class="cstat-no" title="statement not covered" >_</span>input$properties=input.properties;<span class="cstat-no" title="statement not covered" >i</span>f(!(_input$properties&amp;&amp;(typeof _input$properties[Symbol.iterator]==='function'||Array.isArray(_input$properties)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _input$properties to be iterable, got '+_inspect(_input$properties));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion9=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError9=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError9=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator9=_input$properties[Symbol.iterator](),_step9;!(_iteratorNormalCompletion9=(_step9=_iterator9.next()).done);_iteratorNormalCompletion9=true){<span class="cstat-no" title="statement not covered" >var _input$properties;<span class="cstat-no" title="statement not covered" >v</span>ar item=_step9.value;<span class="cstat-no" title="statement not covered" >v</span>ar key=item.key;<span class="cstat-no" title="statement not covered" >v</span>ar _id121=item.value;<span class="cstat-no" title="statement not covered" >v</span>ar prop=propNames[key.name];<span class="cstat-no" title="statement not covered" >i</span>f(!prop){<span class="cstat-no" title="statement not covered" >continue;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar check=checkAnnotation(_id121,prop.value,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >propChecks[key.name]=check;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError9=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError9=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion9&amp;&amp;_iterator9.return){<span class="cstat-no" title="statement not covered" >_iterator9.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError9){<span class="cstat-no" title="statement not covered" >throw _iteratorError9;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref36(Object.keys(propChecks).reduce(<span class="fstat-no" title="function not covered" >function(last,name){<span class="cstat-no" title="statement not covered" ></span>var check=propChecks[name];<span class="cstat-no" title="statement not covered" >i</span>f(last===null){<span class="cstat-no" title="statement not covered" >return check;}</span>else {<span class="cstat-no" title="statement not covered" >return t.logicalExpression('&amp;&amp;',last,check);}</span>}</span>,null));}<span class="fstat-no" title="function not covered" ></span>function createTypeAliasChecks(path){<span class="fstat-no" title="function not covered" ></span>function _ref37(_id53){<span class="cstat-no" title="statement not covered" ></span>if(!Node(_id53)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "createTypeAliasChecks" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id53));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id53;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.id;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.right;<span class="cstat-no" title="statement not covered" >v</span>ar input=t.identifier('input');<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(input,annotation,scope)||t.booleanLiteral(true);<span class="cstat-no" title="statement not covered" >v</span>ar declaration=declareTypeChecker({id:id,check:check});<span class="cstat-no" title="statement not covered" >d</span>eclaration.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >d</span>eclaration.savedTypeAnnotation=annotation;<span class="cstat-no" title="statement not covered" >d</span>eclaration.declarations[0].savedTypeAnnotation=annotation;<span class="cstat-no" title="statement not covered" >r</span>eturn _ref37(declaration);}<span class="fstat-no" title="function not covered" ></span>function createInterfaceChecks(path){<span class="fstat-no" title="function not covered" ></span>function _ref38(_id54){<span class="cstat-no" title="statement not covered" ></span>if(!Node(_id54)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "createInterfaceChecks" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id54));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id54;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.id;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.body;<span class="cstat-no" title="statement not covered" >v</span>ar input=t.identifier('input');<span class="cstat-no" title="statement not covered" >v</span>ar check=node.extends.reduce(<span class="fstat-no" title="function not covered" >function(check,extender){<span class="cstat-no" title="statement not covered" ></span>return t.logicalExpression('&amp;&amp;',check,checkAnnotation(input,t.genericTypeAnnotation(extender.id),path.scope));<span class="cstat-no" title="statement not covered" >r</span>eturn check;}</span>,checkAnnotation(input,annotation,scope)||t.booleanLiteral(true));<span class="cstat-no" title="statement not covered" >v</span>ar declaration=declareTypeChecker({id:id,check:check});<span class="cstat-no" title="statement not covered" >d</span>eclaration.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >r</span>eturn _ref38(declaration);}<span class="fstat-no" title="function not covered" ></span>function checkAnnotation(input,annotation,scope){<span class="fstat-no" title="function not covered" ></span>function _ref39(_id55){<span class="cstat-no" title="statement not covered" ></span>if(!(_id55==null||Node(_id55))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "checkAnnotation" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id55));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id55;}<span class="cstat-no" title="statement not covered" ></span>if(!Node(input)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "input" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(input));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!Scope(scope)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "scope" violates contract.\n\nExpected:\nScope\n\nGot:\n'+_inspect(scope));}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return _ref39(checkAnnotation(input,annotation.typeAnnotation,scope));c</span>ase 'TypeofTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref39(checks.typeof({input:input,annotation:annotation.argument,scope:scope}));c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Array'){<span class="cstat-no" title="statement not covered" >return _ref39(checks.array({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope}));}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Generator'&amp;&amp;!scope.hasBinding('Generator')){<span class="cstat-no" title="statement not covered" >return _ref39(checks.generator({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope}));}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Iterable'&amp;&amp;!scope.hasBinding('Iterable')){<span class="cstat-no" title="statement not covered" >return _ref39(checks.iterable({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope}));}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Map'&amp;&amp;!scope.getBinding('Map')){<span class="cstat-no" title="statement not covered" >return _ref39(checks.map({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope}));}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Set'&amp;&amp;!scope.getBinding('Set')){<span class="cstat-no" title="statement not covered" >return _ref39(checks.set({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope}));}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Function'){<span class="cstat-no" title="statement not covered" >return _ref39(checks.function({input:input}));}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Class'&amp;&amp;!scope.hasBinding('Class')){<span class="cstat-no" title="statement not covered" >return _ref39(checks.class({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope}));}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='int8'&amp;&amp;!scope.hasBinding('int8')){<span class="cstat-no" title="statement not covered" >return _ref39(checks.int8({input:input}));}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='uint8'&amp;&amp;!scope.hasBinding('uint8')){<span class="cstat-no" title="statement not covered" >return _ref39(checks.uint8({input:input}));}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='int16'&amp;&amp;!scope.hasBinding('int16')){<span class="cstat-no" title="statement not covered" >return _ref39(checks.int16({input:input}));}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='uint16'&amp;&amp;!scope.hasBinding('uint16')){<span class="cstat-no" title="statement not covered" >return _ref39(checks.uint16({input:input}));}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='int32'&amp;&amp;!scope.hasBinding('int32')){<span class="cstat-no" title="statement not covered" >return _ref39(checks.int32({input:input}));}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='uint32'&amp;&amp;!scope.hasBinding('uint32')){<span class="cstat-no" title="statement not covered" >return _ref39(checks.uint32({input:input}));}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='float32'&amp;&amp;!scope.hasBinding('float32')){<span class="cstat-no" title="statement not covered" >return _ref39(checks.float32({input:input}));}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='float64'&amp;&amp;!scope.hasBinding('float64')){<span class="cstat-no" title="statement not covered" >return _ref39(checks.float64({input:input}));}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='double'&amp;&amp;!scope.hasBinding('double')){<span class="cstat-no" title="statement not covered" >return _ref39(checks.double({input:input}));}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Symbol'&amp;&amp;!scope.getBinding('Symbol')){<span class="cstat-no" title="statement not covered" >return _ref39(checks.symbol({input:input}));}</span>else <span class="cstat-no" title="statement not covered" >if(isTypeChecker(annotation.id,scope)){<span class="cstat-no" title="statement not covered" >return _ref39(checks.type({input:input,type:annotation.id}));}</span>else <span class="cstat-no" title="statement not covered" >if(isPolymorphicType(annotation.id,scope)){<span class="cstat-no" title="statement not covered" >return;}</span>else {<span class="cstat-no" title="statement not covered" >return _ref39(checks.instanceof({input:input,type:createTypeExpression(annotation.id)}));}</span>c</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>ase 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref39(checks.tuple({input:input,types:annotation.types,scope:scope}));c</span>ase 'NumberTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref39(checks.number({input:input}));c</span>ase 'NumericLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref39(checks.numericLiteral({input:input,annotation:annotation}));c</span>ase 'BooleanTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref39(checks.boolean({input:input}));c</span>ase 'BooleanLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref39(checks.booleanLiteral({input:input,annotation:annotation}));c</span>ase 'StringTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref39(checks.string({input:input}));c</span>ase 'StringLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref39(checks.stringLiteral({input:input,annotation:annotation}));c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref39(checks.union({input:input,types:annotation.types,scope:scope}));c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref39(checks.intersection({input:input,types:annotation.types,scope:scope}));c</span>ase 'ObjectTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref39(checks.object({input:input,properties:annotation.properties||[],indexers:annotation.indexers,scope:scope}));c</span>ase 'ArrayTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref39(checks.array({input:input,types:[annotation.elementType||t.anyTypeAnnotation()],scope:scope}));c</span>ase 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref39(checks.function({input:input,params:annotation.params,returnType:annotation.returnType}));c</span>ase 'MixedTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref39(checks.mixed({input:input}));c</span>ase 'AnyTypeAnnotation':case 'ExistentialTypeParam':<span class="cstat-no" title="statement not covered" >return _ref39(checks.any({input:input}));c</span>ase 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref39(checks.nullable({input:input,type:annotation.typeAnnotation,scope:scope}));c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref39(checks.void({input:input}));}</span>}<span class="fstat-no" title="function not covered" ></span>function staticCheckAnnotation(path,annotation){<span class="fstat-no" title="function not covered" ></span>function _ref40(_id56){<span class="cstat-no" title="statement not covered" ></span>if(!(_id56==null||typeof _id56==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "staticCheckAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id56));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id56;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar other=getAnnotation(path);<span class="cstat-no" title="statement not covered" >s</span>witch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return _ref40(staticCheckAnnotation(path,annotation.typeAnnotation));c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(isTypeChecker(annotation.id,path.scope)){<span class="cstat-no" title="statement not covered" >return _ref40(staticChecks.type({path:path,type:annotation.id}));}</span>else <span class="cstat-no" title="statement not covered" >if(isPolymorphicType(annotation.id,path.scope)){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Symbol'){<span class="cstat-no" title="statement not covered" >return _ref40(staticChecks.symbol(path));}</span>else {<span class="cstat-no" title="statement not covered" >return _ref40(staticChecks.instanceof({path:path,annotation:annotation}));}</span>}<span class="cstat-no" title="statement not covered" ></span></span></span>r</span>eturn _ref40(compareAnnotations(annotation,other));}</span> /**
   * Get the type annotation for a given node.
   */<span class="fstat-no" title="function not covered" >function getAnnotation(path){<span class="fstat-no" title="function not covered" ></span>function _ref41(_id57){<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(_id57)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getAnnotation" return value violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(_id57));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id57;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar annotation=void 0;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >annotation=getAnnotationShallow(path);}</span>catch(e){<span class="cstat-no" title="statement not covered" >if(e instanceof SyntaxError){<span class="cstat-no" title="statement not covered" >throw e;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(process.env.TYPECHECK_DEBUG){<span class="cstat-no" title="statement not covered" >console.error(e.stack);}</span>}<span class="cstat-no" title="statement not covered" ></span>w</span>hile(annotation&amp;&amp;annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref41(annotation||t.anyTypeAnnotation());}<span class="fstat-no" title="function not covered" ></span>function getAnnotationShallow(path){<span class="fstat-no" title="function not covered" ></span>function _ref42(_id58){<span class="cstat-no" title="statement not covered" ></span>if(!(_id58==null||TypeAnnotation(_id58))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getAnnotationShallow" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id58));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id58;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!path||!path.node){<span class="cstat-no" title="statement not covered" >return _ref42(t.voidTypeAnnotation());}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='TypeAlias'){<span class="cstat-no" title="statement not covered" >return _ref42(node.right);}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ClassProperty'&amp;&amp;node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return _ref42(getClassPropertyAnnotation(path));}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ClassMethod'&amp;&amp;node.returnType){<span class="cstat-no" title="statement not covered" >return _ref42(getClassMethodAnnotation(path));}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ObjectProperty'&amp;&amp;node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return _ref42(getObjectPropertyAnnotation(path));}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='SpreadProperty'&amp;&amp;node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return _ref42(getSpreadPropertyAnnotation(path));}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ObjectMethod'&amp;&amp;node.returnType){<span class="cstat-no" title="statement not covered" >return _ref42(getObjectMethodAnnotation(path));}</span>else <span class="cstat-no" title="statement not covered" >if(!node.typeAnnotation&amp;&amp;!node.savedTypeAnnotation&amp;&amp;!node.returnType){<span class="cstat-no" title="statement not covered" >switch(path.type){case 'Identifier':<span class="cstat-no" title="statement not covered" >var binding=scope.getBinding(node.name);<span class="cstat-no" title="statement not covered" >i</span>f(!binding||!binding.identifier){<span class="cstat-no" title="statement not covered" >return _ref42(path.getTypeAnnotation());}<span class="cstat-no" title="statement not covered" ></span>v</span>ar id=binding.identifier;<span class="cstat-no" title="statement not covered" >i</span>f(binding.path.type==='ObjectPattern'){<span class="cstat-no" title="statement not covered" >return _ref42(getObjectPatternAnnotation(binding.path,node.name));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(id.savedTypeAnnotation){<span class="cstat-no" title="statement not covered" >return _ref42(id.savedTypeAnnotation);}</span>else <span class="cstat-no" title="statement not covered" >if(id.returnType){<span class="cstat-no" title="statement not covered" >return _ref42(id.returnType);}</span>else <span class="cstat-no" title="statement not covered" >if(id.typeAnnotation){<span class="cstat-no" title="statement not covered" >return _ref42(id.typeAnnotation);}</span>else <span class="cstat-no" title="statement not covered" >if(isPolymorphicType(id,scope)){<span class="cstat-no" title="statement not covered" >return _ref42(t.anyTypeAnnotation());}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span>eturn _ref42(binding.constant?binding.path.getTypeAnnotation():path.getTypeAnnotation());c</span>ase 'StringLiteral':case 'NumericLiteral':case 'BooleanLiteral':<span class="cstat-no" title="statement not covered" >return _ref42(createLiteralTypeAnnotation(path));c</span>ase 'CallExpression':<span class="cstat-no" title="statement not covered" >var callee=path.get('callee');<span class="cstat-no" title="statement not covered" >i</span>f(callee.type==='Identifier'){<span class="cstat-no" title="statement not covered" >if(callee.name==='Symbol'){<span class="cstat-no" title="statement not covered" >return _ref42(t.genericTypeAnnotation('Symbol'));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar fn=getFunctionForIdentifier(callee);<span class="cstat-no" title="statement not covered" >i</span>f(fn){<span class="cstat-no" title="statement not covered" >return getAnnotation(fn);}</span>}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase 'ThisExpression':<span class="cstat-no" title="statement not covered" >return _ref42(getThisExpressionAnnotation(path));c</span>ase 'AssignmentExpression':<span class="cstat-no" title="statement not covered" >return _ref42(getAssignmentExpressionAnnotation(path));c</span>ase 'MemberExpression':<span class="cstat-no" title="statement not covered" >return getMemberExpressionAnnotation(path);c</span>ase 'ArrayExpression':<span class="cstat-no" title="statement not covered" >return getArrayExpressionAnnotation(path);c</span>ase 'ObjectExpression':<span class="cstat-no" title="statement not covered" >return getObjectExpressionAnnotation(path);c</span>ase 'BinaryExpression':<span class="cstat-no" title="statement not covered" >return getBinaryExpressionAnnotation(path);c</span>ase 'LogicalExpression':<span class="cstat-no" title="statement not covered" >return getLogicalExpressionAnnotation(path);c</span>ase 'ConditionalExpression':<span class="cstat-no" title="statement not covered" >return getConditionalExpressionAnnotation(path);c</span>ase 'ObjectMethod':<span class="cstat-no" title="statement not covered" >return _ref42(getObjectMethodAnnotation(path));c</span>ase 'SpreadProperty':<span class="cstat-no" title="statement not covered" >return _ref42(getSpreadPropertyAnnotation(path));c</span>ase 'ObjectProperty':<span class="cstat-no" title="statement not covered" >return _ref42(getObjectPropertyAnnotation(path));c</span>ase 'ClassDeclaration':<span class="cstat-no" title="statement not covered" >return _ref42(getClassDeclarationAnnotation(path));c</span>ase 'ClassMethod':<span class="cstat-no" title="statement not covered" >return _ref42(getClassMethodAnnotation(path));c</span>ase 'ClassProperty':<span class="cstat-no" title="statement not covered" >return _ref42(getClassPropertyAnnotation(path));d</span>efault:<span class="cstat-no" title="statement not covered" >return _ref42(path.getTypeAnnotation());}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span></span></span></span>eturn _ref42(node.savedTypeAnnotation||node.returnType||node.typeAnnotation||path.getTypeAnnotation());}<span class="fstat-no" title="function not covered" ></span>function createLiteralTypeAnnotation(path){<span class="fstat-no" title="function not covered" ></span>function _ref43(_id59){<span class="cstat-no" title="statement not covered" ></span>if(!(_id59==null||TypeAnnotation(_id59))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "createLiteralTypeAnnotation" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id59));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id59;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar annotation=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(path.isStringLiteral()){<span class="cstat-no" title="statement not covered" >annotation=t.stringLiteralTypeAnnotation();}</span>else <span class="cstat-no" title="statement not covered" >if(path.isNumericLiteral()){<span class="cstat-no" title="statement not covered" >annotation=t.numericLiteralTypeAnnotation();}</span>else <span class="cstat-no" title="statement not covered" >if(path.isBooleanLiteral()){<span class="cstat-no" title="statement not covered" >annotation=t.booleanLiteralTypeAnnotation();}</span>else {<span class="cstat-no" title="statement not covered" >return _ref43(path.getTypeAnnotation());}<span class="cstat-no" title="statement not covered" ></span>a</span></span></span>nnotation.value=path.node.value;<span class="cstat-no" title="statement not covered" >r</span>eturn _ref43(annotation);}<span class="fstat-no" title="function not covered" ></span>function getObjectPatternAnnotation(path,name){<span class="fstat-no" title="function not covered" ></span>function _ref44(_id60){<span class="cstat-no" title="statement not covered" ></span>if(!(_id60==null||TypeAnnotation(_id60))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getObjectPatternAnnotation" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id60));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id60;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!(typeof name==='string')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "name" violates contract.\n\nExpected:\nstring\n\nGot:\n'+_inspect(name));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar annotation=keyByName(getAnnotation(path),name);<span class="cstat-no" title="statement not covered" >v</span>ar found=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(!path.node.properties){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>_</span>path$get4=path.get('properties');<span class="cstat-no" title="statement not covered" >i</span>f(!(_path$get4&amp;&amp;(typeof _path$get4[Symbol.iterator]==='function'||Array.isArray(_path$get4)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _path$get4 to be iterable, got '+_inspect(_path$get4));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion10=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError10=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError10=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator10=_path$get4[Symbol.iterator](),_step10;!(_iteratorNormalCompletion10=(_step10=_iterator10.next()).done);_iteratorNormalCompletion10=true){<span class="cstat-no" title="statement not covered" >var _path$get4;<span class="cstat-no" title="statement not covered" >v</span>ar prop=_step10.value;<span class="cstat-no" title="statement not covered" >i</span>f(prop.node.value&amp;&amp;prop.node.value.name===name){<span class="cstat-no" title="statement not covered" >found=prop.get('key');<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>else <span class="cstat-no" title="statement not covered" >if(prop.node.key.type==='Identifier'&amp;&amp;prop.node.key.name===name){<span class="cstat-no" title="statement not covered" >found=prop.get('key');<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError10=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError10=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion10&amp;&amp;_iterator10.return){<span class="cstat-no" title="statement not covered" >_iterator10.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError10){<span class="cstat-no" title="statement not covered" >throw _iteratorError10;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!annotation||!found){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(found.type==='Identifier'){<span class="cstat-no" title="statement not covered" >annotation.value.authoritative=false;<span class="cstat-no" title="statement not covered" >r</span>eturn _ref44(annotation.value);}</span>}<span class="fstat-no" title="function not covered" ></span>function keyByName(node,name){<span class="fstat-no" title="function not covered" ></span>function _ref45(_id61){<span class="cstat-no" title="statement not covered" ></span>if(!(_id61==null||Node(_id61))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "keyByName" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id61));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id61;}<span class="cstat-no" title="statement not covered" ></span>if(!Node(node)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!(typeof name==='string')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "name" violates contract.\n\nExpected:\nstring\n\nGot:\n'+_inspect(name));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!node.properties){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>_</span>node$properties=node.properties;<span class="cstat-no" title="statement not covered" >i</span>f(!(_node$properties&amp;&amp;(typeof _node$properties[Symbol.iterator]==='function'||Array.isArray(_node$properties)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _node$properties to be iterable, got '+_inspect(_node$properties));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion11=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError11=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError11=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator11=_node$properties[Symbol.iterator](),_step11;!(_iteratorNormalCompletion11=(_step11=_iterator11.next()).done);_iteratorNormalCompletion11=true){<span class="cstat-no" title="statement not covered" >var _node$properties;<span class="cstat-no" title="statement not covered" >v</span>ar prop=_step11.value;<span class="cstat-no" title="statement not covered" >i</span>f(prop.key&amp;&amp;prop.key.name===name){<span class="cstat-no" title="statement not covered" >return _ref45(prop);}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError11=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError11=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion11&amp;&amp;_iterator11.return){<span class="cstat-no" title="statement not covered" >_iterator11.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError11){<span class="cstat-no" title="statement not covered" >throw _iteratorError11;}</span>}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function valueByName(node,name){<span class="fstat-no" title="function not covered" ></span>function _ref46(_id62){<span class="cstat-no" title="statement not covered" ></span>if(!(_id62==null||Node(_id62))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "valueByName" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id62));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id62;}<span class="cstat-no" title="statement not covered" ></span>if(!Node(node)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!(typeof name==='string')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "name" violates contract.\n\nExpected:\nstring\n\nGot:\n'+_inspect(name));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!node.properties){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>_</span>node$properties2=node.properties;<span class="cstat-no" title="statement not covered" >i</span>f(!(_node$properties2&amp;&amp;(typeof _node$properties2[Symbol.iterator]==='function'||Array.isArray(_node$properties2)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _node$properties2 to be iterable, got '+_inspect(_node$properties2));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion12=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError12=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError12=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator12=_node$properties2[Symbol.iterator](),_step12;!(_iteratorNormalCompletion12=(_step12=_iterator12.next()).done);_iteratorNormalCompletion12=true){<span class="cstat-no" title="statement not covered" >var _node$properties2;<span class="cstat-no" title="statement not covered" >v</span>ar prop=_step12.value;<span class="cstat-no" title="statement not covered" >i</span>f(prop.value&amp;&amp;prop.value.name===name){<span class="cstat-no" title="statement not covered" >return _ref46(prop);}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError12=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError12=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion12&amp;&amp;_iterator12.return){<span class="cstat-no" title="statement not covered" >_iterator12.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError12){<span class="cstat-no" title="statement not covered" >throw _iteratorError12;}</span>}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function getSpreadPropertyAnnotation(path){<span class="fstat-no" title="function not covered" ></span>function _ref47(_id63){<span class="cstat-no" title="statement not covered" ></span>if(!(_id63==null||TypeAnnotation(_id63))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getSpreadPropertyAnnotation" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id63));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id63;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.typeAnnotation||node.savedTypeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(!annotation){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(path.get('argument'));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref47(annotation);}<span class="fstat-no" title="function not covered" ></span>function getObjectPropertyAnnotation(path){<span class="fstat-no" title="function not covered" ></span>function _ref48(_id64){<span class="cstat-no" title="statement not covered" ></span>if(!(_id64==null||TypeAnnotation(_id64))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getObjectPropertyAnnotation" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id64));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id64;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.typeAnnotation||node.savedTypeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(!annotation){<span class="cstat-no" title="statement not covered" >if(node.value){<span class="cstat-no" title="statement not covered" >if(node.value.typeAnnotation||node.value.savedTypeAnnotation){<span class="cstat-no" title="statement not covered" >annotation=node.value.typeAnnotation||node.value.savedTypeAnnotation;}</span>else <span class="cstat-no" title="statement not covered" >if(node.value.type==='BooleanLiteral'||node.value.type==='NumericLiteral'||node.value.type==='StringLiteral'){<span class="cstat-no" title="statement not covered" >annotation=t[node.value.type](node.value.value);}</span>else {<span class="cstat-no" title="statement not covered" >annotation=t.anyTypeAnnotation();}</span>}</span></span>else {<span class="cstat-no" title="statement not covered" >annotation=t.anyTypeAnnotation();}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref48(t.objectTypeProperty(node.key,annotation));}<span class="fstat-no" title="function not covered" ></span>function getObjectMethodAnnotation(path){<span class="fstat-no" title="function not covered" ></span>function _ref49(_id65){<span class="cstat-no" title="statement not covered" ></span>if(!(_id65==null||TypeAnnotation(_id65))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getObjectMethodAnnotation" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id65));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id65;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >r</span>eturn _ref49(t.objectTypeProperty(t.identifier(node.key.name),t.functionTypeAnnotation(null,node.params.map(<span class="fstat-no" title="function not covered" >function(param){<span class="cstat-no" title="statement not covered" ></span>return param.savedTypeAnnotation||param.typeAnnotation;}</span>),null,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation())));}<span class="fstat-no" title="function not covered" ></span>function getThisExpressionAnnotation(path){<span class="fstat-no" title="function not covered" ></span>function _ref50(_id66){<span class="cstat-no" title="statement not covered" ></span>if(!(_id66==null||TypeAnnotation(_id66))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getThisExpressionAnnotation" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id66));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id66;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar parent=path.parentPath;<span class="cstat-no" title="statement not covered" >l</span>oop: <span class="cstat-no" title="statement not covered" >while(parent){<span class="cstat-no" title="statement not covered" >switch(parent.type){case 'ClassDeclaration':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent);c</span>ase 'ClassBody':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath);c</span>ase 'ClassMethod':case 'ClassProperty':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath.parentPath);c</span>ase 'ObjectProperty':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath);c</span>ase 'ObjectMethod':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath);c</span>ase 'FunctionExpression':<span class="cstat-no" title="statement not covered" >if(parent.parentPath.type==='ObjectProperty'){<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath.parentPath);}<span class="cstat-no" title="statement not covered" ></span>b</span>reak loop;c</span>ase 'ArrowFunctionExpression':<span class="cstat-no" title="statement not covered" >parent=parent.parentPath;<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(parent.isFunction()){<span class="cstat-no" title="statement not covered" >break;}<span class="cstat-no" title="statement not covered" ></span>p</span>arent=parent.parentPath;}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn _ref50(t.objectTypeAnnotation([]));}<span class="fstat-no" title="function not covered" ></span>function getClassDeclarationAnnotation(path){<span class="fstat-no" title="function not covered" ></span>function _ref51(_id67){<span class="cstat-no" title="statement not covered" ></span>if(!(_id67==null||TypeAnnotation(_id67))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getClassDeclarationAnnotation" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id67));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id67;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar body=path.get('body').get('body').map(getAnnotation).filter(<span class="fstat-no" title="function not covered" >function(annotation){<span class="cstat-no" title="statement not covered" ></span>return annotation&amp;&amp;annotation.type!=='AnyTypeAnnotation';}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn _ref51(t.objectTypeAnnotation(body));}<span class="fstat-no" title="function not covered" ></span>function getAssignmentExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(path.node.operator==='='){<span class="cstat-no" title="statement not covered" >return getAnnotation(path.get('right'));}</span>}<span class="fstat-no" title="function not covered" ></span>function getClassPropertyAnnotation(path){<span class="fstat-no" title="function not covered" ></span>function _ref53(_id69){<span class="cstat-no" title="statement not covered" ></span>if(!(_id69==null||TypeAnnotation(_id69))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getClassPropertyAnnotation" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id69));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id69;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.computed){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar annotation=node.typeAnnotation||(node.value?node.value.savedTypeAnnotation||node.value.typeAnnotation:t.anyTypeAnnotation());<span class="cstat-no" title="statement not covered" >r</span>eturn _ref53(t.objectTypeProperty(node.key,annotation||t.anyTypeAnnotation()));}<span class="fstat-no" title="function not covered" ></span>function getClassMethodAnnotation(path){<span class="fstat-no" title="function not covered" ></span>function _ref54(_id70){<span class="cstat-no" title="statement not covered" ></span>if(!(_id70==null||TypeAnnotation(_id70))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getClassMethodAnnotation" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id70));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id70;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.computed){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.kind==='get'){<span class="cstat-no" title="statement not covered" >return _ref54(t.objectTypeProperty(node.key,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation()));}</span>else <span class="cstat-no" title="statement not covered" >if(node.kind==='set'){<span class="cstat-no" title="statement not covered" >return _ref54(t.objectTypeProperty(node.key,node.params.map(<span class="fstat-no" title="function not covered" >function(param){<span class="cstat-no" title="statement not covered" ></span>return param.savedTypeAnnotation||param.typeAnnotation;}</span>).shift()||t.anyTypeAnnotation()));}</span>else {<span class="cstat-no" title="statement not covered" >return _ref54(t.objectTypeProperty(node.key,t.functionTypeAnnotation(null,node.params.map(<span class="fstat-no" title="function not covered" >function(param){<span class="cstat-no" title="statement not covered" ></span>return param.savedTypeAnnotation||param.typeAnnotation||t.anyTypeAnnotation();}</span>),null,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation())));}</span>}<span class="fstat-no" title="function not covered" ></span></span>function getBinaryExpressionAnnotation(path){<span class="fstat-no" title="function not covered" ></span>function _ref55(_id71){<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(_id71)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getBinaryExpressionAnnotation" return value violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(_id71));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id71;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(isBooleanExpression(node)){<span class="cstat-no" title="statement not covered" >return _ref55(t.booleanTypeAnnotation());}</span>else {<span class="cstat-no" title="statement not covered" >return _ref55(t.anyTypeAnnotation());}</span>}<span class="fstat-no" title="function not covered" ></span>function getLogicalExpressionAnnotation(path){<span class="fstat-no" title="function not covered" ></span>function _ref56(_id72){<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(_id72)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getLogicalExpressionAnnotation" return value violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(_id72));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id72;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(isBooleanExpression(node)){<span class="cstat-no" title="statement not covered" >return _ref56(t.booleanTypeAnnotation());}</span>else {<span class="cstat-no" title="statement not covered" >var left=path.get('left');<span class="cstat-no" title="statement not covered" >v</span>ar right=path.get('right');<span class="cstat-no" title="statement not covered" >s</span>witch(node.operator){case '&amp;&amp;':case '||':<span class="cstat-no" title="statement not covered" >var _ref126=[getAnnotation(left),getAnnotation(right)];<span class="cstat-no" title="statement not covered" >l</span>eft=_ref126[0];<span class="cstat-no" title="statement not covered" >r</span>ight=_ref126[1];<span class="cstat-no" title="statement not covered" >i</span>f(t.isUnionTypeAnnotation(left)){<span class="cstat-no" title="statement not covered" >if(t.isUnionTypeAnnotation(right)){<span class="cstat-no" title="statement not covered" >return _ref56(t.unionTypeAnnotation(left.types.concat(right.types)));}</span>else {<span class="cstat-no" title="statement not covered" >return _ref56(t.unionTypeAnnotation(left.types.concat(right)));}</span>}</span>else {<span class="cstat-no" title="statement not covered" >return _ref56(t.unionTypeAnnotation([left,right]));}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref56(t.anyTypeAnnotation());}</span>}<span class="fstat-no" title="function not covered" ></span>function getConditionalExpressionAnnotation(path){<span class="fstat-no" title="function not covered" ></span>function _ref57(_id73){<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(_id73)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getConditionalExpressionAnnotation" return value violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(_id73));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id73;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar consequent=getAnnotation(path.get('consequent'));<span class="cstat-no" title="statement not covered" >v</span>ar alternate=getAnnotation(path.get('alternate'));<span class="cstat-no" title="statement not covered" >i</span>f(t.isUnionTypeAnnotation(consequent)){<span class="cstat-no" title="statement not covered" >if(t.isUnionTypeAnnotation(alternate)){<span class="cstat-no" title="statement not covered" >return _ref57(t.unionTypeAnnotation(consequent.types.concat(alternate.types)));}</span>else {<span class="cstat-no" title="statement not covered" >return _ref57(t.unionTypeAnnotation(consequent.types.concat(alternate)));}</span>}</span>else {<span class="cstat-no" title="statement not covered" >return _ref57(t.unionTypeAnnotation([consequent,alternate]));}</span>}<span class="fstat-no" title="function not covered" ></span>function getArrayExpressionAnnotation(path){<span class="fstat-no" title="function not covered" ></span>function _ref58(_id74){<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(_id74)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getArrayExpressionAnnotation" return value violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(_id74));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id74;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref58(t.genericTypeAnnotation(t.identifier('Array'),t.typeParameterDeclaration(path.get('elements').map(getAnnotation))));}<span class="fstat-no" title="function not covered" ></span>function getObjectExpressionAnnotation(path){<span class="fstat-no" title="function not covered" ></span>function _ref59(_id75){<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(_id75)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getObjectExpressionAnnotation" return value violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(_id75));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id75;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar annotation=t.objectTypeAnnotation(path.get('properties').filter(<span class="fstat-no" title="function not covered" >function(prop){<span class="cstat-no" title="statement not covered" ></span>return !prop.node.computed;}</span>).map(getAnnotation).reduce(<span class="fstat-no" title="function not covered" >function(properties,prop){<span class="cstat-no" title="statement not covered" ></span>if(t.isObjectTypeProperty(prop)){<span class="cstat-no" title="statement not covered" >properties.push(prop);}</span>else <span class="cstat-no" title="statement not covered" >if(t.isObjectTypeAnnotation(prop)){<span class="cstat-no" title="statement not covered" >properties.push.apply(properties,_toConsumableArray(prop.properties));}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn properties;}</span>,[]).filter(<span class="fstat-no" title="function not covered" >function(annotation){<span class="cstat-no" title="statement not covered" ></span>return !t.isAnyTypeAnnotation(annotation.value);}</span>));<span class="cstat-no" title="statement not covered" >r</span>eturn _ref59(annotation);}<span class="fstat-no" title="function not covered" ></span>function getMemberExpressionAnnotation(path){<span class="fstat-no" title="function not covered" ></span>function _ref60(_id76){<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(_id76)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getMemberExpressionAnnotation" return value violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(_id76));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id76;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(path.node.computed){<span class="cstat-no" title="statement not covered" >return _ref60(getComputedMemberExpressionAnnotation(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar stack=[];<span class="cstat-no" title="statement not covered" >v</span>ar target=path;<span class="cstat-no" title="statement not covered" >w</span>hile(target.isMemberExpression()){<span class="cstat-no" title="statement not covered" >stack.push(target);<span class="cstat-no" title="statement not covered" >i</span>f(target.node.computed){<span class="cstat-no" title="statement not covered" >break;}<span class="cstat-no" title="statement not covered" ></span>t</span>arget=target.get('object');}<span class="cstat-no" title="statement not covered" ></span>v</span>ar objectAnnotation=stack.reduceRight(<span class="fstat-no" title="function not covered" >function(last,target){<span class="cstat-no" title="statement not covered" ></span>var annotation=last;<span class="cstat-no" title="statement not covered" >i</span>f(annotation==null){<span class="cstat-no" title="statement not covered" >if(stack.length===1){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(target.get('object'));}</span>else {<span class="cstat-no" title="statement not covered" >return getAnnotation(target);}</span>}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(annotation.type){case 'AnyTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation;c</span>ase 'NullableTypeAnnotation':case 'TypeAnnotation':<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(annotation.type==='GenericTypeAnnotation'){<span class="cstat-no" title="statement not covered" >var typeChecker=getTypeChecker(annotation.id,path.scope);<span class="cstat-no" title="statement not covered" >i</span>f(typeChecker){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(typeChecker);}</span>else <span class="cstat-no" title="statement not covered" >if(isPolymorphicType(annotation.id,path.scope)){<span class="cstat-no" title="statement not covered" >annotation=t.anyTypeAnnotation();}</span>else {<span class="cstat-no" title="statement not covered" >var binding=path.scope.getBinding(annotation.id.name);<span class="cstat-no" title="statement not covered" >i</span>f(binding){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(binding.path);}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span></span>s</span>witch(annotation.type){case 'AnyTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation;c</span>ase 'ObjectTypeAnnotation':<span class="cstat-no" title="statement not covered" >var id=target.get('property').node;<span class="cstat-no" title="statement not covered" >_</span>ref61=annotation.properties||[];<span class="cstat-no" title="statement not covered" >i</span>f(!(_ref61&amp;&amp;(typeof _ref61[Symbol.iterator]==='function'||Array.isArray(_ref61)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _ref61 to be iterable, got '+_inspect(_ref61));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion13=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError13=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError13=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator13=_ref61[Symbol.iterator](),_step13;!(_iteratorNormalCompletion13=(_step13=_iterator13.next()).done);_iteratorNormalCompletion13=true){<span class="cstat-no" title="statement not covered" >var _ref61;<span class="cstat-no" title="statement not covered" >v</span>ar _step13$value=_step13.value;<span class="cstat-no" title="statement not covered" >v</span>ar key=_step13$value.key;<span class="cstat-no" title="statement not covered" >v</span>ar value=_step13$value.value;<span class="cstat-no" title="statement not covered" >i</span>f(key.name===id.name){<span class="cstat-no" title="statement not covered" >return value.type==='VoidTypeAnnotation'||value.type==='NullLiteralTypeAnnotation'?t.anyTypeAnnotation():value;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError13=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError13=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion13&amp;&amp;_iterator13.return){<span class="cstat-no" title="statement not covered" >_iterator13.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError13){<span class="cstat-no" title="statement not covered" >throw _iteratorError13;}</span>}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.anyTypeAnnotation();}</span>,null);<span class="cstat-no" title="statement not covered" >r</span>eturn _ref60(objectAnnotation||path.getTypeAnnotation());}<span class="fstat-no" title="function not covered" ></span>function getComputedMemberExpressionAnnotation(path){<span class="fstat-no" title="function not covered" ></span>function _ref62(_id77){<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(_id77)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getComputedMemberExpressionAnnotation" return value violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(_id77));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id77;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar object=path.get('object');<span class="cstat-no" title="statement not covered" >v</span>ar property=path.get('property');<span class="cstat-no" title="statement not covered" >v</span>ar objectAnnotation=getAnnotation(object);<span class="cstat-no" title="statement not covered" >i</span>f(objectAnnotation.type==='TypeAnnotation'||objectAnnotation.type==='NullableTypeAnnotation'){<span class="cstat-no" title="statement not covered" >objectAnnotation=objectAnnotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar propertyAnnotation=getAnnotation(property);<span class="cstat-no" title="statement not covered" >i</span>f(propertyAnnotation.type==='TypeAnnotation'||propertyAnnotation.type==='NullableTypeAnnotation'){<span class="cstat-no" title="statement not covered" >propertyAnnotation=propertyAnnotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _property$evaluate=property.evaluate();<span class="cstat-no" title="statement not covered" >v</span>ar confident=_property$evaluate.confident;<span class="cstat-no" title="statement not covered" >v</span>ar value=_property$evaluate.value;<span class="cstat-no" title="statement not covered" >i</span>f(!confident){<span class="cstat-no" title="statement not covered" >return _ref62(path.getTypeAnnotation());}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(objectAnnotation.type){case 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(objectAnnotation.types.length===0){<span class="cstat-no" title="statement not covered" >break;}</span>else <span class="cstat-no" title="statement not covered" >if(typeof value==='number'){<span class="cstat-no" title="statement not covered" >if(!objectAnnotation.types[value]){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError('Invalid computed member expression for tuple: '+humanReadableType(objectAnnotation));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref62(objectAnnotation.types[value]);}</span>else {<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError('Invalid computed member expression for tuple: '+humanReadableType(objectAnnotation));}<span class="cstat-no" title="statement not covered" ></span>b</span></span>reak;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref62(path.getTypeAnnotation());}<span class="fstat-no" title="function not covered" ></span>function getFunctionForIdentifier(path){<span class="fstat-no" title="function not covered" ></span>function _ref63(_id78){<span class="cstat-no" title="statement not covered" ></span>if(!(typeof _id78==='boolean'||Node(_id78))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getFunctionForIdentifier" return value violates contract.\n\nExpected:\nbool | Node\n\nGot:\n'+_inspect(_id78));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id78;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(path.type!=='Identifier'){<span class="cstat-no" title="statement not covered" >return false;}</span>else <span class="cstat-no" title="statement not covered" >if(isTypeChecker(path.node,path.scope)||isPolymorphicType(path.node,path.scope)){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar ref=path.scope.getBinding(path.node.name);<span class="cstat-no" title="statement not covered" >i</span>f(!ref){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref63(t.isFunction(ref.path.parent)&amp;&amp;ref.path.parentPath);}</span> /**
   * Determine whether the given annotation is for an array.
   */<span class="fstat-no" title="function not covered" >function isStrictlyArrayAnnotation(annotation){<span class="fstat-no" title="function not covered" ></span>function _ref64(_id79){<span class="cstat-no" title="statement not covered" ></span>if(!(_id79==null||typeof _id79==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "isStrictlyArrayAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id79));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id79;}<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(annotation.type){case 'ArrayTypeAnnotation':case 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return _ref64(isStrictlyArrayAnnotation(annotation.typeAnnotation));c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation.id.name==='Array'?true:null;c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref64(annotation.types.every(isStrictlyArrayAnnotation));d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareMaybeUnion(annotation,comparator){<span class="fstat-no" title="function not covered" ></span>function _ref65(_id80){<span class="cstat-no" title="statement not covered" ></span>if(!(_id80==null||typeof _id80==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "compareMaybeUnion" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id80));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id80;}<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!(typeof comparator==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "comparator" violates contract.\n\nExpected:\n(TypeAnnotation) =&gt; ?bool\n\nGot:\n'+_inspect(comparator));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar falseCount=0;<span class="cstat-no" title="statement not covered" >_</span>annotation$types=annotation.types;<span class="cstat-no" title="statement not covered" >i</span>f(!(_annotation$types&amp;&amp;(typeof _annotation$types[Symbol.iterator]==='function'||Array.isArray(_annotation$types)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _annotation$types to be iterable, got '+_inspect(_annotation$types));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion14=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError14=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError14=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator14=_annotation$types[Symbol.iterator](),_step14;!(_iteratorNormalCompletion14=(_step14=_iterator14.next()).done);_iteratorNormalCompletion14=true){<span class="cstat-no" title="statement not covered" >var _annotation$types;<span class="cstat-no" title="statement not covered" >v</span>ar _type6=_step14.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=comparator(_type6);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError14=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError14=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion14&amp;&amp;_iterator14.return){<span class="cstat-no" title="statement not covered" >_iterator14.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError14){<span class="cstat-no" title="statement not covered" >throw _iteratorError14;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return _ref65(null);}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a number,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeNumberAnnotation(annotation){<span class="fstat-no" title="function not covered" ></span>function _ref66(_id81){<span class="cstat-no" title="statement not covered" ></span>if(!(_id81==null||typeof _id81==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "maybeNumberAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id81));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id81;}<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref66(maybeNumberAnnotation(annotation.typeAnnotation));c</span>ase 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'NumericLiteral':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return _ref66(null);}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref66(compareMaybeUnion(annotation,maybeNumberAnnotation));c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref66(null);d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a string,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeStringAnnotation(annotation){<span class="fstat-no" title="function not covered" ></span>function _ref67(_id82){<span class="cstat-no" title="statement not covered" ></span>if(!(_id82==null||typeof _id82==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "maybeStringAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id82));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id82;}<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref67(maybeStringAnnotation(annotation.typeAnnotation));c</span>ase 'StringTypeAnnotation':case 'StringLiteral':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'StringLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref67(null);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'Number':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return _ref67(null);}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >_</span>annotation$types2=annotation.types;<span class="cstat-no" title="statement not covered" >i</span>f(!(_annotation$types2&amp;&amp;(typeof _annotation$types2[Symbol.iterator]==='function'||Array.isArray(_annotation$types2)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _annotation$types2 to be iterable, got '+_inspect(_annotation$types2));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion15=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError15=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError15=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator15=_annotation$types2[Symbol.iterator](),_step15;!(_iteratorNormalCompletion15=(_step15=_iterator15.next()).done);_iteratorNormalCompletion15=true){<span class="cstat-no" title="statement not covered" >var _annotation$types2;<span class="cstat-no" title="statement not covered" >v</span>ar _type7=_step15.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeStringAnnotation(_type7);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError15=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError15=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion15&amp;&amp;_iterator15.return){<span class="cstat-no" title="statement not covered" >_iterator15.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError15){<span class="cstat-no" title="statement not covered" >throw _iteratorError15;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return _ref67(null);}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref67(null);d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a symbol,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeSymbolAnnotation(annotation){<span class="fstat-no" title="function not covered" ></span>function _ref68(_id83){<span class="cstat-no" title="statement not covered" ></span>if(!(_id83==null||typeof _id83==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "maybeSymbolAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id83));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id83;}<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref68(maybeSymbolAnnotation(annotation.typeAnnotation));c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'Number':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;c</span>ase 'Symbol':<span class="cstat-no" title="statement not covered" >return true;d</span>efault:<span class="cstat-no" title="statement not covered" >return _ref68(null);}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >_</span>annotation$types3=annotation.types;<span class="cstat-no" title="statement not covered" >i</span>f(!(_annotation$types3&amp;&amp;(typeof _annotation$types3[Symbol.iterator]==='function'||Array.isArray(_annotation$types3)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _annotation$types3 to be iterable, got '+_inspect(_annotation$types3));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion16=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError16=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError16=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator16=_annotation$types3[Symbol.iterator](),_step16;!(_iteratorNormalCompletion16=(_step16=_iterator16.next()).done);_iteratorNormalCompletion16=true){<span class="cstat-no" title="statement not covered" >var _annotation$types3;<span class="cstat-no" title="statement not covered" >v</span>ar _type8=_step16.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeSymbolAnnotation(_type8);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError16=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError16=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion16&amp;&amp;_iterator16.return){<span class="cstat-no" title="statement not covered" >_iterator16.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError16){<span class="cstat-no" title="statement not covered" >throw _iteratorError16;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return _ref68(null);}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref68(null);d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a boolean,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeBooleanAnnotation(annotation){<span class="fstat-no" title="function not covered" ></span>function _ref69(_id84){<span class="cstat-no" title="statement not covered" ></span>if(!(_id84==null||typeof _id84==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "maybeBooleanAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id84));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id84;}<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref69(maybeBooleanAnnotation(annotation.typeAnnotation));c</span>ase 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'BooleanLiteral':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'String':case 'Number':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return _ref69(null);}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >_</span>annotation$types4=annotation.types;<span class="cstat-no" title="statement not covered" >i</span>f(!(_annotation$types4&amp;&amp;(typeof _annotation$types4[Symbol.iterator]==='function'||Array.isArray(_annotation$types4)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _annotation$types4 to be iterable, got '+_inspect(_annotation$types4));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion17=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError17=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError17=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator17=_annotation$types4[Symbol.iterator](),_step17;!(_iteratorNormalCompletion17=(_step17=_iterator17.next()).done);_iteratorNormalCompletion17=true){<span class="cstat-no" title="statement not covered" >var _annotation$types4;<span class="cstat-no" title="statement not covered" >v</span>ar _type9=_step17.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeBooleanAnnotation(_type9);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError17=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError17=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion17&amp;&amp;_iterator17.return){<span class="cstat-no" title="statement not covered" >_iterator17.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError17){<span class="cstat-no" title="statement not covered" >throw _iteratorError17;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return _ref69(null);}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref69(null);d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a function,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeFunctionAnnotation(annotation){<span class="fstat-no" title="function not covered" ></span>function _ref70(_id85){<span class="cstat-no" title="statement not covered" ></span>if(!(_id85==null||typeof _id85==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "maybeFunctionAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id85));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id85;}<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref70(maybeFunctionAnnotation(annotation.typeAnnotation));c</span>ase 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Number':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return _ref70(null);}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >_</span>annotation$types5=annotation.types;<span class="cstat-no" title="statement not covered" >i</span>f(!(_annotation$types5&amp;&amp;(typeof _annotation$types5[Symbol.iterator]==='function'||Array.isArray(_annotation$types5)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _annotation$types5 to be iterable, got '+_inspect(_annotation$types5));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion18=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError18=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError18=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator18=_annotation$types5[Symbol.iterator](),_step18;!(_iteratorNormalCompletion18=(_step18=_iterator18.next()).done);_iteratorNormalCompletion18=true){<span class="cstat-no" title="statement not covered" >var _annotation$types5;<span class="cstat-no" title="statement not covered" >v</span>ar _type10=_step18.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeFunctionAnnotation(_type10);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError18=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError18=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion18&amp;&amp;_iterator18.return){<span class="cstat-no" title="statement not covered" >_iterator18.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError18){<span class="cstat-no" title="statement not covered" >throw _iteratorError18;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return _ref70(null);}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref70(null);d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with an undefined or null type,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeNullableAnnotation(annotation){<span class="fstat-no" title="function not covered" ></span>function _ref71(_id86){<span class="cstat-no" title="statement not covered" ></span>if(!(_id86==null||typeof _id86==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "maybeNullableAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id86));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id86;}<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(annotation.type){case 'NullableTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'MixedTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return _ref71(maybeNullableAnnotation(annotation.typeAnnotation));c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Number':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;c</span>ase 'Generator':<span class="cstat-no" title="statement not covered" >if(annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1){<span class="cstat-no" title="statement not covered" >return _ref71(maybeNullableAnnotation(annotation.typeParameters.params[1]));}</span>else {<span class="cstat-no" title="statement not covered" >return _ref71(null);}</span>d</span>efault:<span class="cstat-no" title="statement not covered" >return _ref71(null);}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >_</span>annotation$types6=annotation.types;<span class="cstat-no" title="statement not covered" >i</span>f(!(_annotation$types6&amp;&amp;(typeof _annotation$types6[Symbol.iterator]==='function'||Array.isArray(_annotation$types6)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _annotation$types6 to be iterable, got '+_inspect(_annotation$types6));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion19=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError19=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError19=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator19=_annotation$types6[Symbol.iterator](),_step19;!(_iteratorNormalCompletion19=(_step19=_iterator19.next()).done);_iteratorNormalCompletion19=true){<span class="cstat-no" title="statement not covered" >var _annotation$types6;<span class="cstat-no" title="statement not covered" >v</span>ar _type11=_step19.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeNullableAnnotation(_type11);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError19=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError19=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion19&amp;&amp;_iterator19.return){<span class="cstat-no" title="statement not covered" >_iterator19.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError19){<span class="cstat-no" title="statement not covered" >throw _iteratorError19;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return _ref71(null);}</span>d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with an object type,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeInstanceOfAnnotation(annotation,expected,typeParameters){<span class="fstat-no" title="function not covered" ></span>function _ref72(_id87){<span class="cstat-no" title="statement not covered" ></span>if(!(_id87==null||typeof _id87==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "maybeInstanceOfAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id87));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id87;}<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!Identifier(expected)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "expected" violates contract.\n\nExpected:\nIdentifier\n\nGot:\n'+_inspect(expected));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!(Array.isArray(typeParameters)&amp;&amp;typeParameters.every(<span class="fstat-no" title="function not covered" >function(item){<span class="cstat-no" title="statement not covered" ></span>return TypeAnnotation(item);}</span>))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "typeParameters" violates contract.\n\nExpected:\nTypeAnnotation[]\n\nGot:\n'+_inspect(typeParameters));}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref72(maybeInstanceOfAnnotation(annotation.typeAnnotation,expected,typeParameters));c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(annotation.id.name===expected.name){<span class="cstat-no" title="statement not covered" >if(typeParameters.length===0){<span class="cstat-no" title="statement not covered" >return true;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length){<span class="cstat-no" title="statement not covered" >var trueCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar nullCount=0;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;typeParameters.length&amp;&amp;i&lt;annotation.typeParameters.params.length;i++){<span class="cstat-no" title="statement not covered" >var result=compareAnnotations(typeParameters[i],annotation.typeParameters.params[i]);<span class="cstat-no" title="statement not covered" >i</span>f(result===false){<span class="cstat-no" title="statement not covered" >return false;}</span>else <span class="cstat-no" title="statement not covered" >if(result===true){<span class="cstat-no" title="statement not covered" >trueCount++;}</span>else {<span class="cstat-no" title="statement not covered" >nullCount++;}</span>}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn trueCount&gt;0&amp;&amp;nullCount===0?true:null;}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref72(null);c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >_</span>annotation$types7=annotation.types;<span class="cstat-no" title="statement not covered" >i</span>f(!(_annotation$types7&amp;&amp;(typeof _annotation$types7[Symbol.iterator]==='function'||Array.isArray(_annotation$types7)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _annotation$types7 to be iterable, got '+_inspect(_annotation$types7));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion20=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError20=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError20=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator20=_annotation$types7[Symbol.iterator](),_step20;!(_iteratorNormalCompletion20=(_step20=_iterator20.next()).done);_iteratorNormalCompletion20=true){<span class="cstat-no" title="statement not covered" >var _annotation$types7;<span class="cstat-no" title="statement not covered" >v</span>ar _type12=_step20.value;<span class="cstat-no" title="statement not covered" >v</span>ar _result=maybeInstanceOfAnnotation(_type12,expected,typeParameters);<span class="cstat-no" title="statement not covered" >i</span>f(_result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(_result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError20=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError20=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion20&amp;&amp;_iterator20.return){<span class="cstat-no" title="statement not covered" >_iterator20.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError20){<span class="cstat-no" title="statement not covered" >throw _iteratorError20;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return _ref72(null);}</span>c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(expected.name==='Array'||expected.name==='RegExp'||expected.name==='Error'||expected.name==='Function'||expected.name==='String'||expected.name==='Object'){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return _ref72(null);}</span>c</span>ase 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(expected.name==='Array'||expected.name==='RegExp'||expected.name==='Error'||expected.name==='Function'){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return _ref72(null);}</span>c</span>ase 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(expected.name==='Function'){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return _ref72(null);}</span>d</span>efault:<span class="cstat-no" title="statement not covered" >return _ref72(null);}</span>}</span> /**
   * Returns `true` if the annotation is compatible with an array,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeArrayAnnotation(annotation){<span class="fstat-no" title="function not covered" ></span>function _ref73(_id88){<span class="cstat-no" title="statement not covered" ></span>if(!(_id88==null||typeof _id88==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "maybeArrayAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id88));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id88;}<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref73(maybeArrayAnnotation(annotation.typeAnnotation));c</span>ase 'TupleTypeAnnotation':case 'ArrayTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation.id.name==='Array'?true:null;c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >_</span>annotation$types8=annotation.types;<span class="cstat-no" title="statement not covered" >i</span>f(!(_annotation$types8&amp;&amp;(typeof _annotation$types8[Symbol.iterator]==='function'||Array.isArray(_annotation$types8)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _annotation$types8 to be iterable, got '+_inspect(_annotation$types8));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion21=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError21=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError21=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator21=_annotation$types8[Symbol.iterator](),_step21;!(_iteratorNormalCompletion21=(_step21=_iterator21.next()).done);_iteratorNormalCompletion21=true){<span class="cstat-no" title="statement not covered" >var _annotation$types8;<span class="cstat-no" title="statement not covered" >v</span>ar _type13=_step21.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeArrayAnnotation(_type13);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError21=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError21=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion21&amp;&amp;_iterator21.return){<span class="cstat-no" title="statement not covered" >_iterator21.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError21){<span class="cstat-no" title="statement not covered" >throw _iteratorError21;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return _ref73(null);}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref73(null);d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with an iterable,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeIterableAnnotation(annotation){<span class="fstat-no" title="function not covered" ></span>function _ref74(_id89){<span class="cstat-no" title="statement not covered" ></span>if(!(_id89==null||typeof _id89==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "maybeIterableAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id89));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id89;}<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref74(maybeIterableAnnotation(annotation.typeAnnotation));c</span>ase 'TupleTypeAnnotation':case 'ArrayTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation.id.name==='Iterable'?true:null;c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >_</span>annotation$types9=annotation.types;<span class="cstat-no" title="statement not covered" >i</span>f(!(_annotation$types9&amp;&amp;(typeof _annotation$types9[Symbol.iterator]==='function'||Array.isArray(_annotation$types9)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _annotation$types9 to be iterable, got '+_inspect(_annotation$types9));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion22=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError22=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError22=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator22=_annotation$types9[Symbol.iterator](),_step22;!(_iteratorNormalCompletion22=(_step22=_iterator22.next()).done);_iteratorNormalCompletion22=true){<span class="cstat-no" title="statement not covered" >var _annotation$types9;<span class="cstat-no" title="statement not covered" >v</span>ar _type14=_step22.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeIterableAnnotation(_type14);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError22=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError22=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion22&amp;&amp;_iterator22.return){<span class="cstat-no" title="statement not covered" >_iterator22.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError22){<span class="cstat-no" title="statement not covered" >throw _iteratorError22;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return _ref74(null);}</span>c</span>ase 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return _ref74(null);}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a tuple,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeTupleAnnotation(annotation){<span class="fstat-no" title="function not covered" ></span>function _ref75(_id90){<span class="cstat-no" title="statement not covered" ></span>if(!(_id90==null||typeof _id90==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "maybeTupleAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id90));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id90;}<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref75(maybeTupleAnnotation(annotation.typeAnnotation));c</span>ase 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >_</span>annotation$types10=annotation.types;<span class="cstat-no" title="statement not covered" >i</span>f(!(_annotation$types10&amp;&amp;(typeof _annotation$types10[Symbol.iterator]==='function'||Array.isArray(_annotation$types10)))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Expected _annotation$types10 to be iterable, got '+_inspect(_annotation$types10));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion23=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError23=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError23=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator23=_annotation$types10[Symbol.iterator](),_step23;!(_iteratorNormalCompletion23=(_step23=_iterator23.next()).done);_iteratorNormalCompletion23=true){<span class="cstat-no" title="statement not covered" >var _annotation$types10;<span class="cstat-no" title="statement not covered" >v</span>ar _type15=_step23.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeTupleAnnotation(_type15);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError23=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError23=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion23&amp;&amp;_iterator23.return){<span class="cstat-no" title="statement not covered" >_iterator23.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError23){<span class="cstat-no" title="statement not covered" >throw _iteratorError23;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return _ref75(null);}</span>c</span>ase 'GenericTypeAnnotation':case 'AnyTypeAnnotation':case 'ArrayTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return _ref75(null);d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}<span class="fstat-no" title="function not covered" ></span>function humanReadableType(annotation){<span class="fstat-no" title="function not covered" ></span>function _ref76(_id91){<span class="cstat-no" title="statement not covered" ></span>if(!(typeof _id91==='string')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "humanReadableType" return value violates contract.\n\nExpected:\nstring\n\nGot:\n'+_inspect(_id91));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id91;}<span class="cstat-no" title="statement not covered" ></span>if(!(Node(annotation)||TypeAnnotation(annotation))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nNode | TypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return _ref76(humanReadableType(annotation.typeAnnotation));c</span>ase 'FunctionTypeAnnotation': // @fixme babel doesn't seem to like generating FunctionTypeAnnotations yet</span>
<span class="cstat-no" title="statement not covered" >return '('+annotation.params.map(humanReadableType).join(', ')+') =&gt; '+humanReadableType(annotation.returnType);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >var path=getNodePath(annotation);<span class="cstat-no" title="statement not covered" >v</span>ar checker=path&amp;&amp;getTypeChecker(annotation.id,path.scope);<span class="cstat-no" title="statement not covered" >i</span>f(checker&amp;&amp;checker.node.savedTypeAnnotation){<span class="cstat-no" title="statement not covered" >return _ref76(humanReadableType(checker.node.savedTypeAnnotation));}</span>else {<span class="cstat-no" title="statement not covered" >return _ref76((0,_babelGenerator2.default)(annotation).code);}</span>d</span>efault:<span class="cstat-no" title="statement not covered" >return _ref76((0,_babelGenerator2.default)(annotation).code);}</span>} /**
   * Get the path directly from a node.
   */<span class="fstat-no" title="function not covered" >function getNodePath(node){<span class="fstat-no" title="function not covered" ></span>function _ref77(_id92){<span class="cstat-no" title="statement not covered" ></span>if(!(_id92==null||NodePath(_id92))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getNodePath" return value violates contract.\n\nExpected:\n?NodePath\n\nGot:\n'+_inspect(_id92));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id92;}<span class="cstat-no" title="statement not covered" ></span>if(!Node(node)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node._paths&amp;&amp;node._paths.length){<span class="cstat-no" title="statement not covered" >return _ref77(node._paths[0]);}</span>else {<span class="cstat-no" title="statement not covered" >return _ref77(null);}</span>}<span class="fstat-no" title="function not covered" ></span>function getTypeChecker(id,scope){<span class="fstat-no" title="function not covered" ></span>function _ref78(_id93){<span class="cstat-no" title="statement not covered" ></span>if(!(NodePath(_id93)||_id93===false)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getTypeChecker" return value violates contract.\n\nExpected:\nNodePath | false\n\nGot:\n'+_inspect(_id93));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id93;}<span class="cstat-no" title="statement not covered" ></span>if(!(Identifier(id)||QualifiedTypeIdentifier(id))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "id" violates contract.\n\nExpected:\nIdentifier | QualifiedTypeIdentifier\n\nGot:\n'+_inspect(id));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!Scope(scope)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "scope" violates contract.\n\nExpected:\nScope\n\nGot:\n'+_inspect(scope));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checker=scope.getData('typechecker:'+id.name);<span class="cstat-no" title="statement not covered" >i</span>f(checker){<span class="cstat-no" title="statement not covered" >return _ref78(checker);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}<span class="fstat-no" title="function not covered" ></span>function isTypeChecker(id,scope){<span class="fstat-no" title="function not covered" ></span>function _ref79(_id94){<span class="cstat-no" title="statement not covered" ></span>if(!(typeof _id94==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "isTypeChecker" return value violates contract.\n\nExpected:\nbool\n\nGot:\n'+_inspect(_id94));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id94;}<span class="cstat-no" title="statement not covered" ></span>if(!(Identifier(id)||QualifiedTypeIdentifier(id))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "id" violates contract.\n\nExpected:\nIdentifier | QualifiedTypeIdentifier\n\nGot:\n'+_inspect(id));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!Scope(scope)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "scope" violates contract.\n\nExpected:\nScope\n\nGot:\n'+_inspect(scope));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref79(scope.getData('typechecker:'+id.name)!==undefined);}<span class="fstat-no" title="function not covered" ></span>function isPolymorphicType(id,scope){<span class="fstat-no" title="function not covered" ></span>function _ref80(_id95){<span class="cstat-no" title="statement not covered" ></span>if(!(typeof _id95==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "isPolymorphicType" return value violates contract.\n\nExpected:\nbool\n\nGot:\n'+_inspect(_id95));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id95;}<span class="cstat-no" title="statement not covered" ></span>if(!(Identifier(id)||QualifiedTypeIdentifier(id))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "id" violates contract.\n\nExpected:\nIdentifier | QualifiedTypeIdentifier\n\nGot:\n'+_inspect(id));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!Scope(scope)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "scope" violates contract.\n\nExpected:\nScope\n\nGot:\n'+_inspect(scope));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref80(scope.getData('typeparam:'+id.name)!==undefined);}<span class="fstat-no" title="function not covered" ></span>function getPolymorphicType(id,scope){<span class="fstat-no" title="function not covered" ></span>function _ref81(_id96){<span class="cstat-no" title="statement not covered" ></span>if(!(_id96==null||Node(_id96))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getPolymorphicType" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id96));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id96;}<span class="cstat-no" title="statement not covered" ></span>if(!(Identifier(id)||QualifiedTypeIdentifier(id))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "id" violates contract.\n\nExpected:\nIdentifier | QualifiedTypeIdentifier\n\nGot:\n'+_inspect(id));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!Scope(scope)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "scope" violates contract.\n\nExpected:\nScope\n\nGot:\n'+_inspect(scope));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar path=scope.getData('typeparam:'+id.name);<span class="cstat-no" title="statement not covered" >i</span>f(path){<span class="cstat-no" title="statement not covered" >return _ref81(path.node);}</span>}<span class="fstat-no" title="function not covered" ></span>function collectParamChecks(path,context){<span class="fstat-no" title="function not covered" ></span>function _ref82(_id97){<span class="cstat-no" title="statement not covered" ></span>if(!(Array.isArray(_id97)&amp;&amp;_id97.every(<span class="fstat-no" title="function not covered" >function(item){<span class="cstat-no" title="statement not covered" ></span>return Node(item);}</span>))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "collectParamChecks" return value violates contract.\n\nExpected:\nNode[]\n\nGot:\n'+_inspect(_id97));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id97;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!VisitorContext(context)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref82(path.get('params').map(<span class="fstat-no" title="function not covered" >function(param){<span class="cstat-no" title="statement not covered" ></span>var node=param.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='AssignmentPattern'){<span class="cstat-no" title="statement not covered" >if(node.left.typeAnnotation){<span class="cstat-no" title="statement not covered" >return createDefaultParamGuard(param,context);}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='RestElement'){<span class="cstat-no" title="statement not covered" >if(node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return createRestParamGuard(param,context);}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return createParamGuard(param,context);}</span>}</span></span></span>).filter(identity));}<span class="fstat-no" title="function not covered" ></span>function createParamGuard(path,context){<span class="fstat-no" title="function not covered" ></span>function _ref83(_id98){<span class="cstat-no" title="statement not covered" ></span>if(!(_id98==null||Node(_id98))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "createParamGuard" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id98));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id98;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!VisitorContext(context)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >n</span>ode.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >n</span>ode.savedTypeAnnotation=node.typeAnnotation;<span class="cstat-no" title="statement not covered" >v</span>ar checkable=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='ObjectPattern'){<span class="cstat-no" title="statement not covered" >node.name=path.key;<span class="cstat-no" title="statement not covered" >c</span>heckable=t.memberExpression(t.identifier('arguments'),t.numericLiteral(path.key),true);}</span>else {<span class="cstat-no" title="statement not covered" >checkable=node;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar check=checkAnnotation(checkable,node.typeAnnotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!check){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.optional){<span class="cstat-no" title="statement not covered" >check=t.logicalExpression('||',checks.undefined({input:checkable}),check);}<span class="cstat-no" title="statement not covered" ></span>v</span>ar message=paramTypeErrorMessage(checkable,context,node.typeAnnotation);<span class="cstat-no" title="statement not covered" >r</span>eturn _ref83(guard({check:check,message:message}));}<span class="fstat-no" title="function not covered" ></span>function createDefaultParamGuard(path,context){<span class="fstat-no" title="function not covered" ></span>function _ref84(_id99){<span class="cstat-no" title="statement not covered" ></span>if(!(_id99==null||Node(_id99))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "createDefaultParamGuard" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id99));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id99;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!VisitorContext(context)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.left;<span class="cstat-no" title="statement not covered" >v</span>ar value=node.right;<span class="cstat-no" title="statement not covered" >v</span>ar ok=staticCheckAnnotation(path.get('right'),id.typeAnnotation);<span class="cstat-no" title="statement not covered" >i</span>f(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid default value for argument "'+id.name+'".',id.typeAnnotation,getAnnotation(path.get('right'))));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref84(createParamGuard(path.get('left'),context));}<span class="fstat-no" title="function not covered" ></span>function createRestParamGuard(path,context){<span class="fstat-no" title="function not covered" ></span>function _ref85(_id100){<span class="cstat-no" title="statement not covered" ></span>if(!(_id100==null||Node(_id100))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "createRestParamGuard" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id100));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id100;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!VisitorContext(context)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.argument;<span class="cstat-no" title="statement not covered" >i</span>d.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >n</span>ode.savedTypeAnnotation=node.typeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(isStrictlyArrayAnnotation(node.typeAnnotation)===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid type annotation for rest argument "'+id.name+'".',t.genericTypeAnnotation(t.identifier('Array')),node.typeAnnotation));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar check=checkAnnotation(id,node.typeAnnotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!check){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.optional){<span class="cstat-no" title="statement not covered" >check=t.logicalExpression('||',checks.undefined({input:id}),check);}<span class="cstat-no" title="statement not covered" ></span>v</span>ar message=paramTypeErrorMessage(id,context,node.typeAnnotation);<span class="cstat-no" title="statement not covered" >r</span>eturn _ref85(guard({check:check,message:message}));}<span class="fstat-no" title="function not covered" ></span>function returnTypeErrorMessage(path,fn,id,context){<span class="fstat-no" title="function not covered" ></span>function _ref86(_id101){<span class="cstat-no" title="statement not covered" ></span>if(!Node(_id101)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "returnTypeErrorMessage" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id101));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id101;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!Node(fn)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "fn" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(fn));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!(id==null||Identifier(id)||Literal(id))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "id" violates contract.\n\nExpected:\n?Identifier | Literal\n\nGot:\n'+_inspect(id));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!VisitorContext(context)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar name=fn.id?fn.id.name:'';<span class="cstat-no" title="statement not covered" >v</span>ar annotation=fn.returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(fn.generator&amp;&amp;isGeneratorAnnotation(annotation)&amp;&amp;annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters.params[1];}<span class="cstat-no" title="statement not covered" ></span>v</span>ar message='Function '+(name?'"'+name+'" ':'')+'return value violates contract.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn _ref86(t.binaryExpression('+',t.stringLiteral(message),id?readableName({inspect:context.inspect,input:id}):node.argument?readableName({inspect:context.inspect,input:node.argument}):t.stringLiteral('undefined')));}<span class="fstat-no" title="function not covered" ></span>function yieldTypeErrorMessage(fn,annotation,id,context){<span class="fstat-no" title="function not covered" ></span>function _ref87(_id102){<span class="cstat-no" title="statement not covered" ></span>if(!Node(_id102)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "yieldTypeErrorMessage" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id102));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id102;}<span class="cstat-no" title="statement not covered" ></span>if(!Node(fn)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "fn" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(fn));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!(Identifier(id)||Literal(id))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "id" violates contract.\n\nExpected:\nIdentifier | Literal\n\nGot:\n'+_inspect(id));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!VisitorContext(context)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar name=fn.id?fn.id.name:'';<span class="cstat-no" title="statement not covered" >v</span>ar message='Function '+(name?'"'+name+'" ':'')+'yielded an invalid value.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn _ref87(t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:id})));}<span class="fstat-no" title="function not covered" ></span>function yieldNextTypeErrorMessage(fn,annotation,id,context){<span class="fstat-no" title="function not covered" ></span>function _ref88(_id103){<span class="cstat-no" title="statement not covered" ></span>if(!Node(_id103)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "yieldNextTypeErrorMessage" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id103));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id103;}<span class="cstat-no" title="statement not covered" ></span>if(!Node(fn)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "fn" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(fn));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!(Identifier(id)||Literal(id))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "id" violates contract.\n\nExpected:\nIdentifier | Literal\n\nGot:\n'+_inspect(id));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!VisitorContext(context)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar name=fn.id?fn.id.name:'';<span class="cstat-no" title="statement not covered" >v</span>ar message='Generator '+(name?'"'+name+'" ':'')+'received an invalid next value.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn _ref88(t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:id})));}<span class="fstat-no" title="function not covered" ></span>function paramTypeErrorMessage(node,context){<span class="cstat-no" title="statement not covered" ></span>var typeAnnotation=arguments.length&lt;=2||arguments[2]===undefined?node.typeAnnotation:arguments[2];<span class="fstat-no" title="function not covered" >f</span>unction _ref89(_id104){<span class="cstat-no" title="statement not covered" ></span>if(!Node(_id104)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "paramTypeErrorMessage" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id104));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id104;}<span class="cstat-no" title="statement not covered" ></span>if(!Node(node)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!VisitorContext(context)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!TypeAnnotation(typeAnnotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "typeAnnotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(typeAnnotation));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar name=node.name;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='MemberExpression'&amp;&amp;node.object.name==='arguments'){<span class="cstat-no" title="statement not covered" >name=node.property.value;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar message='Value of '+(node.optional?'optional ':'')+'argument '+JSON.stringify(name)+' violates contract.\n\nExpected:\n'+humanReadableType(typeAnnotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn _ref89(t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:node})));}<span class="fstat-no" title="function not covered" ></span>function varTypeErrorMessage(node,context){<span class="fstat-no" title="function not covered" ></span>function _ref90(_id105){<span class="cstat-no" title="statement not covered" ></span>if(!Node(_id105)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "varTypeErrorMessage" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id105));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id105;}<span class="cstat-no" title="statement not covered" ></span>if(!Node(node)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!VisitorContext(context)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar annotation=node.typeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.type==='Identifier'){<span class="cstat-no" title="statement not covered" >var _name3=node.name;<span class="cstat-no" title="statement not covered" >v</span>ar message='Value of variable "'+_name3+'" violates contract.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn _ref90(t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:node})));}</span>else {<span class="cstat-no" title="statement not covered" >var _message='Value of "'+humanReadableType(node)+'" violates contract.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn _ref90(t.binaryExpression('+',t.stringLiteral(_message),readableName({inspect:context.inspect,input:node})));}</span>}</span> /**
   * Create a React property validator
   */<span class="fstat-no" title="function not covered" >function generatePropType(annotation,scope,context){<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!Scope(scope)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "scope" violates contract.\n\nExpected:\nScope\n\nGot:\n'+_inspect(scope));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!VisitorContext(context)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar prop=t.identifier('prop');<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(prop,annotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >return propType({check:check,prop:prop,expected:t.stringLiteral(humanReadableType(annotation)),got:readableName({inspect:context.inspect,input:prop})});}</span>else {<span class="cstat-no" title="statement not covered" >return t.functionExpression(null,[],t.blockStatement([]));}</span>}</span> /**
   * Determine whether the given node can produce purely boolean results.
   */<span class="fstat-no" title="function not covered" >function isBooleanExpression(node){<span class="cstat-no" title="statement not covered" ></span>if(!Node(node)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.type==='BinaryExpression'&amp;&amp;BOOLEAN_BINARY_OPERATORS.indexOf(node.operator)&gt;-1){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='LogicalExpression'){<span class="cstat-no" title="statement not covered" >return isBooleanExpression(node.left)&amp;&amp;isBooleanExpression(node.right);}</span>else {<span class="cstat-no" title="statement not covered" >return false;}</span>}</span></span> /**
   * Convert type specifier to expression.
   */<span class="fstat-no" title="function not covered" >function createTypeExpression(node){<span class="fstat-no" title="function not covered" ></span>function _ref91(_id106){<span class="cstat-no" title="statement not covered" ></span>if(!(_id106 instanceof Object)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "createTypeExpression" return value violates contract.\n\nExpected:\nObject\n\nGot:\n'+_inspect(_id106));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id106;}<span class="cstat-no" title="statement not covered" ></span>if(!Node(node)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.type=='Identifier'){<span class="cstat-no" title="statement not covered" >return _ref91(node);}</span>else <span class="cstat-no" title="statement not covered" >if(node.type=='QualifiedTypeIdentifier'){<span class="cstat-no" title="statement not covered" >return _ref91(t.memberExpression(createTypeExpression(node.qualification),createTypeExpression(node.id)));}<span class="cstat-no" title="statement not covered" ></span>t</span></span>hrow this.errorWithNode('Unsupported type: '+node.type);}</span> /**
   * Get name of a type as a string.
   */<span class="fstat-no" title="function not covered" >function getTypeName(node){<span class="fstat-no" title="function not covered" ></span>function _ref92(_id107){<span class="cstat-no" title="statement not covered" ></span>if(!(typeof _id107==='string')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getTypeName" return value violates contract.\n\nExpected:\nstring\n\nGot:\n'+_inspect(_id107));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id107;}<span class="cstat-no" title="statement not covered" ></span>if(!Node(node)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.type=='Identifier'){<span class="cstat-no" title="statement not covered" >return _ref92(node.name);}</span>else <span class="cstat-no" title="statement not covered" >if(node.type=='QualifiedTypeIdentifier'){<span class="cstat-no" title="statement not covered" >return _ref92(getTypeName(node.qualification)+'.'+getTypeName(node.id));}<span class="cstat-no" title="statement not covered" ></span>t</span></span>hrow this.errorWithNode('Unsupported type: '+node.type);}</span> /**
   * Union two arrays.
   */<span class="fstat-no" title="function not covered" >function union(arr1,arr2){<span class="cstat-no" title="statement not covered" ></span>if(!Array.isArray(arr1)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "arr1" violates contract.\n\nExpected:\nArray\n\nGot:\n'+_inspect(arr1));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!Array.isArray(arr2)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "arr2" violates contract.\n\nExpected:\nArray\n\nGot:\n'+_inspect(arr2));}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=0;i&lt;arr2.length;i++){<span class="cstat-no" title="statement not covered" >var item=arr2[i];<span class="cstat-no" title="statement not covered" >i</span>f(arr1.indexOf(item)===-1){<span class="cstat-no" title="statement not covered" >arr1.push(item);}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn arr1;}</span> /**
   * Determine whether the given annotation allows any value.
   */<span class="fstat-no" title="function not covered" >function allowsAny(annotation){<span class="fstat-no" title="function not covered" ></span>function _ref94(_id109){<span class="cstat-no" title="statement not covered" ></span>if(!(typeof _id109==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "allowsAny" return value violates contract.\n\nExpected:\nbool\n\nGot:\n'+_inspect(_id109));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id109;}<span class="cstat-no" title="statement not covered" ></span>if(!TypeAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(annotation.type==='TypeAnnotation'||annotation.type==='NullableTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return _ref94(allowsAny(annotation.typeAnnotation));}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.type==='AnyTypeAnnotation'||annotation.type==='MixedTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.type==='UnionTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return _ref94(annotation.types.some(allowsAny));}</span>else {<span class="cstat-no" title="statement not covered" >return false;}</span>}</span></span></span> /**
   * Determine whether a given node is nully (null or undefined).
   */<span class="fstat-no" title="function not covered" >function isNodeNully(node){<span class="cstat-no" title="statement not covered" ></span>if(!(node==null||Node(node))){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(node));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node==null){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='Identifier'&amp;&amp;node.name==='undefined'){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='Literal'&amp;&amp;node.value===null){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='UnaryExpression'&amp;&amp;node.operator==='void'){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return false;}</span>}</span></span></span></span> /**
   * Determine whether the file should be checked
   */<span class="fstat-no" title="function not covered" >function mustCheckFile(path,opts){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(path.node.leadingComments&amp;&amp;path.node.leadingComments.length){<span class="cstat-no" title="statement not covered" >return opts.only&amp;&amp;!skipEnvironment(path.node.leadingComments,opts);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}</span> /**
   * Determine whether the file should be skipped, based on the comments attached to the given node.
   */<span class="fstat-no" title="function not covered" >function maybeSkipFile(path,opts){<span class="fstat-no" title="function not covered" ></span>function _ref97(_id112){<span class="cstat-no" title="statement not covered" ></span>if(!(typeof _id112==='boolean')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "maybeSkipFile" return value violates contract.\n\nExpected:\nbool\n\nGot:\n'+_inspect(_id112));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id112;}<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(path.node.leadingComments&amp;&amp;path.node.leadingComments.length){<span class="cstat-no" title="statement not covered" >if(skipEnvironment(path.node.leadingComments,opts)){<span class="cstat-no" title="statement not covered" >return true;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref97(path.node.leadingComments.some(<span class="fstat-no" title="function not covered" >function(comment){<span class="cstat-no" title="statement not covered" ></span>return PRAGMA_IGNORE_FILE.test(comment.value);}</span>));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}</span> /**
   * Maybe skip the given path if it has a relevant pragma.
   */<span class="fstat-no" title="function not covered" >function maybeSkip(path){<span class="cstat-no" title="statement not covered" ></span>if(!NodePath(path)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.hasBeenTypeChecked){<span class="cstat-no" title="statement not covered" >return true;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.leadingComments&amp;&amp;node.leadingComments.length){<span class="cstat-no" title="statement not covered" >var comment=node.leadingComments[node.leadingComments.length-1];<span class="cstat-no" title="statement not covered" >i</span>f(PRAGMA_IGNORE_STATEMENT.test(comment.value)){<span class="cstat-no" title="statement not covered" >path.skip();<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}</span> /**
   * A function that returns its first argument, useful when filtering.
   */<span class="fstat-no" title="function not covered" >function identity(input){<span class="cstat-no" title="statement not covered" ></span>return input;}<span class="fstat-no" title="function not covered" ></span>function getExpression(node){<span class="fstat-no" title="function not covered" ></span>function _ref100(_id115){<span class="cstat-no" title="statement not covered" ></span>if(!Node(_id115)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "getExpression" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id115));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id115;}<span class="cstat-no" title="statement not covered" ></span>if(!Node(node)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref100(t.isExpressionStatement(node)?node.expression:node);}<span class="fstat-no" title="function not covered" ></span>function expression(input){<span class="fstat-no" title="function not covered" ></span>function _ref101(_id116){<span class="cstat-no" title="statement not covered" ></span>if(!(typeof _id116==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Function "expression" return value violates contract.\n\nExpected:\nFunction\n\nGot:\n'+_inspect(_id116));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _id116;}<span class="cstat-no" title="statement not covered" ></span>if(!(typeof input==='string')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of argument "input" violates contract.\n\nExpected:\nstring\n\nGot:\n'+_inspect(input));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar fn=template(input);<span class="cstat-no" title="statement not covered" >i</span>f(!(typeof fn==='function')){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "fn" violates contract.\n\nExpected:\nFunction\n\nGot:\n'+_inspect(fn));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _ref101(<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var node=fn.apply(undefined,arguments);<span class="cstat-no" title="statement not covered" >i</span>f(!Node(node)){<span class="cstat-no" title="statement not covered" >throw new TypeError('Value of variable "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn getExpression(node);}</span>);}</span>};var _babelGenerator=require('babel-generator');var _babelGenerator2=_interopRequireDefault(_babelGenerator);function _interopRequireDefault(obj){return obj&amp;&amp;obj.__esModule?obj:<span class="branch-1 cbranch-no" title="branch not covered" >{default:obj};</span>}<span class="fstat-no" title="function not covered" >function _toConsumableArray(arr){<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(arr)){<span class="cstat-no" title="statement not covered" >for(var i=0,arr2=Array(arr.length);i&lt;arr.length;i++){<span class="cstat-no" title="statement not covered" >arr2[i]=arr[i];}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn arr2;}</span>else {<span class="cstat-no" title="statement not covered" >return Array.from(arr);}</span>}</span>var Node=function(){<span class="fstat-no" title="function not covered" >function Node(input){<span class="cstat-no" title="statement not covered" ></span>return input!=null&amp;&amp;typeof input.type==='string';}</span>;Object.defineProperty(Node,Symbol.hasInstance,{value:<span class="fstat-no" title="function not covered" >function value(input){<span class="cstat-no" title="statement not covered" ></span>return Node(input);}</span>});return Node;}();var Literal=function(){<span class="fstat-no" title="function not covered" >function Literal(input){<span class="cstat-no" title="statement not covered" ></span>return input!=null&amp;&amp;(input.type==='StringLiteral'||input.type==='BooleanLiteral'||input.type==='NumericLiteral'||input.type==='NullLiteral'||input.type==='RegExpLiteral');}</span>;Object.defineProperty(Literal,Symbol.hasInstance,{value:<span class="fstat-no" title="function not covered" >function value(input){<span class="cstat-no" title="statement not covered" ></span>return Literal(input);}</span>});return Literal;}();var Identifier=function(){<span class="fstat-no" title="function not covered" >function Identifier(input){<span class="cstat-no" title="statement not covered" ></span>return input!=null&amp;&amp;typeof input.type==='string'&amp;&amp;typeof input.name==='string';}</span>;Object.defineProperty(Identifier,Symbol.hasInstance,{value:<span class="fstat-no" title="function not covered" >function value(input){<span class="cstat-no" title="statement not covered" ></span>return Identifier(input);}</span>});return Identifier;}();var QualifiedTypeIdentifier=function(){<span class="fstat-no" title="function not covered" >function QualifiedTypeIdentifier(input){<span class="cstat-no" title="statement not covered" ></span>return input!=null&amp;&amp;Identifier(input.id)&amp;&amp;(Identifier(input.qualification)||QualifiedTypeIdentifier(input.qualification));}</span>;Object.defineProperty(QualifiedTypeIdentifier,Symbol.hasInstance,{value:<span class="fstat-no" title="function not covered" >function value(input){<span class="cstat-no" title="statement not covered" ></span>return QualifiedTypeIdentifier(input);}</span>});return QualifiedTypeIdentifier;}();var TypeAnnotation=function(){<span class="fstat-no" title="function not covered" >function TypeAnnotation(input){<span class="cstat-no" title="statement not covered" ></span>return input!=null&amp;&amp;typeof input.type==='string';}</span>;Object.defineProperty(TypeAnnotation,Symbol.hasInstance,{value:<span class="fstat-no" title="function not covered" >function value(input){<span class="cstat-no" title="statement not covered" ></span>return TypeAnnotation(input);}</span>});return TypeAnnotation;}();var VisitorContext=function(){<span class="fstat-no" title="function not covered" >function VisitorContext(input){<span class="cstat-no" title="statement not covered" ></span>return input!=null&amp;&amp;Identifier(input.inspect);}</span>;Object.defineProperty(VisitorContext,Symbol.hasInstance,{value:<span class="fstat-no" title="function not covered" >function value(input){<span class="cstat-no" title="statement not covered" ></span>return VisitorContext(input);}</span>});return VisitorContext;}();var StringLiteralTypeAnnotation=function(){<span class="fstat-no" title="function not covered" >function StringLiteralTypeAnnotation(input){<span class="cstat-no" title="statement not covered" ></span>return input!=null&amp;&amp;input.type==='StringLiteralTypeAnnotation'&amp;&amp;TypeAnnotation(input);}</span>;Object.defineProperty(StringLiteralTypeAnnotation,Symbol.hasInstance,{value:<span class="fstat-no" title="function not covered" >function value(input){<span class="cstat-no" title="statement not covered" ></span>return StringLiteralTypeAnnotation(input);}</span>});return StringLiteralTypeAnnotation;}();var NumericLiteralTypeAnnotation=function(){<span class="fstat-no" title="function not covered" >function NumericLiteralTypeAnnotation(input){<span class="cstat-no" title="statement not covered" ></span>return input!=null&amp;&amp;input.type==='NumericLiteralTypeAnnotation'&amp;&amp;TypeAnnotation(input);}</span>;Object.defineProperty(NumericLiteralTypeAnnotation,Symbol.hasInstance,{value:<span class="fstat-no" title="function not covered" >function value(input){<span class="cstat-no" title="statement not covered" ></span>return NumericLiteralTypeAnnotation(input);}</span>});return NumericLiteralTypeAnnotation;}();var BooleanLiteralTypeAnnotation=function(){<span class="fstat-no" title="function not covered" >function BooleanLiteralTypeAnnotation(input){<span class="cstat-no" title="statement not covered" ></span>return input!=null&amp;&amp;input.type==='BooleanLiteralTypeAnnotation'&amp;&amp;TypeAnnotation(input);}</span>;Object.defineProperty(BooleanLiteralTypeAnnotation,Symbol.hasInstance,{value:<span class="fstat-no" title="function not covered" >function value(input){<span class="cstat-no" title="statement not covered" ></span>return BooleanLiteralTypeAnnotation(input);}</span>});return BooleanLiteralTypeAnnotation;}();var Scope=function(){<span class="fstat-no" title="function not covered" >function Scope(input){<span class="cstat-no" title="statement not covered" ></span>return input!=null&amp;&amp;(typeof input==='undefined'?'undefined':_typeof(input))==='object';}</span>;Object.defineProperty(Scope,Symbol.hasInstance,{value:<span class="fstat-no" title="function not covered" >function value(input){<span class="cstat-no" title="statement not covered" ></span>return Scope(input);}</span>});return Scope;}();var NodePath=function(){<span class="fstat-no" title="function not covered" >function NodePath(input){<span class="cstat-no" title="statement not covered" ></span>return input!=null&amp;&amp;typeof input.type==='string'&amp;&amp;Node(input.node)&amp;&amp;Scope(input.scope);}</span>;Object.defineProperty(NodePath,Symbol.hasInstance,{value:<span class="fstat-no" title="function not covered" >function value(input){<span class="cstat-no" title="statement not covered" ></span>return NodePath(input);}</span>});return NodePath;}(); /**
 * # Typecheck Transformer
 */<span class="fstat-no" title="function not covered" >function _inspect(input,depth){<span class="cstat-no" title="statement not covered" ></span>var maxDepth=4;<span class="cstat-no" title="statement not covered" >v</span>ar maxKeys=15;<span class="cstat-no" title="statement not covered" >i</span>f(depth===undefined){<span class="cstat-no" title="statement not covered" >depth=0;}<span class="cstat-no" title="statement not covered" ></span>d</span>epth+=1;<span class="cstat-no" title="statement not covered" >i</span>f(input===null){<span class="cstat-no" title="statement not covered" >return 'null';}</span>else <span class="cstat-no" title="statement not covered" >if(input===undefined){<span class="cstat-no" title="statement not covered" >return 'void';}</span>else <span class="cstat-no" title="statement not covered" >if(typeof input==='string'||typeof input==='number'||typeof input==='boolean'){<span class="cstat-no" title="statement not covered" >return typeof input==='undefined'?'undefined':_typeof(input);}</span>else <span class="cstat-no" title="statement not covered" >if(Array.isArray(input)){<span class="cstat-no" title="statement not covered" >if(input.length&gt;0){<span class="cstat-no" title="statement not covered" >var _ret=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>if(depth&gt;maxDepth)<span class="cstat-no" title="statement not covered" >return {v:'[...]'};<span class="cstat-no" title="statement not covered" >v</span></span>ar first=_inspect(input[0],depth);<span class="cstat-no" title="statement not covered" >i</span>f(input.every(<span class="fstat-no" title="function not covered" >function(item){<span class="cstat-no" title="statement not covered" ></span>return _inspect(item,depth)===first;}</span>)){<span class="cstat-no" title="statement not covered" >return {v:first.trim()+'[]'};}</span>else {<span class="cstat-no" title="statement not covered" >return {v:'['+input.slice(0,maxKeys).map(<span class="fstat-no" title="function not covered" >function(item){<span class="cstat-no" title="statement not covered" ></span>return _inspect(item,depth);}</span>).join(', ')+(input.length&gt;=maxKeys?', ...':'')+']'};}</span>}</span>();<span class="cstat-no" title="statement not covered" >i</span>f((typeof _ret==='undefined'?'undefined':_typeof(_ret))==="object")<span class="cstat-no" title="statement not covered" >return _ret.v;}</span></span>else {<span class="cstat-no" title="statement not covered" >return 'Array';}</span>}</span>else {<span class="cstat-no" title="statement not covered" >var keys=Object.keys(input);<span class="cstat-no" title="statement not covered" >i</span>f(!keys.length){<span class="cstat-no" title="statement not covered" >if(input.constructor&amp;&amp;input.constructor.name&amp;&amp;input.constructor.name!=='Object'){<span class="cstat-no" title="statement not covered" >return input.constructor.name;}</span>else {<span class="cstat-no" title="statement not covered" >return 'Object';}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(depth&gt;maxDepth)<span class="cstat-no" title="statement not covered" >return '{...}';<span class="cstat-no" title="statement not covered" >v</span></span>ar indent='  '.repeat(depth-1);<span class="cstat-no" title="statement not covered" >v</span>ar entries=keys.slice(0,maxKeys).map(<span class="fstat-no" title="function not covered" >function(key){<span class="cstat-no" title="statement not covered" ></span>return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key)?key:JSON.stringify(key))+': '+_inspect(input[key],depth)+';';}</span>).join('\n  '+indent);<span class="cstat-no" title="statement not covered" >i</span>f(keys.length&gt;=maxKeys){<span class="cstat-no" title="statement not covered" >entries+='\n  '+indent+'...';}<span class="cstat-no" title="statement not covered" ></span>i</span>f(input.constructor&amp;&amp;input.constructor.name&amp;&amp;input.constructor.name!=='Object'){<span class="cstat-no" title="statement not covered" >return input.constructor.name+' {\n  '+indent+entries+'\n'+indent+'}';}</span>else {<span class="cstat-no" title="statement not covered" >return '{\n  '+indent+entries+'\n'+indent+'}';}</span>}</span>}</span></span></span></span>
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 23:52:58 GMT+0000 (UTC)</div>
</div>
</body>
</html>


<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header low">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-babel-plugin-typecheck">npmtest-babel-plugin-typecheck (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/</span></h1>
    <h2>
        
        Statements: <span class="metric">6.25% <small>(251 / 4019)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">0.18% <small>(6 / 3246)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">1.33% <small>(5 / 375)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">41.75% <small>(81 / 194)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../../../../index.html">All files</a> &#187; node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/</div>
</div>
<div class="body">
<div class="coverage-summary">
<table>
<thead>
<tr>
   <th data-col="file" data-fmt="html" data-html="true" class="file">File</th>
   <th data-col="pic" data-type="number" data-fmt="html" data-html="true" class="pic"></th>
   <th data-col="statements" data-type="number" data-fmt="pct" class="pct">Statements</th>
   <th data-col="statements_raw" data-type="number" data-fmt="html" class="abs"></th>
   <th data-col="branches" data-type="number" data-fmt="pct" class="pct">Branches</th>
   <th data-col="branches_raw" data-type="number" data-fmt="html" class="abs"></th>
   <th data-col="functions" data-type="number" data-fmt="pct" class="pct">Functions</th>
   <th data-col="functions_raw" data-type="number" data-fmt="html" class="abs"></th>
   <th data-col="lines" data-type="number" data-fmt="pct" class="pct">Lines</th>
   <th data-col="lines_raw" data-type="number" data-fmt="html" class="abs"></th>
</tr>
</thead>
<tbody><tr>
	<td class="file low" data-value="index.js"><a href="index.js.html">index.js</a></td>
	<td data-value="6.06" class="pic low"><span class="cover-fill" style="width: 6px;"></span><span class="cover-empty" style="width:94px;"></span></td>
	<td data-value="6.06" class="pct low">6.06%</td>
	<td data-value="1914" class="abs low">(116&nbsp;/&nbsp;1914)</td>
	<td data-value="0.19" class="pct low">0.19%</td>
	<td data-value="1551" class="abs low">(3&nbsp;/&nbsp;1551)</td>
	<td data-value="1.14" class="pct low">1.14%</td>
	<td data-value="175" class="abs low">(2&nbsp;/&nbsp;175)</td>
	<td data-value="86.49" class="pct high">86.49%</td>
	<td data-value="37" class="abs high">(32&nbsp;/&nbsp;37)</td>
	</tr>

<tr>
	<td class="file low" data-value="inferers.js"><a href="inferers.js.html">inferers.js</a></td>
	<td data-value="12.68" class="pic low"><span class="cover-fill" style="width: 12px;"></span><span class="cover-empty" style="width:88px;"></span></td>
	<td data-value="12.68" class="pct low">12.68%</td>
	<td data-value="71" class="abs low">(9&nbsp;/&nbsp;71)</td>
	<td data-value="0" class="pct low">0%</td>
	<td data-value="26" class="abs low">(0&nbsp;/&nbsp;26)</td>
	<td data-value="9.09" class="pct low">9.09%</td>
	<td data-value="11" class="abs low">(1&nbsp;/&nbsp;11)</td>
	<td data-value="14.89" class="pct low">14.89%</td>
	<td data-value="47" class="abs low">(7&nbsp;/&nbsp;47)</td>
	</tr>

<tr>
	<td class="file low" data-value="old_index.js"><a href="old_index.js.html">old_index.js</a></td>
	<td data-value="5.92" class="pic low"><span class="cover-fill" style="width: 5px;"></span><span class="cover-empty" style="width:95px;"></span></td>
	<td data-value="5.92" class="pct low">5.92%</td>
	<td data-value="1961" class="abs low">(116&nbsp;/&nbsp;1961)</td>
	<td data-value="0.19" class="pct low">0.19%</td>
	<td data-value="1584" class="abs low">(3&nbsp;/&nbsp;1584)</td>
	<td data-value="1.16" class="pct low">1.16%</td>
	<td data-value="172" class="abs low">(2&nbsp;/&nbsp;172)</td>
	<td data-value="86.49" class="pct high">86.49%</td>
	<td data-value="37" class="abs high">(32&nbsp;/&nbsp;37)</td>
	</tr>

<tr>
	<td class="file low" data-value="type-checks.js"><a href="type-checks.js.html">type-checks.js</a></td>
	<td data-value="13.7" class="pic low"><span class="cover-fill" style="width: 13px;"></span><span class="cover-empty" style="width:87px;"></span></td>
	<td data-value="13.7" class="pct low">13.7%</td>
	<td data-value="73" class="abs low">(10&nbsp;/&nbsp;73)</td>
	<td data-value="0" class="pct low">0%</td>
	<td data-value="85" class="abs low">(0&nbsp;/&nbsp;85)</td>
	<td data-value="0" class="pct low">0%</td>
	<td data-value="17" class="abs low">(0&nbsp;/&nbsp;17)</td>
	<td data-value="13.7" class="pct low">13.7%</td>
	<td data-value="73" class="abs low">(10&nbsp;/&nbsp;73)</td>
	</tr>

<tr>
	<td class="file high" data-value="types.js"><a href="types.js.html">types.js</a></td>
	<td data-value="100" class="pic high"><span class="cover-fill cover-full" style="width: 100px;"></span><span class="cover-empty" style="width:0px;"></span></td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="0" class="abs high">(0&nbsp;/&nbsp;0)</td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="0" class="abs high">(0&nbsp;/&nbsp;0)</td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="0" class="abs high">(0&nbsp;/&nbsp;0)</td>
	<td data-value="100" class="pct high">100%</td>
	<td data-value="0" class="abs high">(0&nbsp;/&nbsp;0)</td>
	</tr>

</tbody>
</table>
</div></div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 23:52:58 GMT+0000 (UTC)</div>
</div>
</body>
</html>


<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/index.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header low">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-babel-plugin-typecheck">npmtest-babel-plugin-typecheck (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/index.js</span></h1>
    <h2>
        
        Statements: <span class="metric">6.06% <small>(116 / 1914)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">0.19% <small>(3 / 1551)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">1.14% <small>(2 / 175)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">86.49% <small>(32 / 37)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../../../../index.html">All files</a> &#187; <a href="index.html">node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/</a> &#187; index.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77</td><td class="line-coverage"><span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _slicedToArray=function(){<span class="fstat-no" title="function not covered" >function sliceIterator(arr,i){<span class="cstat-no" title="statement not covered" ></span>var _arr=[];<span class="cstat-no" title="statement not covered" >v</span>ar _n=true;<span class="cstat-no" title="statement not covered" >v</span>ar _d=false;<span class="cstat-no" title="statement not covered" >v</span>ar _e=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){<span class="cstat-no" title="statement not covered" >_arr.push(_s.value);<span class="cstat-no" title="statement not covered" >i</span>f(i&amp;&amp;_arr.length===i)<span class="cstat-no" title="statement not covered" >break;}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_d=true;<span class="cstat-no" title="statement not covered" >_</span>e=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_n&amp;&amp;_i["return"])<span class="cstat-no" title="statement not covered" >_i["return"]();}</span></span>finally {<span class="cstat-no" title="statement not covered" >if(_d)<span class="cstat-no" title="statement not covered" >throw _e;}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _arr;}</span>return <span class="fstat-no" title="function not covered" >function(arr,i){<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(arr)){<span class="cstat-no" title="statement not covered" >return arr;}</span>else <span class="cstat-no" title="statement not covered" >if(Symbol.iterator in Object(arr)){<span class="cstat-no" title="statement not covered" >return sliceIterator(arr,i);}</span>else {<span class="cstat-no" title="statement not covered" >throw new TypeError("Invalid attempt to destructure non-iterable instance");}</span>}</span></span>;}(); /**
 * # Typecheck Transformer
 */exports.default=<span class="fstat-no" title="function not covered" >function(_ref){<span class="cstat-no" title="statement not covered" ></span>var t=_ref.types;<span class="cstat-no" title="statement not covered" >v</span>ar template=_ref.template; </span>/**
   * Binary Operators that can only produce boolean results.
   */<span class="cstat-no" title="statement not covered" >var BOOLEAN_BINARY_OPERATORS=['==','===','&gt;=','&lt;=','&gt;','&lt;','instanceof'];<span class="cstat-no" title="statement not covered" >v</span>ar checks=createChecks();<span class="cstat-no" title="statement not covered" >v</span>ar staticChecks=createStaticChecks();<span class="cstat-no" title="statement not covered" >v</span>ar checkIsArray=expression('Array.isArray(input)');<span class="cstat-no" title="statement not covered" >v</span>ar checkIsMap=expression('input instanceof Map');<span class="cstat-no" title="statement not covered" >v</span>ar checkIsSet=expression('input instanceof Set');<span class="cstat-no" title="statement not covered" >v</span>ar checkIsClass=expression('typeof input === \'function\' &amp;&amp; input.prototype &amp;&amp; input.prototype.constructor === input');<span class="cstat-no" title="statement not covered" >v</span>ar checkIsGenerator=expression('typeof input === \'function\' &amp;&amp; input.generator');<span class="cstat-no" title="statement not covered" >v</span>ar checkIsIterable=expression('input &amp;&amp; (typeof input[Symbol.iterator] === \'function\' || Array.isArray(input))');<span class="cstat-no" title="statement not covered" >v</span>ar checkIsObject=expression('input != null &amp;&amp; typeof input === \'object\'');<span class="cstat-no" title="statement not covered" >v</span>ar checkNotNull=expression('input != null');<span class="cstat-no" title="statement not covered" >v</span>ar checkEquals=expression('input === expected');<span class="cstat-no" title="statement not covered" >v</span>ar declareTypeChecker=template('\n    const id = (function () {\n      function id (input) {\n        return check;\n      };\n      Object.defineProperty(id, Symbol.hasInstance, {\n        value: function (input) {\n          return id(input);\n        }\n      });\n      return id;\n    })();\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar guard=template('\n    if (!check) {\n      throw new TypeError(message);\n    }\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar thrower=template('\n    if (check) {\n      ret;\n    }\n    else {\n      throw new TypeError(message);\n    }\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar guardInline=expression('\n    (id =&gt; {\n      if (!check) {\n        throw new TypeError(message);\n      }\n      return id;\n    })(input)\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar guardFn=expression('\n    function name (id) {\n      if (!check) {\n        throw new TypeError(message);\n      }\n      return id;\n    }\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar readableName=expression('\n    inspect(input)\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar checkMapKeys=expression('\n    input instanceof Map &amp;&amp; Array.from(input.keys()).every(key =&gt; keyCheck)\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar checkMapValues=expression('\n    input instanceof Map &amp;&amp; Array.from(input.values()).every(value =&gt; valueCheck)\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar checkMapEntries=expression('\n    input instanceof Map &amp;&amp; Array.from(input).every(([key, value]) =&gt; keyCheck &amp;&amp; valueCheck)\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar checkSetEntries=expression('\n    input instanceof Set &amp;&amp; Array.from(input).every(value =&gt; valueCheck)\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar checkObjectIndexers=expression('\n    Object.keys(input).every(key =&gt; {\n      const value = input[key];\n      if (~fixedKeys.indexOf(key)) {\n        return true;\n      }\n      else {\n        return check;\n      }\n    });\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar checkObjectIndexersNoFixed=expression('\n    Object.keys(input).every(key =&gt; {\n      const value = input[key];\n      return check;\n    });\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar propType=expression('\n    (function(props, name, component) {\n      var prop = props[name];\n      if(!check) {\n        return new Error(\n          "Invalid prop `" + name + "` supplied to `" + component\n          + "`.\\n\\nExpected:\\n" + expected + "\\n\\nGot:\\n" + got + "\\n\\n"\n        );\n      }\n    })\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar PRAGMA_IGNORE_STATEMENT=/typecheck:\s*ignore\s+statement/i;<span class="cstat-no" title="statement not covered" >v</span>ar PRAGMA_IGNORE_FILE=/typecheck:\s*ignore\s+file/i;<span class="fstat-no" title="function not covered" >f</span>unction skipEnvironment(comments,opts){<span class="cstat-no" title="statement not covered" ></span>if(!opts.only){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar envs=pragmaEnvironments(comments);<span class="cstat-no" title="statement not covered" >r</span>eturn !opts.only.some(<span class="fstat-no" title="function not covered" >function(env){<span class="cstat-no" title="statement not covered" ></span>return envs[env];}</span>);}<span class="fstat-no" title="function not covered" ></span>function pragmaEnvironments(comments){<span class="cstat-no" title="statement not covered" ></span>var pragma=/@typecheck:\s*(.+)/;<span class="cstat-no" title="statement not covered" >v</span>ar environments={};<span class="cstat-no" title="statement not covered" >c</span>omments.forEach(<span class="fstat-no" title="function not covered" >function(comment){<span class="cstat-no" title="statement not covered" ></span>var m=comment.value.match(pragma);<span class="cstat-no" title="statement not covered" >i</span>f(m){<span class="cstat-no" title="statement not covered" >m[1].split(',').forEach(<span class="fstat-no" title="function not covered" >function(env){<span class="cstat-no" title="statement not covered" ></span>return environments[env.trim()]=true;}</span>);}</span>}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn environments;}<span class="cstat-no" title="statement not covered" ></span>var visitors={Statement:<span class="fstat-no" title="function not covered" >function Statement(path){<span class="cstat-no" title="statement not covered" ></span>maybeSkip(path);}</span>,TypeAlias:<span class="fstat-no" title="function not covered" >function TypeAlias(path){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.replaceWith(createTypeAliasChecks(path));}</span>,InterfaceDeclaration:<span class="fstat-no" title="function not covered" >function InterfaceDeclaration(path){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.replaceWith(createInterfaceChecks(path));}</span>,ExportNamedDeclaration:<span class="fstat-no" title="function not covered" >function ExportNamedDeclaration(path){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >i</span>f(node.declaration&amp;&amp;node.declaration.type==='TypeAlias'){<span class="cstat-no" title="statement not covered" >var declaration=path.get('declaration');<span class="cstat-no" title="statement not covered" >d</span>eclaration.replaceWith(createTypeAliasChecks(declaration));<span class="cstat-no" title="statement not covered" >n</span>ode.exportKind='value';}</span>}</span>,ImportDeclaration:<span class="fstat-no" title="function not covered" >function ImportDeclaration(path){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(path.node.importKind!=='type'){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _path$get$map$reduce=path.get('specifiers').map(<span class="fstat-no" title="function not covered" >function(specifier){<span class="cstat-no" title="statement not covered" ></span>var local=specifier.get('local');<span class="cstat-no" title="statement not covered" >v</span>ar tmpId=path.scope.generateUidIdentifierBasedOnNode(local.node);<span class="cstat-no" title="statement not covered" >v</span>ar replacement=t.importSpecifier(tmpId,specifier.node.imported);<span class="cstat-no" title="statement not covered" >v</span>ar id=t.identifier(local.node.name);<span class="cstat-no" title="statement not covered" >i</span>d.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >v</span>ar declarator=t.variableDeclarator(id,tmpId);<span class="cstat-no" title="statement not covered" >d</span>eclarator.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >r</span>eturn [declarator,replacement];}</span>).reduce(<span class="fstat-no" title="function not covered" >function(_ref2,_ref3){<span class="cstat-no" title="statement not covered" ></span>var _ref5=_slicedToArray(_ref2,2);<span class="cstat-no" title="statement not covered" >v</span>ar declarators=_ref5[0];<span class="cstat-no" title="statement not covered" >v</span>ar specifiers=_ref5[1];<span class="cstat-no" title="statement not covered" >v</span>ar _ref4=_slicedToArray(_ref3,2);<span class="cstat-no" title="statement not covered" >v</span>ar declarator=_ref4[0];<span class="cstat-no" title="statement not covered" >v</span>ar specifier=_ref4[1];<span class="cstat-no" title="statement not covered" >d</span>eclarators.push(declarator);<span class="cstat-no" title="statement not covered" >s</span>pecifiers.push(specifier);<span class="cstat-no" title="statement not covered" >r</span>eturn [declarators,specifiers];}</span>,[[],[]]);<span class="cstat-no" title="statement not covered" >v</span>ar _path$get$map$reduce2=_slicedToArray(_path$get$map$reduce,2);<span class="cstat-no" title="statement not covered" >v</span>ar declarators=_path$get$map$reduce2[0];<span class="cstat-no" title="statement not covered" >v</span>ar specifiers=_path$get$map$reduce2[1];<span class="cstat-no" title="statement not covered" >v</span>ar declaration=t.variableDeclaration('var',declarators);<span class="cstat-no" title="statement not covered" >d</span>eclaration.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >p</span>ath.replaceWithMultiple([t.importDeclaration(specifiers,path.node.source),declaration]);}</span>,ArrowFunctionExpression:<span class="fstat-no" title="function not covered" >function ArrowFunctionExpression(path){</span> // Look for destructuring args with annotations.</span>
<span class="cstat-no" title="statement not covered" >var params=path.get('params');<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator=params[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){<span class="cstat-no" title="statement not covered" >var param=_step.value;<span class="cstat-no" title="statement not covered" >i</span>f(param.isObjectPattern()&amp;&amp;param.node.typeAnnotation){<span class="cstat-no" title="statement not covered" >var _path$get=path.get('body');<span class="cstat-no" title="statement not covered" >v</span>ar _scope=_path$get.scope;<span class="cstat-no" title="statement not covered" >v</span>ar _id=_scope.generateUidIdentifier('arg'+param.key);<span class="cstat-no" title="statement not covered" >v</span>ar pattern=param.node;<span class="cstat-no" title="statement not covered" >p</span>aram.replaceWith(_id);<span class="cstat-no" title="statement not covered" >i</span>f(path.node.expression){<span class="cstat-no" title="statement not covered" >var block=t.blockStatement([t.variableDeclaration('var',[t.variableDeclarator(pattern,_id)]),t.returnStatement(path.get('body').node)]);<span class="cstat-no" title="statement not covered" >p</span>ath.node.body=block;<span class="cstat-no" title="statement not covered" >p</span>ath.node.expression=false;}</span>else {<span class="cstat-no" title="statement not covered" >path.get('body.body')[0].insertBefore(t.variableDeclaration('var',[t.variableDeclarator(pattern,_id)]));}</span>}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion&amp;&amp;_iterator.return){<span class="cstat-no" title="statement not covered" >_iterator.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError){<span class="cstat-no" title="statement not covered" >throw _iteratorError;}</span>}</span>}</span>}</span>,Function:{enter:<span class="fstat-no" title="function not covered" >function enter(path,context){<span class="cstat-no" title="statement not covered" ></span>var _node$body$body;<span class="cstat-no" title="statement not covered" >i</span>f(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar paramChecks=collectParamChecks(path,context);<span class="cstat-no" title="statement not covered" >i</span>f(node.type==="ArrowFunctionExpression"&amp;&amp;node.expression){<span class="cstat-no" title="statement not covered" >node.expression=false;<span class="cstat-no" title="statement not covered" >n</span>ode.body=t.blockStatement([t.returnStatement(node.body)]);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.returnType){<span class="cstat-no" title="statement not covered" >createFunctionReturnGuard(path,context);<span class="cstat-no" title="statement not covered" >c</span>reateFunctionYieldGuards(path,context);}<span class="cstat-no" title="statement not covered" ></span>(</span>_node$body$body=node.body.body).unshift.apply(_node$body$body,_toConsumableArray(paramChecks));<span class="cstat-no" title="statement not covered" >n</span>ode.savedTypeAnnotation=node.returnType;<span class="cstat-no" title="statement not covered" >n</span>ode.returnCount=0;<span class="cstat-no" title="statement not covered" >n</span>ode.yieldCount=0;}</span>,exit:<span class="fstat-no" title="function not covered" >function exit(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar isVoid=node.savedTypeAnnotation?maybeNullableAnnotation(node.savedTypeAnnotation):null;<span class="cstat-no" title="statement not covered" >i</span>f(!node.returnCount&amp;&amp;isVoid===false){<span class="cstat-no" title="statement not covered" >var annotation=node.savedTypeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.generator&amp;&amp;isGeneratorAnnotation(annotation)&amp;&amp;annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters.params[1];}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow path.buildCodeFrameError(buildErrorMessage('Function '+(node.id?'"'+node.id.name+'" ':'')+'did not return a value.',annotation));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.nextGuardCount){<span class="cstat-no" title="statement not covered" >path.get('body').get('body')[0].insertBefore(node.nextGuard);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.yieldGuardCount){<span class="cstat-no" title="statement not covered" >path.get('body').get('body')[0].insertBefore(node.yieldGuard);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.returnGuardCount){<span class="cstat-no" title="statement not covered" >path.get('body').get('body')[0].insertBefore(node.returnGuard);}</span>}</span>},YieldExpression:<span class="fstat-no" title="function not covered" >function YieldExpression(path,context){<span class="cstat-no" title="statement not covered" ></span>var fn=path.getFunctionParent();<span class="cstat-no" title="statement not covered" >i</span>f(!fn){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>f</span>n.node.yieldCount++;<span class="cstat-no" title="statement not covered" >i</span>f(!isGeneratorAnnotation(fn.node.returnType)||maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar parent=path.parent;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=fn.node.returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='NullableTypeAnnotation'||annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!annotation.typeParameters||annotation.typeParameters.params.length===0){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar yieldType=annotation.typeParameters.params[0];<span class="cstat-no" title="statement not covered" >v</span>ar nextType=annotation.typeParameters.params[2];<span class="cstat-no" title="statement not covered" >v</span>ar ok=staticCheckAnnotation(path.get("argument"),yieldType);<span class="cstat-no" title="statement not covered" >i</span>f(ok===true&amp;&amp;!nextType){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'"'+fn.node.id.name+'" ':'')+'yielded an invalid type.',yieldType,getAnnotation(path.get('argument'))));}<span class="cstat-no" title="statement not covered" ></span>f</span></span>n.node.yieldGuardCount++;<span class="cstat-no" title="statement not covered" >i</span>f(fn.node.yieldGuard){<span class="cstat-no" title="statement not covered" >var _yielder=t.yieldExpression(t.callExpression(fn.node.yieldGuardName,[node.argument||t.identifier('undefined')]));<span class="cstat-no" title="statement not covered" >_</span>yielder.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >i</span>f(fn.node.nextGuard){<span class="cstat-no" title="statement not covered" >fn.node.nextGuardCount++;<span class="cstat-no" title="statement not covered" >p</span>ath.replaceWith(t.callExpression(fn.node.nextGuardName,[_yielder]));}</span>else {<span class="cstat-no" title="statement not covered" >path.replaceWith(_yielder);}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(fn.node.nextGuard){<span class="cstat-no" title="statement not covered" >fn.node.nextGuardCount++;<span class="cstat-no" title="statement not covered" >p</span>ath.replaceWith(t.callExpression(fn.node.nextGuardName,[yielder]));}</span>}</span></span>,ReturnStatement:<span class="fstat-no" title="function not covered" >function ReturnStatement(path,context){<span class="cstat-no" title="statement not covered" ></span>var fn=path.getFunctionParent();<span class="cstat-no" title="statement not covered" >i</span>f(!fn){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>f</span>n.node.returnCount++;<span class="cstat-no" title="statement not covered" >i</span>f(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar parent=path.parent;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar _fn$node=fn.node;<span class="cstat-no" title="statement not covered" >v</span>ar returnType=_fn$node.returnType;<span class="cstat-no" title="statement not covered" >v</span>ar returnGuardName=_fn$node.returnGuardName;<span class="cstat-no" title="statement not covered" >i</span>f(!returnType||!returnGuardName){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!node.argument){<span class="cstat-no" title="statement not covered" >if(maybeNullableAnnotation(returnType)===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'"'+fn.node.id.name+'" ':'')+'did not return a value.',returnType));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar annotation=returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isGeneratorAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1?annotation.typeParameters.params[1]:t.anyTypeAnnotation();}</span>else <span class="cstat-no" title="statement not covered" >if(node.async&amp;&amp;annotation.type==='GenericTypeAnnotation'&amp;&amp;annotation.id.name==='Promise'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters&amp;&amp;annotation.typeParameters[0]||t.anyTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar ok=staticCheckAnnotation(path.get("argument"),annotation);<span class="cstat-no" title="statement not covered" >i</span>f(ok===true){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'"'+fn.node.id.name+'" ':'')+'returned an invalid type.',annotation,getAnnotation(path.get('argument'))));}<span class="cstat-no" title="statement not covered" ></span>f</span></span>n.node.returnGuardCount++;<span class="cstat-no" title="statement not covered" >v</span>ar returner=t.returnStatement(t.callExpression(fn.node.returnGuardName,[node.argument]));<span class="cstat-no" title="statement not covered" >r</span>eturner.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >p</span>ath.replaceWith(returner);}</span>,VariableDeclaration:<span class="fstat-no" title="function not covered" >function VariableDeclaration(path,context){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar collected=[];<span class="cstat-no" title="statement not covered" >v</span>ar declarations=path.get("declarations");<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;node.declarations.length;i++){<span class="cstat-no" title="statement not covered" >var declaration=node.declarations[i];<span class="cstat-no" title="statement not covered" >v</span>ar _id2=declaration.id;<span class="cstat-no" title="statement not covered" >v</span>ar init=declaration.init;<span class="cstat-no" title="statement not covered" >i</span>f(!_id2.typeAnnotation||_id2.hasBeenTypeChecked){<span class="cstat-no" title="statement not covered" >continue;}<span class="cstat-no" title="statement not covered" ></span>_</span>id2.savedTypeAnnotation=_id2.typeAnnotation;<span class="cstat-no" title="statement not covered" >_</span>id2.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >v</span>ar ok=staticCheckAnnotation(declarations[i],_id2.typeAnnotation);<span class="cstat-no" title="statement not covered" >i</span>f(ok===true){<span class="cstat-no" title="statement not covered" >continue;}</span>else <span class="cstat-no" title="statement not covered" >if(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid assignment value for "'+_id2.name+'".',_id2.typeAnnotation,getAnnotation(declarations[i])));}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar check=checkAnnotation(_id2,_id2.typeAnnotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >collected.push(guard({check:check,message:varTypeErrorMessage(_id2,context)}));}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(collected.length&gt;0){<span class="cstat-no" title="statement not covered" >var _check=collected.reduce(<span class="fstat-no" title="function not covered" >function(check,branch){<span class="cstat-no" title="statement not covered" ></span>branch.alternate=check;<span class="cstat-no" title="statement not covered" >r</span>eturn branch;}</span>);<span class="cstat-no" title="statement not covered" >i</span>f(path.parent.type==='Program'||path.parent.type==='BlockStatement'){<span class="cstat-no" title="statement not covered" >path.insertAfter(_check);}</span>else <span class="cstat-no" title="statement not covered" >if(path.parentPath.isForXStatement()||path.parentPath.isForStatement()||path.parentPath.isForInStatement()){<span class="cstat-no" title="statement not covered" >var body=path.parentPath.get('body');<span class="cstat-no" title="statement not covered" >i</span>f(body.type!=='BlockStatement'){<span class="cstat-no" title="statement not covered" >var block=t.blockStatement([body.node]);<span class="cstat-no" title="statement not covered" >b</span>ody.replaceWith(block);<span class="cstat-no" title="statement not covered" >b</span>ody=path.parentPath.get('body');}<span class="cstat-no" title="statement not covered" ></span>v</span>ar children=body.get('body');<span class="cstat-no" title="statement not covered" >i</span>f(children.length===0){<span class="cstat-no" title="statement not covered" >body.replaceWith(_check);}</span>else {<span class="cstat-no" title="statement not covered" >children[0].insertBefore(_check);}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(path.parent.type==='ExportNamedDeclaration'||path.parent.type==='ExportDefaultDeclaration'||path.parent.type==='ExportAllDeclaration'){<span class="cstat-no" title="statement not covered" >path.parentPath.insertAfter(_check);}</span>else {<span class="cstat-no" title="statement not covered" >path.replaceWith(t.blockStatement([node,_check]));}</span>}</span></span></span>}</span>,AssignmentExpression:<span class="fstat-no" title="function not covered" >function AssignmentExpression(path,context){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar left=path.get('left');<span class="cstat-no" title="statement not covered" >v</span>ar annotation=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(node.hasBeenTypeChecked||node.left.hasBeenTypeChecked){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(left.isMemberExpression()){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(left);}</span>else <span class="cstat-no" title="statement not covered" >if(t.isIdentifier(node.left)){<span class="cstat-no" title="statement not covered" >var binding=scope.getBinding(node.left.name);<span class="cstat-no" title="statement not covered" >i</span>f(!binding){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(binding.path.type!=='VariableDeclarator'){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>a</span></span>nnotation=left.getTypeAnnotation();<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='AnyTypeAnnotation'){<span class="cstat-no" title="statement not covered" >var item=binding.path.get('id');<span class="cstat-no" title="statement not covered" >a</span>nnotation=item.node.savedTypeAnnotation||item.getTypeAnnotation();}</span>}</span>else {<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>n</span></span></span>ode.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >n</span>ode.left.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.left;<span class="cstat-no" title="statement not covered" >v</span>ar right=path.get('right');<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='AnyTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar ok=staticCheckAnnotation(right,annotation);<span class="cstat-no" title="statement not covered" >i</span>f(ok===true){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid assignment value for "'+humanReadableType(id)+'".',annotation,getAnnotation(right)));}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar check=checkAnnotation(id,annotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!id.typeAnnotation){<span class="cstat-no" title="statement not covered" >id.typeAnnotation=annotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>d.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >var parent=path.getStatementParent();<span class="cstat-no" title="statement not covered" >p</span>arent.insertAfter(guard({check:check,message:varTypeErrorMessage(id,context)}));}</span>}</span>,TypeCastExpression:<span class="fstat-no" title="function not covered" >function TypeCastExpression(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar target=void 0;<span class="cstat-no" title="statement not covered" >s</span>witch(node.expression.type){case 'Identifier':<span class="cstat-no" title="statement not covered" >target=node.expression;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 'AssignmentExpression':<span class="cstat-no" title="statement not covered" >target=node.expression.left;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault: // unsupported.</span>
<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>var id=path.scope.getBindingIdentifier(target.name);<span class="cstat-no" title="statement not covered" >i</span>f(!id){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>d.savedTypeAnnotation=path.getTypeAnnotation();}</span>,ForOfStatement:<span class="fstat-no" title="function not covered" >function ForOfStatement(path,context){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar left=path.get('left');<span class="cstat-no" title="statement not covered" >v</span>ar right=path.get('right');<span class="cstat-no" title="statement not covered" >v</span>ar rightAnnotation=getAnnotation(right);<span class="cstat-no" title="statement not covered" >v</span>ar leftAnnotation=left.isVariableDeclaration()?getAnnotation(left.get('declarations')[0].get('id')):getAnnotation(left);<span class="cstat-no" title="statement not covered" >i</span>f(rightAnnotation.type!=='VoidTypeAnnotation'&amp;&amp;rightAnnotation.type!=='NullLiteralTypeAnnotation'){<span class="cstat-no" title="statement not covered" >var ok=maybeIterableAnnotation(rightAnnotation);<span class="cstat-no" title="statement not covered" >i</span>f(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError('Cannot iterate '+humanReadableType(rightAnnotation)+'.');}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar id=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(right.isIdentifier()){<span class="cstat-no" title="statement not covered" >id=right.node;}</span>else {<span class="cstat-no" title="statement not covered" >id=path.scope.generateUidIdentifierBasedOnNode(right.node);<span class="cstat-no" title="statement not covered" >p</span>ath.scope.push({id:id});<span class="cstat-no" title="statement not covered" >v</span>ar replacement=t.expressionStatement(t.assignmentExpression('=',id,right.node));<span class="cstat-no" title="statement not covered" >p</span>ath.insertBefore(replacement);<span class="cstat-no" title="statement not covered" >r</span>ight.replaceWith(id);}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.insertBefore(guard({check:checks.iterable({input:id}),message:t.binaryExpression('+',t.stringLiteral('Expected '+humanReadableType(right.node)+' to be iterable, got '),readableName({inspect:context.inspect,input:id}))}));<span class="cstat-no" title="statement not covered" >i</span>f(rightAnnotation.type!=='GenericTypeAnnotation'||rightAnnotation.id.name!=='Iterable'||!rightAnnotation.typeParameters||!rightAnnotation.typeParameters.params.length){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar annotation=rightAnnotation.typeParameters.params[0];<span class="cstat-no" title="statement not covered" >i</span>f(compareAnnotations(annotation,leftAnnotation)===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid iterator type.',annotation,leftAnnotation));}</span>}</span>,ClassDeclaration:<span class="fstat-no" title="function not covered" >function ClassDeclaration(path,context){</span> // Convert React props to propTypes
<span class="cstat-no" title="statement not covered" >if(!path.node.superClass){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar props=void 0;<span class="cstat-no" title="statement not covered" >v</span>ar hasRenderMethod=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion2=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError2=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError2=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator2=path.get('body.body')[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=true){<span class="cstat-no" title="statement not covered" >var memberPath=_step2.value;<span class="cstat-no" title="statement not covered" >v</span>ar classMember=memberPath.node;<span class="cstat-no" title="statement not covered" >i</span>f(t.isClassProperty(classMember)){<span class="cstat-no" title="statement not covered" >if(classMember.key.name==='propTypes'&amp;&amp;classMember.static){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(classMember.key.name==='props'&amp;&amp;!classMember.static){<span class="cstat-no" title="statement not covered" >props=memberPath;}</span>}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(t.isClassMethod(classMember)&amp;&amp;classMember.key.name==='render'){<span class="cstat-no" title="statement not covered" >hasRenderMethod=true;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError2=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError2=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion2&amp;&amp;_iterator2.return){<span class="cstat-no" title="statement not covered" >_iterator2.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError2){<span class="cstat-no" title="statement not covered" >throw _iteratorError2;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar type=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(path.node.superTypeParameters){<span class="cstat-no" title="statement not covered" >if(path.node.superTypeParameters.params.length!==3){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>t</span>ype=path.node.superTypeParameters.params[1];}<span class="cstat-no" title="statement not covered" ></span>i</span>f(props){<span class="cstat-no" title="statement not covered" >type=props.node.typeAnnotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!type||!hasRenderMethod){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t.isGenericTypeAnnotation(type)){<span class="cstat-no" title="statement not covered" >var binding=path.scope.getBinding(type.id.name);<span class="cstat-no" title="statement not covered" >t</span>ype=getAnnotation(binding.path);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!t.isObjectTypeAnnotation(type)){<span class="cstat-no" title="statement not covered" >return;}</span> </span>// Now we have a class that has a superclass, an instance method called 'render'
// and some property type annotations. We can be reasonably sure it's a React component.
<span class="cstat-no" title="statement not covered" >var propTypes=t.objectExpression(type.properties.map(<span class="fstat-no" title="function not covered" >function(prop){<span class="cstat-no" title="statement not covered" ></span>return t.objectProperty(t.identifier(prop.key.name),generatePropType(prop.value,path.scope,context));}</span>));<span class="cstat-no" title="statement not covered" >i</span>f(path.node.decorators){<span class="cstat-no" title="statement not covered" >var property=t.classProperty(t.identifier('propTypes'),propTypes);<span class="cstat-no" title="statement not covered" >p</span>roperty.static=true;<span class="cstat-no" title="statement not covered" >p</span>rops.insertAfter(property);}</span>else {<span class="cstat-no" title="statement not covered" >var root=path.parentPath.isExportDeclaration()?path.parentPath:path;<span class="cstat-no" title="statement not covered" >r</span>oot.insertAfter(t.expressionStatement(t.assignmentExpression("=",t.memberExpression(path.node.id,t.identifier("propTypes")),propTypes)));}</span>}</span>}; /**
   * Collect all the type declarations in the given path and add references to them for retreival later.
   */<span class="fstat-no" title="function not covered" >function collectTypes(path){<span class="cstat-no" title="statement not covered" ></span>path.traverse({InterfaceDeclaration:<span class="fstat-no" title="function not covered" >function InterfaceDeclaration(path){<span class="cstat-no" title="statement not covered" ></span>path.scope.setData('typechecker:'+path.node.id.name,path);}</span>,TypeAlias:<span class="fstat-no" title="function not covered" >function TypeAlias(path){<span class="cstat-no" title="statement not covered" ></span>path.scope.setData('typechecker:'+path.node.id.name,path);}</span>,ImportDeclaration:<span class="fstat-no" title="function not covered" >function ImportDeclaration(path){<span class="cstat-no" title="statement not covered" ></span>if(path.node.importKind!=='type'){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.get('specifiers').forEach(<span class="fstat-no" title="function not covered" >function(specifier){<span class="cstat-no" title="statement not covered" ></span>var local=specifier.get('local');<span class="cstat-no" title="statement not covered" >i</span>f(local.isIdentifier()){<span class="cstat-no" title="statement not covered" >path.scope.setData('typechecker:'+local.node.name,specifier);}</span>else {<span class="cstat-no" title="statement not covered" >path.scope.setData('typechecker:'+local.node.id.name,specifier);}</span>}</span>);}</span>,"Function|Class":<span class="fstat-no" title="function not covered" >function FunctionClass(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.typeParameters&amp;&amp;node.typeParameters.params){<span class="cstat-no" title="statement not covered" >path.get('typeParameters').get('params').forEach(<span class="fstat-no" title="function not covered" >function(typeParam){<span class="cstat-no" title="statement not covered" ></span>path.get('body').scope.setData('typeparam:'+typeParam.node.name,typeParam);}</span>);}</span>}</span>});}<span class="cstat-no" title="statement not covered" ></span>return {visitor:{Program:<span class="fstat-no" title="function not covered" >function Program(path,_ref6){<span class="cstat-no" title="statement not covered" ></span>var opts=_ref6.opts;<span class="cstat-no" title="statement not covered" >i</span>f(opts&amp;&amp;opts.disable&amp;&amp;opts.disable[process.env.NODE_ENV]){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checkFile=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion3=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError3=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError3=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator3=path.get('body')[Symbol.iterator](),_step3;!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=true){<span class="cstat-no" title="statement not covered" >var _child=_step3.value;<span class="cstat-no" title="statement not covered" >i</span>f(mustCheckFile(_child,opts)){<span class="cstat-no" title="statement not covered" >checkFile=true;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError3=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError3=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion3&amp;&amp;_iterator3.return){<span class="cstat-no" title="statement not covered" >_iterator3.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError3){<span class="cstat-no" title="statement not covered" >throw _iteratorError3;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!checkFile){<span class="cstat-no" title="statement not covered" >var _iteratorNormalCompletion4=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError4=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError4=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator4=path.get('body')[Symbol.iterator](),_step4;!(_iteratorNormalCompletion4=(_step4=_iterator4.next()).done);_iteratorNormalCompletion4=true){<span class="cstat-no" title="statement not covered" >var child=_step4.value;<span class="cstat-no" title="statement not covered" >i</span>f(maybeSkipFile(child,opts)){<span class="cstat-no" title="statement not covered" >return;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError4=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError4=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion4&amp;&amp;_iterator4.return){<span class="cstat-no" title="statement not covered" >_iterator4.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError4){<span class="cstat-no" title="statement not covered" >throw _iteratorError4;}</span>}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>c</span>ollectTypes(path);<span class="cstat-no" title="statement not covered" >v</span>ar inspect=path.scope.generateUidIdentifier('inspect');<span class="cstat-no" title="statement not covered" >v</span>ar requiresHelpers={inspect:false};<span class="cstat-no" title="statement not covered" >v</span>ar context={get inspect<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>requiresHelpers.inspect=true;<span class="cstat-no" title="statement not covered" >r</span>eturn inspect;}</span>};<span class="cstat-no" title="statement not covered" >p</span>ath.traverse(visitors,context);<span class="cstat-no" title="statement not covered" >i</span>f(requiresHelpers.inspect){<span class="cstat-no" title="statement not covered" >var body=path.get('body');<span class="cstat-no" title="statement not covered" >b</span>ody[body.length-1].insertAfter(template('\n            function id (input, depth) {\n              const maxDepth = 4;\n              const maxKeys = 15;\n              if (depth === undefined) {\n                depth = 0;\n              }\n              depth += 1;\n              if (input === null) {\n                return \'null\';\n              }\n              else if (input === undefined) {\n                return \'void\';\n              }\n              else if (typeof input === \'string\' || typeof input === \'number\' || typeof input === \'boolean\') {\n                return typeof input;\n              }\n              else if (Array.isArray(input)) {\n                if (input.length &gt; 0) {\n                  if (depth &gt; maxDepth) return \'[...]\';\n                  const first = id(input[0], depth);\n                  if (input.every(item =&gt; id(item, depth) === first)) {\n                    return first.trim() + \'[]\';\n                  }\n                  else {\n                    return \'[\' + input.slice(0, maxKeys).map(item =&gt; id(item, depth)).join(\', \') + (input.length &gt;= maxKeys ? \', ...\' : \'\') + \']\';\n                  }\n                }\n                else {\n                  return \'Array\';\n                }\n              }\n              else {\n                const keys = Object.keys(input);\n                if (!keys.length) {\n                  if (input.constructor &amp;&amp; input.constructor.name &amp;&amp; input.constructor.name !== \'Object\') {\n                    return input.constructor.name;\n                  }\n                  else {\n                    return \'Object\';\n                  }\n                }\n                if (depth &gt; maxDepth) return \'{...}\';\n                const indent = \'  \'.repeat(depth - 1);\n                let entries = keys.slice(0, maxKeys).map(key =&gt; {\n                  return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key) ? key : JSON.stringify(key)) + \': \' + id(input[key], depth) + \';\';\n                }).join(\'\\n  \' + indent);\n                if (keys.length &gt;= maxKeys) {\n                  entries += \'\\n  \' + indent + \'...\';\n                }\n                if (input.constructor &amp;&amp; input.constructor.name &amp;&amp; input.constructor.name !== \'Object\') {\n                  return input.constructor.name + \' {\\n  \' + indent + entries + \'\\n\' + indent + \'}\';\n                }\n                else {\n                  return \'{\\n  \' + indent + entries + \'\\n\' + indent + \'}\';\n                }\n              }\n            }\n          ')({id:inspect}));}</span>}</span>}}; </span>/**
   * Create a function which can verify the return type for a function.
   */<span class="fstat-no" title="function not covered" >function createFunctionReturnGuard(path,context){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isGeneratorAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1?annotation.typeParameters.params[1]:t.anyTypeAnnotation();}</span>else <span class="cstat-no" title="statement not covered" >if(node.async&amp;&amp;annotation.type==='GenericTypeAnnotation'&amp;&amp;annotation.id.name==='Promise'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters&amp;&amp;annotation.typeParameters[0]||t.anyTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar name=scope.generateUidIdentifierBasedOnNode(node);<span class="cstat-no" title="statement not covered" >v</span>ar id=scope.generateUidIdentifier('id');<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(id,annotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >node.returnGuard=guardFn({id:id,name:name,check:check,message:returnTypeErrorMessage(path,path.node,id,context)});<span class="cstat-no" title="statement not covered" >n</span>ode.returnGuard.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >n</span>ode.returnGuardName=name;<span class="cstat-no" title="statement not covered" >n</span>ode.returnGuardCount=0;}</span>}<span class="fstat-no" title="function not covered" ></span>function createFunctionYieldGuards(path,context){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='NullableTypeAnnotation'||annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!annotation.typeParameters||annotation.typeParameters.params.length===0){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!isGeneratorAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar yieldType=annotation.typeParameters.params[0];<span class="cstat-no" title="statement not covered" >v</span>ar nextType=annotation.typeParameters.params[2];<span class="cstat-no" title="statement not covered" >i</span>f(yieldType){<span class="cstat-no" title="statement not covered" >var _name=scope.generateUidIdentifier('check'+(node.id?node.id.name.slice(0,1).toUpperCase()+node.id.name.slice(1):'')+'Yield');<span class="cstat-no" title="statement not covered" >v</span>ar _id3=scope.generateUidIdentifier('id');<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(_id3,yieldType,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >node.yieldGuard=guardFn({id:_id3,name:_name,check:check,message:yieldTypeErrorMessage(node,yieldType,_id3,context)});<span class="cstat-no" title="statement not covered" >n</span>ode.yieldGuardName=_name;<span class="cstat-no" title="statement not covered" >n</span>ode.yieldGuardCount=0;}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(nextType){<span class="cstat-no" title="statement not covered" >var _name2=scope.generateUidIdentifier('check'+(node.id?node.id.name.slice(0,1).toUpperCase()+node.id.name.slice(1):'')+'Next');<span class="cstat-no" title="statement not covered" >v</span>ar _id4=scope.generateUidIdentifier('id');<span class="cstat-no" title="statement not covered" >v</span>ar _check2=checkAnnotation(_id4,nextType,scope);<span class="cstat-no" title="statement not covered" >i</span>f(_check2){<span class="cstat-no" title="statement not covered" >node.nextGuard=guardFn({id:_id4,name:_name2,check:_check2,message:yieldNextTypeErrorMessage(node,nextType,_id4,context)});<span class="cstat-no" title="statement not covered" >n</span>ode.nextGuardName=_name2;<span class="cstat-no" title="statement not covered" >n</span>ode.nextGuardCount=0;}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function isThisMemberExpression(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='ThisExpression'){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='MemberExpression'){<span class="cstat-no" title="statement not covered" >return isThisMemberExpression(path.get('object'));}</span>else {<span class="cstat-no" title="statement not covered" >return false;}</span>}<span class="fstat-no" title="function not covered" ></span></span>function isGeneratorAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>if(!annotation){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(annotation.type==='TypeAnnotation'||annotation.type==='NullableTypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn annotation.type==='GenericTypeAnnotation'&amp;&amp;annotation.id.name==='Generator';}<span class="fstat-no" title="function not covered" ></span>function buildErrorMessage(message,expected,got){<span class="cstat-no" title="statement not covered" ></span>if(got){<span class="cstat-no" title="statement not covered" >return message+'\n\nExpected:\n'+humanReadableType(expected)+'\n\nGot:\n'+humanReadableType(got);}</span>else {<span class="cstat-no" title="statement not covered" >return message+'\n\nExpected:\n'+humanReadableType(expected);}</span>}<span class="fstat-no" title="function not covered" ></span>function createChecks(){<span class="cstat-no" title="statement not covered" ></span>return {number:expression('typeof input === \'number\''),numericLiteral:checkNumericLiteral,boolean:expression('typeof input === \'boolean\''),booleanLiteral:checkBooleanLiteral,class:checkClass,function:expression('typeof input === \'function\''),string:expression('typeof input === \'string\''),stringLiteral:checkStringLiteral,symbol:expression('typeof input === \'symbol\''),undefined:expression('input === undefined'),null:expression('input === null'),void:expression('input == null'),instanceof:expression('input instanceof type'),type:expression('type(input)'),mixed:<span class="fstat-no" title="function not covered" >function mixed(){<span class="cstat-no" title="statement not covered" ></span>return null;}</span>,any:<span class="fstat-no" title="function not covered" >function any(){<span class="cstat-no" title="statement not covered" ></span>return null;}</span>,union:checkUnion,intersection:checkIntersection,array:checkArray,map:checkMap,set:checkSet,generator:checkGenerator,iterable:checkIterable,tuple:checkTuple,object:checkObject,nullable:checkNullable,typeof:checkTypeof,int8:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= -128 &amp;&amp; input &lt;= 127 &amp;&amp; input === Math.floor(input)'),uint8:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= 0 &amp;&amp; input &lt;= 255 &amp;&amp; input === Math.floor(input)'),int16:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= -32768 &amp;&amp; input &lt;= 32767 &amp;&amp; input === Math.floor(input)'),uint16:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= 0 &amp;&amp; input &lt;= 65535 &amp;&amp; input === Math.floor(input)'),int32:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= -2147483648 &amp;&amp; input &lt;= 2147483647 &amp;&amp; input === Math.floor(input)'),uint32:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= 0 &amp;&amp; input &lt;= 4294967295 &amp;&amp; input === Math.floor(input)'),float32:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= -3.40282347e+38 &amp;&amp; input &lt;= 3.40282347e+38'),float64:expression('typeof input === \'number\' &amp;&amp; !isNaN(input)'),double:expression('typeof input === \'number\' &amp;&amp; !isNaN(input)')};}<span class="fstat-no" title="function not covered" ></span>function createStaticChecks(){<span class="cstat-no" title="statement not covered" ></span>return {symbol:<span class="fstat-no" title="function not covered" >function symbol(path){<span class="cstat-no" title="statement not covered" ></span>return maybeSymbolAnnotation(getAnnotation(path));}</span>,instanceof:<span class="fstat-no" title="function not covered" >function _instanceof(_ref7){<span class="cstat-no" title="statement not covered" ></span>var path=_ref7.path;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref7.annotation;<span class="cstat-no" title="statement not covered" >v</span>ar type=createTypeExpression(annotation.id);<span class="cstat-no" title="statement not covered" >v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >i</span>f(type.name==='Object'&amp;&amp;node.type==='ObjectExpression'&amp;&amp;!scope.getBinding('Object')){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='Map'&amp;&amp;!scope.getBinding('Map')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='Set'&amp;&amp;!scope.getBinding('Set')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='Class'&amp;&amp;!scope.hasBinding('Class')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='int8'&amp;&amp;!scope.hasBinding('int8')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='uint8'&amp;&amp;!scope.hasBinding('uint8')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='int16'&amp;&amp;!scope.hasBinding('int16')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='uint16'&amp;&amp;!scope.hasBinding('uint16')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='int32'&amp;&amp;!scope.hasBinding('int32')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='uint32'&amp;&amp;!scope.hasBinding('uint32')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='float32'&amp;&amp;!scope.hasBinding('float32')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='float64'&amp;&amp;!scope.hasBinding('float64')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='double'&amp;&amp;!scope.hasBinding('double')){<span class="cstat-no" title="statement not covered" >return null;}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span></span></span></span></span></span></span></span></span></span>eturn maybeInstanceOfAnnotation(getAnnotation(path),type,annotation.typeParameters?annotation.typeParameters.params:[]);}</span>,type:<span class="fstat-no" title="function not covered" >function(_type){<span class="fstat-no" title="function not covered" ></span>function type(_x){<span class="cstat-no" title="statement not covered" ></span>return _type.apply(this,arguments);}<span class="cstat-no" title="statement not covered" ></span>type.toString=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return _type.toString();}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn type;}</span>(<span class="fstat-no" title="function not covered" >function(_ref8){<span class="cstat-no" title="statement not covered" ></span>var path=_ref8.path;<span class="cstat-no" title="statement not covered" >v</span>ar type=_ref8.type;<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span>)};}<span class="fstat-no" title="function not covered" ></span>function compareAnnotations(a,b){<span class="cstat-no" title="statement not covered" ></span>if(a.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >a=a.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(b.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >b=b.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(a.type){case 'StringTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeStringAnnotation(b);c</span>ase 'StringLiteral':case 'StringLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareStringLiteralAnnotations(a,b);c</span>ase 'NumberTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeNumberAnnotation(b);c</span>ase 'NumericLiteral':case 'NumericLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareNumericLiteralAnnotations(a,b);c</span>ase 'BooleanTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeBooleanAnnotation(b);c</span>ase 'BooleanLiteral':case 'BooleanLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareBooleanLiteralAnnotations(a,b);c</span>ase 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeFunctionAnnotation(b);c</span>ase 'AnyTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;c</span>ase 'MixedTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;c</span>ase 'ObjectTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareObjectAnnotation(a,b);c</span>ase 'ArrayTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareArrayAnnotation(a,b);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareGenericAnnotation(a,b);c</span>ase 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareTupleAnnotation(a,b);c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareUnionAnnotation(a,b);c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareIntersectionAnnotation(a,b);c</span>ase 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareNullableAnnotation(a,b);d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareStringLiteralAnnotations(a,b){<span class="cstat-no" title="statement not covered" ></span>if(b.type==='StringLiteralTypeAnnotation'||b.type==='StringLiteral'){<span class="cstat-no" title="statement not covered" >return a.value===b.value;}</span>else {<span class="cstat-no" title="statement not covered" >return maybeStringAnnotation(b)===false?false:null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareBooleanLiteralAnnotations(a,b){<span class="cstat-no" title="statement not covered" ></span>if(b.type==='BooleanLiteralTypeAnnotation'||b.type==='BooleanLiteral'){<span class="cstat-no" title="statement not covered" >return a.value===b.value;}</span>else {<span class="cstat-no" title="statement not covered" >return maybeBooleanAnnotation(b)===false?false:null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareNumericLiteralAnnotations(a,b){<span class="cstat-no" title="statement not covered" ></span>if(b.type==='NumericLiteralTypeAnnotation'||b.type==='NumericLiteral'){<span class="cstat-no" title="statement not covered" >return a.value===b.value;}</span>else {<span class="cstat-no" title="statement not covered" >return maybeNumberAnnotation(b)===false?false:null;}</span>}<span class="fstat-no" title="function not covered" ></span>function unionComparer(a,b,comparator){<span class="cstat-no" title="statement not covered" ></span>if(!a.types||a.types.length===0){<span class="cstat-no" title="statement not covered" >return null;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar trueCount=0;<span class="cstat-no" title="statement not covered" >i</span>f(!a.types){<span class="cstat-no" title="statement not covered" >return null;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion5=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError5=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError5=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator5=a.types[Symbol.iterator](),_step5;!(_iteratorNormalCompletion5=(_step5=_iterator5.next()).done);_iteratorNormalCompletion5=true){<span class="cstat-no" title="statement not covered" >var _type2=_step5.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=comparator(_type2,b);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >if(b.type!=='UnionTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return true;}<span class="cstat-no" title="statement not covered" ></span>t</span>rueCount++;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >if(b.type==='UnionTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>f</span>alseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError5=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError5=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion5&amp;&amp;_iterator5.return){<span class="cstat-no" title="statement not covered" >_iterator5.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError5){<span class="cstat-no" title="statement not covered" >throw _iteratorError5;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===a.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else <span class="cstat-no" title="statement not covered" >if(trueCount===a.types.length){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span></span>function intersectionComparer(a,b,comparator){<span class="cstat-no" title="statement not covered" ></span>var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar trueCount=0;<span class="cstat-no" title="statement not covered" >i</span>f(!a.types){<span class="cstat-no" title="statement not covered" >return null;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion6=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError6=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError6=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator6=a.types[Symbol.iterator](),_step6;!(_iteratorNormalCompletion6=(_step6=_iterator6.next()).done);_iteratorNormalCompletion6=true){<span class="cstat-no" title="statement not covered" >var _type3=_step6.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=comparator(_type3,b);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >trueCount++;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >return false;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError6=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError6=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion6&amp;&amp;_iterator6.return){<span class="cstat-no" title="statement not covered" >_iterator6.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError6){<span class="cstat-no" title="statement not covered" >throw _iteratorError6;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(trueCount===a.types.length){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareObjectAnnotation(a,b){<span class="cstat-no" title="statement not covered" ></span>switch(b.type){case 'ObjectTypeAnnotation':<span class="cstat-no" title="statement not covered" >break;c</span>ase 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareObjectAnnotation(a,b.typeAnnotation);c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return unionComparer(a,b,compareObjectAnnotation);c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return intersectionComparer(a,b,compareObjectAnnotation);c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span> </span>// We're comparing two object annotations.
<span class="cstat-no" title="statement not covered" >var allTrue=true;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion7=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError7=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError7=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator7=a.properties[Symbol.iterator](),_step7;!(_iteratorNormalCompletion7=(_step7=_iterator7.next()).done);_iteratorNormalCompletion7=true){<span class="cstat-no" title="statement not covered" >var aprop=_step7.value;<span class="cstat-no" title="statement not covered" >v</span>ar found=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion8=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError8=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError8=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator8=b.properties[Symbol.iterator](),_step8;!(_iteratorNormalCompletion8=(_step8=_iterator8.next()).done);_iteratorNormalCompletion8=true){<span class="cstat-no" title="statement not covered" >var bprop=_step8.value;<span class="cstat-no" title="statement not covered" >i</span>f(bprop.key.name===aprop.key.name){<span class="cstat-no" title="statement not covered" >var result=compareAnnotations(aprop.value,bprop.value);<span class="cstat-no" title="statement not covered" >i</span>f(result===false&amp;&amp;!(aprop.optional&amp;&amp;(bprop.optional||maybeNullableAnnotation(bprop.value)===true))){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >found=result;}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError8=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError8=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion8&amp;&amp;_iterator8.return){<span class="cstat-no" title="statement not covered" >_iterator8.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError8){<span class="cstat-no" title="statement not covered" >throw _iteratorError8;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(found===false&amp;&amp;!aprop.optional){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>a</span>llTrue=allTrue&amp;&amp;found===true;}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError7=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError7=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion7&amp;&amp;_iterator7.return){<span class="cstat-no" title="statement not covered" >_iterator7.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError7){<span class="cstat-no" title="statement not covered" >throw _iteratorError7;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn allTrue?true:null;}<span class="fstat-no" title="function not covered" ></span>function compareArrayAnnotation(a,b){<span class="cstat-no" title="statement not covered" ></span>switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareArrayAnnotation(a,b.typeAnnotation);c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return unionComparer(a,b,compareArrayAnnotation);c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return intersectionComparer(a,b,compareArrayAnnotation);c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareGenericAnnotation(a,b){<span class="cstat-no" title="statement not covered" ></span>switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareGenericAnnotation(a,b.typeAnnotation);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(b.id.name===a.id.name){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return unionComparer(a,b,compareGenericAnnotation);c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return intersectionComparer(a,b,compareGenericAnnotation);d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareTupleAnnotation(a,b){<span class="cstat-no" title="statement not covered" ></span>if(b.type==='TupleTypeAnnotation'){<span class="cstat-no" title="statement not covered" >if(b.types.length===0){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(b.types.length&lt;a.types.length){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn a.types.every(<span class="fstat-no" title="function not covered" >function(type,index){<span class="cstat-no" title="statement not covered" ></span>return compareAnnotations(type,b.types[index]);}</span>);}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareTupleAnnotation(a,b.typeAnnotation);c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return unionComparer(a,b,compareTupleAnnotation);c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return intersectionComparer(a,b,compareTupleAnnotation);c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareUnionAnnotation(a,b){<span class="cstat-no" title="statement not covered" ></span>switch(b.type){case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareUnionAnnotation(a,b.typeAnnotation);c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return unionComparer(a,b,compareAnnotations);}</span>}<span class="fstat-no" title="function not covered" ></span>function compareNullableAnnotation(a,b){<span class="cstat-no" title="statement not covered" ></span>switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return compareNullableAnnotation(a,b.typeAnnotation);c</span>ase 'NullableTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(compareAnnotations(a.typeAnnotation,b)===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function arrayExpressionToTupleAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var elements=path.get('elements');<span class="cstat-no" title="statement not covered" >r</span>eturn t.tupleTypeAnnotation(elements.map(<span class="fstat-no" title="function not covered" >function(element){<span class="cstat-no" title="statement not covered" ></span>return getAnnotation(element);}</span>));}<span class="fstat-no" title="function not covered" ></span>function checkNullable(_ref9){<span class="cstat-no" title="statement not covered" ></span>var input=_ref9.input;<span class="cstat-no" title="statement not covered" >v</span>ar type=_ref9.type;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref9.scope;<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(input,type,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!check){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logicalExpression("||",checks.void({input:input}),check);}<span class="fstat-no" title="function not covered" ></span>function checkTypeof(_ref10){<span class="cstat-no" title="statement not covered" ></span>var input=_ref10.input;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref10.annotation;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref10.scope;<span class="cstat-no" title="statement not covered" >s</span>witch(annotation.type){case 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >var id=annotation.id;<span class="cstat-no" title="statement not covered" >v</span>ar path=Object.assign({},input,{type:id.type,node:id,scope:scope});<span class="cstat-no" title="statement not covered" >r</span>eturn checkAnnotation(input,getAnnotation(path),scope);d</span>efault:<span class="cstat-no" title="statement not covered" >return checkAnnotation(input,annotation,scope);}</span>}<span class="fstat-no" title="function not covered" ></span>function checkStringLiteral(_ref11){<span class="cstat-no" title="statement not covered" ></span>var input=_ref11.input;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref11.annotation;<span class="cstat-no" title="statement not covered" >r</span>eturn checkEquals({input:input,expected:t.stringLiteral(annotation.value)});}<span class="fstat-no" title="function not covered" ></span>function checkNumericLiteral(_ref12){<span class="cstat-no" title="statement not covered" ></span>var input=_ref12.input;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref12.annotation;<span class="cstat-no" title="statement not covered" >r</span>eturn checkEquals({input:input,expected:t.numericLiteral(annotation.value)});}<span class="fstat-no" title="function not covered" ></span>function checkBooleanLiteral(_ref13){<span class="cstat-no" title="statement not covered" ></span>var input=_ref13.input;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref13.annotation;<span class="cstat-no" title="statement not covered" >r</span>eturn checkEquals({input:input,expected:t.booleanLiteral(annotation.value)});}<span class="fstat-no" title="function not covered" ></span>function checkUnion(_ref14){<span class="cstat-no" title="statement not covered" ></span>var input=_ref14.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref14.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref14.scope;<span class="cstat-no" title="statement not covered" >v</span>ar checks=types.map(<span class="fstat-no" title="function not covered" >function(type){<span class="cstat-no" title="statement not covered" ></span>return checkAnnotation(input,type,scope);}</span>).filter(identity);<span class="cstat-no" title="statement not covered" >r</span>eturn checks.reduce(<span class="fstat-no" title="function not covered" >function(last,check,index){<span class="cstat-no" title="statement not covered" ></span>if(last==null){<span class="cstat-no" title="statement not covered" >return check;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logicalExpression("||",last,check);}</span>,null);}<span class="fstat-no" title="function not covered" ></span>function checkIntersection(_ref15){<span class="cstat-no" title="statement not covered" ></span>var input=_ref15.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref15.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref15.scope;<span class="cstat-no" title="statement not covered" >v</span>ar checks=types.map(<span class="fstat-no" title="function not covered" >function(type){<span class="cstat-no" title="statement not covered" ></span>return checkAnnotation(input,type,scope);}</span>).filter(identity);<span class="cstat-no" title="statement not covered" >r</span>eturn checks.reduce(<span class="fstat-no" title="function not covered" >function(last,check,index){<span class="cstat-no" title="statement not covered" ></span>if(last==null){<span class="cstat-no" title="statement not covered" >return check;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logicalExpression("&amp;&amp;",last,check);}</span>,null);}<span class="fstat-no" title="function not covered" ></span>function checkMap(_ref16){<span class="cstat-no" title="statement not covered" ></span>var input=_ref16.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref16.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref16.scope;<span class="cstat-no" title="statement not covered" >v</span>ar _types=_slicedToArray(types,2);<span class="cstat-no" title="statement not covered" >v</span>ar keyType=_types[0];<span class="cstat-no" title="statement not covered" >v</span>ar valueType=_types[1];<span class="cstat-no" title="statement not covered" >v</span>ar key=t.identifier('key');<span class="cstat-no" title="statement not covered" >v</span>ar value=t.identifier('value');<span class="cstat-no" title="statement not covered" >v</span>ar keyCheck=keyType?checkAnnotation(key,keyType,scope):null;<span class="cstat-no" title="statement not covered" >v</span>ar valueCheck=valueType?checkAnnotation(value,valueType,scope):null;<span class="cstat-no" title="statement not covered" >i</span>f(!keyCheck){<span class="cstat-no" title="statement not covered" >if(!valueCheck){<span class="cstat-no" title="statement not covered" >return checkIsMap({input:input});}</span>else {<span class="cstat-no" title="statement not covered" >return checkMapValues({input:input,value:value,valueCheck:valueCheck});}</span>}</span>else {<span class="cstat-no" title="statement not covered" >if(!valueCheck){<span class="cstat-no" title="statement not covered" >return checkMapKeys({input:input,key:key,keyCheck:keyCheck});}</span>else {<span class="cstat-no" title="statement not covered" >return checkMapEntries({input:input,key:key,value:value,keyCheck:keyCheck,valueCheck:valueCheck});}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function checkSet(_ref17){<span class="cstat-no" title="statement not covered" ></span>var input=_ref17.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref17.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref17.scope;<span class="cstat-no" title="statement not covered" >v</span>ar _types2=_slicedToArray(types,1);<span class="cstat-no" title="statement not covered" >v</span>ar valueType=_types2[0];<span class="cstat-no" title="statement not covered" >v</span>ar value=t.identifier('value');<span class="cstat-no" title="statement not covered" >v</span>ar valueCheck=valueType?checkAnnotation(value,valueType,scope):null;<span class="cstat-no" title="statement not covered" >i</span>f(!valueCheck){<span class="cstat-no" title="statement not covered" >return checkIsSet({input:input});}</span>else {<span class="cstat-no" title="statement not covered" >return checkSetEntries({input:input,value:value,valueCheck:valueCheck});}</span>}<span class="fstat-no" title="function not covered" ></span>function checkGenerator(_ref18){<span class="cstat-no" title="statement not covered" ></span>var input=_ref18.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref18.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref18.scope;<span class="cstat-no" title="statement not covered" >r</span>eturn checkIsGenerator({input:input});}<span class="fstat-no" title="function not covered" ></span>function checkIterable(_ref19){<span class="cstat-no" title="statement not covered" ></span>var input=_ref19.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref19.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref19.scope;<span class="cstat-no" title="statement not covered" >r</span>eturn checkIsIterable({input:input});}<span class="fstat-no" title="function not covered" ></span>function checkClass(_ref20){<span class="cstat-no" title="statement not covered" ></span>var input=_ref20.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref20.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref20.scope;<span class="cstat-no" title="statement not covered" >r</span>eturn checkIsClass({input:input});}<span class="fstat-no" title="function not covered" ></span>function checkArray(_ref21){<span class="cstat-no" title="statement not covered" ></span>var input=_ref21.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref21.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref21.scope;<span class="cstat-no" title="statement not covered" >i</span>f(!types||types.length===0){<span class="cstat-no" title="statement not covered" >return checkIsArray({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(types.length===1){<span class="cstat-no" title="statement not covered" >var item=t.identifier('item');<span class="cstat-no" title="statement not covered" >v</span>ar _type4=types[0];<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(item,_type4,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!check){<span class="cstat-no" title="statement not covered" >return checkIsArray({input:input});}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logicalExpression('&amp;&amp;',checkIsArray({input:input}),t.callExpression(t.memberExpression(input,t.identifier('every')),[t.functionExpression(null,[item],t.blockStatement([t.returnStatement(check)]))]));}</span>else { // This is a tuple</span></span>
<span class="cstat-no" title="statement not covered" >var _checks=types.map(<span class="fstat-no" title="function not covered" >function(type,index){<span class="cstat-no" title="statement not covered" ></span>return checkAnnotation(t.memberExpression(input,t.numericLiteral(index),true),type,scope);}</span>).filter(identity);<span class="cstat-no" title="statement not covered" >v</span>ar checkLength=t.binaryExpression('&gt;=',t.memberExpression(input,t.identifier('length')),t.numericLiteral(types.length));<span class="cstat-no" title="statement not covered" >r</span>eturn _checks.reduce(<span class="fstat-no" title="function not covered" >function(last,check,index){<span class="cstat-no" title="statement not covered" ></span>return t.logicalExpression("&amp;&amp;",last,check);}</span>,t.logicalExpression('&amp;&amp;',checkIsArray({input:input}),checkLength));}</span>}<span class="fstat-no" title="function not covered" >function checkTuple(_ref22){<span class="cstat-no" title="statement not covered" ></span>var input=_ref22.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref22.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref22.scope;<span class="cstat-no" title="statement not covered" >i</span>f(types.length===0){<span class="cstat-no" title="statement not covered" >return checkIsArray({input:input});}</span> </span>// This is a tuple
<span class="cstat-no" title="statement not covered" >var checks=types.map(<span class="fstat-no" title="function not covered" >function(type,index){<span class="cstat-no" title="statement not covered" ></span>return checkAnnotation(t.memberExpression(input,t.numericLiteral(index),true),type,scope);}</span>).filter(identity);<span class="cstat-no" title="statement not covered" >v</span>ar checkLength=t.binaryExpression('&gt;=',t.memberExpression(input,t.identifier('length')),t.numericLiteral(types.length));<span class="cstat-no" title="statement not covered" >r</span>eturn checks.reduce(<span class="fstat-no" title="function not covered" >function(last,check,index){<span class="cstat-no" title="statement not covered" ></span>return t.logicalExpression("&amp;&amp;",last,check);}</span>,t.logicalExpression('&amp;&amp;',checkIsArray({input:input}),checkLength));}<span class="fstat-no" title="function not covered" ></span>function checkObject(_ref23){<span class="cstat-no" title="statement not covered" ></span>var input=_ref23.input;<span class="cstat-no" title="statement not covered" >v</span>ar properties=_ref23.properties;<span class="cstat-no" title="statement not covered" >v</span>ar indexers=_ref23.indexers;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref23.scope;<span class="cstat-no" title="statement not covered" >i</span>f(input.type==='ObjectPattern'){<span class="cstat-no" title="statement not covered" >return checkObjectPattern({input:input,properties:properties,scope:scope});}<span class="cstat-no" title="statement not covered" ></span>v</span>ar propNames=[];<span class="cstat-no" title="statement not covered" >v</span>ar check=properties.length===0?checkIsObject({input:input}):properties.reduce(<span class="fstat-no" title="function not covered" >function(expr,prop,index){<span class="cstat-no" title="statement not covered" ></span>var target=prop.key.type==='Identifier'?t.memberExpression(input,prop.key):t.memberExpression(input,prop.key,true);<span class="cstat-no" title="statement not covered" >p</span>ropNames.push(prop.key.type==='Identifier'?t.stringLiteral(prop.key.name):prop.key);<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(target,prop.value,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >if(prop.optional){<span class="cstat-no" title="statement not covered" >check=t.logicalExpression('||',checks.undefined({input:target}),check);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logicalExpression("&amp;&amp;",expr,check);}</span>else {<span class="cstat-no" title="statement not covered" >return expr;}</span>}</span>,checkNotNull({input:input}));<span class="cstat-no" title="statement not covered" >i</span>f(indexers.length){<span class="cstat-no" title="statement not covered" >return indexers.reduceRight(<span class="fstat-no" title="function not covered" >function(expr,indexer){<span class="cstat-no" title="statement not covered" ></span>if(indexer.value.type==='AnyTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return expr;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar value=scope.generateUidIdentifier(indexer.id.name);<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(value,indexer.value,scope);<span class="cstat-no" title="statement not covered" >v</span>ar fixedKeys=t.arrayExpression(propNames);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >if(propNames.length){<span class="cstat-no" title="statement not covered" >return t.logicalExpression('&amp;&amp;',expr,checkObjectIndexers({input:input,value:value,check:check,fixedKeys:fixedKeys}));}</span>else {<span class="cstat-no" title="statement not covered" >return t.logicalExpression('&amp;&amp;',expr,checkObjectIndexersNoFixed({input:input,value:value,check:check,fixedKeys:fixedKeys}));}</span>}</span>else {<span class="cstat-no" title="statement not covered" >return expr;}</span>}</span>,check);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn check;}<span class="fstat-no" title="function not covered" ></span>function checkObjectPattern(_ref24){<span class="cstat-no" title="statement not covered" ></span>var input=_ref24.input;<span class="cstat-no" title="statement not covered" >v</span>ar properties=_ref24.properties;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref24.scope;<span class="cstat-no" title="statement not covered" >v</span>ar propNames=properties.reduce(<span class="fstat-no" title="function not covered" >function(names,prop){<span class="cstat-no" title="statement not covered" ></span>names[prop.key.name]=prop;<span class="cstat-no" title="statement not covered" >r</span>eturn names;}</span>,{});<span class="cstat-no" title="statement not covered" >v</span>ar propChecks={};<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion9=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError9=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError9=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator9=input.properties[Symbol.iterator](),_step9;!(_iteratorNormalCompletion9=(_step9=_iterator9.next()).done);_iteratorNormalCompletion9=true){<span class="cstat-no" title="statement not covered" >var item=_step9.value;<span class="cstat-no" title="statement not covered" >v</span>ar key=item.key;<span class="cstat-no" title="statement not covered" >v</span>ar _id5=item.value;<span class="cstat-no" title="statement not covered" >v</span>ar prop=propNames[key.name];<span class="cstat-no" title="statement not covered" >i</span>f(!prop){<span class="cstat-no" title="statement not covered" >continue;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar check=checkAnnotation(_id5,prop.value,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >propChecks[key.name]=check;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError9=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError9=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion9&amp;&amp;_iterator9.return){<span class="cstat-no" title="statement not covered" >_iterator9.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError9){<span class="cstat-no" title="statement not covered" >throw _iteratorError9;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Object.keys(propChecks).reduce(<span class="fstat-no" title="function not covered" >function(last,name){<span class="cstat-no" title="statement not covered" ></span>var check=propChecks[name];<span class="cstat-no" title="statement not covered" >i</span>f(last===null){<span class="cstat-no" title="statement not covered" >return check;}</span>else {<span class="cstat-no" title="statement not covered" >return t.logicalExpression('&amp;&amp;',last,check);}</span>}</span>,null);}<span class="fstat-no" title="function not covered" ></span>function createTypeAliasChecks(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.id;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.right;<span class="cstat-no" title="statement not covered" >v</span>ar input=t.identifier('input');<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(input,annotation,scope)||t.booleanLiteral(true);<span class="cstat-no" title="statement not covered" >v</span>ar declaration=declareTypeChecker({id:id,check:check});<span class="cstat-no" title="statement not covered" >d</span>eclaration.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >d</span>eclaration.savedTypeAnnotation=annotation;<span class="cstat-no" title="statement not covered" >d</span>eclaration.declarations[0].savedTypeAnnotation=annotation;<span class="cstat-no" title="statement not covered" >r</span>eturn declaration;}<span class="fstat-no" title="function not covered" ></span>function createInterfaceChecks(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.id;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.body;<span class="cstat-no" title="statement not covered" >v</span>ar input=t.identifier('input');<span class="cstat-no" title="statement not covered" >v</span>ar check=node.extends.reduce(<span class="fstat-no" title="function not covered" >function(check,extender){<span class="cstat-no" title="statement not covered" ></span>return t.logicalExpression('&amp;&amp;',check,checkAnnotation(input,t.genericTypeAnnotation(extender.id),path.scope));<span class="cstat-no" title="statement not covered" >r</span>eturn check;}</span>,checkAnnotation(input,annotation,scope)||t.booleanLiteral(true));<span class="cstat-no" title="statement not covered" >v</span>ar declaration=declareTypeChecker({id:id,check:check});<span class="cstat-no" title="statement not covered" >d</span>eclaration.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >r</span>eturn declaration;}<span class="fstat-no" title="function not covered" ></span>function checkAnnotation(input,annotation,scope){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return checkAnnotation(input,annotation.typeAnnotation,scope);c</span>ase 'TypeofTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.typeof({input:input,annotation:annotation.argument,scope:scope});c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Array'){<span class="cstat-no" title="statement not covered" >return checks.array({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Generator'&amp;&amp;!scope.hasBinding('Generator')){<span class="cstat-no" title="statement not covered" >return checks.generator({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Iterable'&amp;&amp;!scope.hasBinding('Iterable')){<span class="cstat-no" title="statement not covered" >return checks.iterable({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Map'&amp;&amp;!scope.getBinding('Map')){<span class="cstat-no" title="statement not covered" >return checks.map({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Set'&amp;&amp;!scope.getBinding('Set')){<span class="cstat-no" title="statement not covered" >return checks.set({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Function'){<span class="cstat-no" title="statement not covered" >return checks.function({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Class'&amp;&amp;!scope.hasBinding('Class')){<span class="cstat-no" title="statement not covered" >return checks.class({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='int8'&amp;&amp;!scope.hasBinding('int8')){<span class="cstat-no" title="statement not covered" >return checks.int8({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='uint8'&amp;&amp;!scope.hasBinding('uint8')){<span class="cstat-no" title="statement not covered" >return checks.uint8({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='int16'&amp;&amp;!scope.hasBinding('int16')){<span class="cstat-no" title="statement not covered" >return checks.int16({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='uint16'&amp;&amp;!scope.hasBinding('uint16')){<span class="cstat-no" title="statement not covered" >return checks.uint16({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='int32'&amp;&amp;!scope.hasBinding('int32')){<span class="cstat-no" title="statement not covered" >return checks.int32({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='uint32'&amp;&amp;!scope.hasBinding('uint32')){<span class="cstat-no" title="statement not covered" >return checks.uint32({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='float32'&amp;&amp;!scope.hasBinding('float32')){<span class="cstat-no" title="statement not covered" >return checks.float32({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='float64'&amp;&amp;!scope.hasBinding('float64')){<span class="cstat-no" title="statement not covered" >return checks.float64({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='double'&amp;&amp;!scope.hasBinding('double')){<span class="cstat-no" title="statement not covered" >return checks.double({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Symbol'&amp;&amp;!scope.getBinding('Symbol')){<span class="cstat-no" title="statement not covered" >return checks.symbol({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(isTypeChecker(annotation.id,scope)){<span class="cstat-no" title="statement not covered" >return checks.type({input:input,type:annotation.id});}</span>else <span class="cstat-no" title="statement not covered" >if(isPolymorphicType(annotation.id,scope)){<span class="cstat-no" title="statement not covered" >return;}</span>else {<span class="cstat-no" title="statement not covered" >return checks.instanceof({input:input,type:createTypeExpression(annotation.id)});}</span>c</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>ase 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.tuple({input:input,types:annotation.types,scope:scope});c</span>ase 'NumberTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.number({input:input});c</span>ase 'NumericLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.numericLiteral({input:input,annotation:annotation});c</span>ase 'BooleanTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.boolean({input:input});c</span>ase 'BooleanLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.booleanLiteral({input:input,annotation:annotation});c</span>ase 'StringTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.string({input:input});c</span>ase 'StringLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.stringLiteral({input:input,annotation:annotation});c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.union({input:input,types:annotation.types,scope:scope});c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.intersection({input:input,types:annotation.types,scope:scope});c</span>ase 'ObjectTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.object({input:input,properties:annotation.properties||[],indexers:annotation.indexers,scope:scope});c</span>ase 'ArrayTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.array({input:input,types:[annotation.elementType||t.anyTypeAnnotation()],scope:scope});c</span>ase 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.function({input:input,params:annotation.params,returnType:annotation.returnType});c</span>ase 'MixedTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.mixed({input:input});c</span>ase 'AnyTypeAnnotation':case 'ExistentialTypeParam':<span class="cstat-no" title="statement not covered" >return checks.any({input:input});c</span>ase 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.nullable({input:input,type:annotation.typeAnnotation,scope:scope});c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.void({input:input});}</span>}<span class="fstat-no" title="function not covered" ></span>function staticCheckAnnotation(path,annotation){<span class="cstat-no" title="statement not covered" ></span>var other=getAnnotation(path);<span class="cstat-no" title="statement not covered" >s</span>witch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return staticCheckAnnotation(path,annotation.typeAnnotation);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(isTypeChecker(annotation.id,path.scope)){<span class="cstat-no" title="statement not covered" >return staticChecks.type({path:path,type:annotation.id});}</span>else <span class="cstat-no" title="statement not covered" >if(isPolymorphicType(annotation.id,path.scope)){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Symbol'){<span class="cstat-no" title="statement not covered" >return staticChecks.symbol(path);}</span>else {<span class="cstat-no" title="statement not covered" >return staticChecks.instanceof({path:path,annotation:annotation});}</span>}<span class="cstat-no" title="statement not covered" ></span></span></span>r</span>eturn compareAnnotations(annotation,other);}</span> /**
   * Get the type annotation for a given node.
   */<span class="fstat-no" title="function not covered" >function getAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var annotation=void 0;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >annotation=getAnnotationShallow(path);}</span>catch(e){<span class="cstat-no" title="statement not covered" >if(e instanceof SyntaxError){<span class="cstat-no" title="statement not covered" >throw e;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(process.env.TYPECHECK_DEBUG){<span class="cstat-no" title="statement not covered" >console.error(e.stack);}</span>}<span class="cstat-no" title="statement not covered" ></span>w</span>hile(annotation&amp;&amp;annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn annotation||t.anyTypeAnnotation();}<span class="fstat-no" title="function not covered" ></span>function getAnnotationShallow(path){<span class="cstat-no" title="statement not covered" ></span>if(!path||!path.node){<span class="cstat-no" title="statement not covered" >return t.voidTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='TypeAlias'){<span class="cstat-no" title="statement not covered" >return node.right;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ClassProperty'&amp;&amp;node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return getClassPropertyAnnotation(path);}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ClassMethod'&amp;&amp;node.returnType){<span class="cstat-no" title="statement not covered" >return getClassMethodAnnotation(path);}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ObjectProperty'&amp;&amp;node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return getObjectPropertyAnnotation(path);}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='SpreadProperty'&amp;&amp;node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return getSpreadPropertyAnnotation(path);}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ObjectMethod'&amp;&amp;node.returnType){<span class="cstat-no" title="statement not covered" >return getObjectMethodAnnotation(path);}</span>else <span class="cstat-no" title="statement not covered" >if(!node.typeAnnotation&amp;&amp;!node.savedTypeAnnotation&amp;&amp;!node.returnType){<span class="cstat-no" title="statement not covered" >switch(path.type){case 'Identifier':<span class="cstat-no" title="statement not covered" >var binding=scope.getBinding(node.name);<span class="cstat-no" title="statement not covered" >i</span>f(!binding||!binding.identifier){<span class="cstat-no" title="statement not covered" >return path.getTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>v</span>ar id=binding.identifier;<span class="cstat-no" title="statement not covered" >i</span>f(binding.path.type==='ObjectPattern'){<span class="cstat-no" title="statement not covered" >return getObjectPatternAnnotation(binding.path,node.name);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(id.savedTypeAnnotation){<span class="cstat-no" title="statement not covered" >return id.savedTypeAnnotation;}</span>else <span class="cstat-no" title="statement not covered" >if(id.returnType){<span class="cstat-no" title="statement not covered" >return id.returnType;}</span>else <span class="cstat-no" title="statement not covered" >if(id.typeAnnotation){<span class="cstat-no" title="statement not covered" >return id.typeAnnotation;}</span>else <span class="cstat-no" title="statement not covered" >if(isPolymorphicType(id,scope)){<span class="cstat-no" title="statement not covered" >return t.anyTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span>eturn binding.constant?binding.path.getTypeAnnotation():path.getTypeAnnotation();c</span>ase 'StringLiteral':case 'NumericLiteral':case 'BooleanLiteral':<span class="cstat-no" title="statement not covered" >return createLiteralTypeAnnotation(path);c</span>ase 'CallExpression':<span class="cstat-no" title="statement not covered" >var callee=path.get('callee');<span class="cstat-no" title="statement not covered" >i</span>f(callee.type==='Identifier'){<span class="cstat-no" title="statement not covered" >if(callee.name==='Symbol'){<span class="cstat-no" title="statement not covered" >return t.genericTypeAnnotation('Symbol');}<span class="cstat-no" title="statement not covered" ></span>v</span>ar fn=getFunctionForIdentifier(callee);<span class="cstat-no" title="statement not covered" >i</span>f(fn){<span class="cstat-no" title="statement not covered" >return getAnnotation(fn);}</span>}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase 'ThisExpression':<span class="cstat-no" title="statement not covered" >return getThisExpressionAnnotation(path);c</span>ase 'AssignmentExpression':<span class="cstat-no" title="statement not covered" >return getAssignmentExpressionAnnotation(path);c</span>ase 'MemberExpression':<span class="cstat-no" title="statement not covered" >return getMemberExpressionAnnotation(path);c</span>ase 'ArrayExpression':<span class="cstat-no" title="statement not covered" >return getArrayExpressionAnnotation(path);c</span>ase 'ObjectExpression':<span class="cstat-no" title="statement not covered" >return getObjectExpressionAnnotation(path);c</span>ase 'BinaryExpression':<span class="cstat-no" title="statement not covered" >return getBinaryExpressionAnnotation(path);c</span>ase 'LogicalExpression':<span class="cstat-no" title="statement not covered" >return getLogicalExpressionAnnotation(path);c</span>ase 'ConditionalExpression':<span class="cstat-no" title="statement not covered" >return getConditionalExpressionAnnotation(path);c</span>ase 'ObjectMethod':<span class="cstat-no" title="statement not covered" >return getObjectMethodAnnotation(path);c</span>ase 'SpreadProperty':<span class="cstat-no" title="statement not covered" >return getSpreadPropertyAnnotation(path);c</span>ase 'ObjectProperty':<span class="cstat-no" title="statement not covered" >return getObjectPropertyAnnotation(path);c</span>ase 'ClassDeclaration':<span class="cstat-no" title="statement not covered" >return getClassDeclarationAnnotation(path);c</span>ase 'ClassMethod':<span class="cstat-no" title="statement not covered" >return getClassMethodAnnotation(path);c</span>ase 'ClassProperty':<span class="cstat-no" title="statement not covered" >return getClassPropertyAnnotation(path);d</span>efault:<span class="cstat-no" title="statement not covered" >return path.getTypeAnnotation();}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span></span></span></span>eturn node.savedTypeAnnotation||node.returnType||node.typeAnnotation||path.getTypeAnnotation();}<span class="fstat-no" title="function not covered" ></span>function createLiteralTypeAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var annotation=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(path.isStringLiteral()){<span class="cstat-no" title="statement not covered" >annotation=t.stringLiteralTypeAnnotation();}</span>else <span class="cstat-no" title="statement not covered" >if(path.isNumericLiteral()){<span class="cstat-no" title="statement not covered" >annotation=t.numericLiteralTypeAnnotation();}</span>else <span class="cstat-no" title="statement not covered" >if(path.isBooleanLiteral()){<span class="cstat-no" title="statement not covered" >annotation=t.booleanLiteralTypeAnnotation();}</span>else {<span class="cstat-no" title="statement not covered" >return path.getTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>a</span></span></span>nnotation.value=path.node.value;<span class="cstat-no" title="statement not covered" >r</span>eturn annotation;}<span class="fstat-no" title="function not covered" ></span>function getObjectPatternAnnotation(path,name){<span class="cstat-no" title="statement not covered" ></span>var annotation=keyByName(getAnnotation(path),name);<span class="cstat-no" title="statement not covered" >v</span>ar found=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(!path.node.properties){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion10=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError10=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError10=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator10=path.get('properties')[Symbol.iterator](),_step10;!(_iteratorNormalCompletion10=(_step10=_iterator10.next()).done);_iteratorNormalCompletion10=true){<span class="cstat-no" title="statement not covered" >var prop=_step10.value;<span class="cstat-no" title="statement not covered" >i</span>f(prop.node.value&amp;&amp;prop.node.value.name===name){<span class="cstat-no" title="statement not covered" >found=prop.get('key');<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>else <span class="cstat-no" title="statement not covered" >if(prop.node.key.type==='Identifier'&amp;&amp;prop.node.key.name===name){<span class="cstat-no" title="statement not covered" >found=prop.get('key');<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError10=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError10=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion10&amp;&amp;_iterator10.return){<span class="cstat-no" title="statement not covered" >_iterator10.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError10){<span class="cstat-no" title="statement not covered" >throw _iteratorError10;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!annotation||!found){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(found.type==='Identifier'){<span class="cstat-no" title="statement not covered" >annotation.value.authoritative=false;<span class="cstat-no" title="statement not covered" >r</span>eturn annotation.value;}</span>}<span class="fstat-no" title="function not covered" ></span>function keyByName(node,name){<span class="cstat-no" title="statement not covered" ></span>if(!node.properties){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion11=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError11=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError11=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator11=node.properties[Symbol.iterator](),_step11;!(_iteratorNormalCompletion11=(_step11=_iterator11.next()).done);_iteratorNormalCompletion11=true){<span class="cstat-no" title="statement not covered" >var prop=_step11.value;<span class="cstat-no" title="statement not covered" >i</span>f(prop.key&amp;&amp;prop.key.name===name){<span class="cstat-no" title="statement not covered" >return prop;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError11=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError11=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion11&amp;&amp;_iterator11.return){<span class="cstat-no" title="statement not covered" >_iterator11.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError11){<span class="cstat-no" title="statement not covered" >throw _iteratorError11;}</span>}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function valueByName(node,name){<span class="cstat-no" title="statement not covered" ></span>if(!node.properties){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion12=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError12=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError12=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator12=node.properties[Symbol.iterator](),_step12;!(_iteratorNormalCompletion12=(_step12=_iterator12.next()).done);_iteratorNormalCompletion12=true){<span class="cstat-no" title="statement not covered" >var prop=_step12.value;<span class="cstat-no" title="statement not covered" >i</span>f(prop.value&amp;&amp;prop.value.name===name){<span class="cstat-no" title="statement not covered" >return prop;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError12=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError12=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion12&amp;&amp;_iterator12.return){<span class="cstat-no" title="statement not covered" >_iterator12.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError12){<span class="cstat-no" title="statement not covered" >throw _iteratorError12;}</span>}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function getSpreadPropertyAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.typeAnnotation||node.savedTypeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(!annotation){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(path.get('argument'));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn annotation;}<span class="fstat-no" title="function not covered" ></span>function getObjectPropertyAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.typeAnnotation||node.savedTypeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(!annotation){<span class="cstat-no" title="statement not covered" >if(node.value){<span class="cstat-no" title="statement not covered" >if(node.value.typeAnnotation||node.value.savedTypeAnnotation){<span class="cstat-no" title="statement not covered" >annotation=node.value.typeAnnotation||node.value.savedTypeAnnotation;}</span>else <span class="cstat-no" title="statement not covered" >if(node.value.type==='BooleanLiteral'||node.value.type==='NumericLiteral'||node.value.type==='StringLiteral'){<span class="cstat-no" title="statement not covered" >annotation=t[node.value.type](node.value.value);}</span>else {<span class="cstat-no" title="statement not covered" >annotation=t.anyTypeAnnotation();}</span>}</span></span>else {<span class="cstat-no" title="statement not covered" >annotation=t.anyTypeAnnotation();}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.objectTypeProperty(node.key,annotation);}<span class="fstat-no" title="function not covered" ></span>function getObjectMethodAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >r</span>eturn t.objectTypeProperty(t.identifier(node.key.name),t.functionTypeAnnotation(null,node.params.map(<span class="fstat-no" title="function not covered" >function(param){<span class="cstat-no" title="statement not covered" ></span>return param.savedTypeAnnotation||param.typeAnnotation;}</span>),null,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation()));}<span class="fstat-no" title="function not covered" ></span>function getThisExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var parent=path.parentPath;<span class="cstat-no" title="statement not covered" >l</span>oop: <span class="cstat-no" title="statement not covered" >while(parent){<span class="cstat-no" title="statement not covered" >switch(parent.type){case 'ClassDeclaration':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent);c</span>ase 'ClassBody':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath);c</span>ase 'ClassMethod':case 'ClassProperty':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath.parentPath);c</span>ase 'ObjectProperty':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath);c</span>ase 'ObjectMethod':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath);c</span>ase 'FunctionExpression':<span class="cstat-no" title="statement not covered" >if(parent.parentPath.type==='ObjectProperty'){<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath.parentPath);}<span class="cstat-no" title="statement not covered" ></span>b</span>reak loop;c</span>ase 'ArrowFunctionExpression':<span class="cstat-no" title="statement not covered" >parent=parent.parentPath;<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(parent.isFunction()){<span class="cstat-no" title="statement not covered" >break;}<span class="cstat-no" title="statement not covered" ></span>p</span>arent=parent.parentPath;}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn t.objectTypeAnnotation([]);}<span class="fstat-no" title="function not covered" ></span>function getClassDeclarationAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var body=path.get('body').get('body').map(getAnnotation).filter(<span class="fstat-no" title="function not covered" >function(annotation){<span class="cstat-no" title="statement not covered" ></span>return annotation&amp;&amp;annotation.type!=='AnyTypeAnnotation';}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn t.objectTypeAnnotation(body);}<span class="fstat-no" title="function not covered" ></span>function getAssignmentExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>if(path.node.operator==='='){<span class="cstat-no" title="statement not covered" >return getAnnotation(path.get('right'));}</span>}<span class="fstat-no" title="function not covered" ></span>function getClassPropertyAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.computed){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar annotation=node.typeAnnotation||(node.value?node.value.savedTypeAnnotation||node.value.typeAnnotation:t.anyTypeAnnotation());<span class="cstat-no" title="statement not covered" >r</span>eturn t.objectTypeProperty(node.key,annotation||t.anyTypeAnnotation());}<span class="fstat-no" title="function not covered" ></span>function getClassMethodAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.computed){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.kind==='get'){<span class="cstat-no" title="statement not covered" >return t.objectTypeProperty(node.key,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation());}</span>else <span class="cstat-no" title="statement not covered" >if(node.kind==='set'){<span class="cstat-no" title="statement not covered" >return t.objectTypeProperty(node.key,node.params.map(<span class="fstat-no" title="function not covered" >function(param){<span class="cstat-no" title="statement not covered" ></span>return param.savedTypeAnnotation||param.typeAnnotation;}</span>).shift()||t.anyTypeAnnotation());}</span>else {<span class="cstat-no" title="statement not covered" >return t.objectTypeProperty(node.key,t.functionTypeAnnotation(null,node.params.map(<span class="fstat-no" title="function not covered" >function(param){<span class="cstat-no" title="statement not covered" ></span>return param.savedTypeAnnotation||param.typeAnnotation||t.anyTypeAnnotation();}</span>),null,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation()));}</span>}<span class="fstat-no" title="function not covered" ></span></span>function getBinaryExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(isBooleanExpression(node)){<span class="cstat-no" title="statement not covered" >return t.booleanTypeAnnotation();}</span>else {<span class="cstat-no" title="statement not covered" >return t.anyTypeAnnotation();}</span>}<span class="fstat-no" title="function not covered" ></span>function getLogicalExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(isBooleanExpression(node)){<span class="cstat-no" title="statement not covered" >return t.booleanTypeAnnotation();}</span>else {<span class="cstat-no" title="statement not covered" >var left=path.get('left');<span class="cstat-no" title="statement not covered" >v</span>ar right=path.get('right');<span class="cstat-no" title="statement not covered" >s</span>witch(node.operator){case '&amp;&amp;':case '||':<span class="cstat-no" title="statement not covered" >var _ref25=[getAnnotation(left),getAnnotation(right)];<span class="cstat-no" title="statement not covered" >l</span>eft=_ref25[0];<span class="cstat-no" title="statement not covered" >r</span>ight=_ref25[1];<span class="cstat-no" title="statement not covered" >i</span>f(t.isUnionTypeAnnotation(left)){<span class="cstat-no" title="statement not covered" >if(t.isUnionTypeAnnotation(right)){<span class="cstat-no" title="statement not covered" >return t.unionTypeAnnotation(left.types.concat(right.types));}</span>else {<span class="cstat-no" title="statement not covered" >return t.unionTypeAnnotation(left.types.concat(right));}</span>}</span>else {<span class="cstat-no" title="statement not covered" >return t.unionTypeAnnotation([left,right]);}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.anyTypeAnnotation();}</span>}<span class="fstat-no" title="function not covered" ></span>function getConditionalExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar consequent=getAnnotation(path.get('consequent'));<span class="cstat-no" title="statement not covered" >v</span>ar alternate=getAnnotation(path.get('alternate'));<span class="cstat-no" title="statement not covered" >i</span>f(t.isUnionTypeAnnotation(consequent)){<span class="cstat-no" title="statement not covered" >if(t.isUnionTypeAnnotation(alternate)){<span class="cstat-no" title="statement not covered" >return t.unionTypeAnnotation(consequent.types.concat(alternate.types));}</span>else {<span class="cstat-no" title="statement not covered" >return t.unionTypeAnnotation(consequent.types.concat(alternate));}</span>}</span>else {<span class="cstat-no" title="statement not covered" >return t.unionTypeAnnotation([consequent,alternate]);}</span>}<span class="fstat-no" title="function not covered" ></span>function getArrayExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>return t.genericTypeAnnotation(t.identifier('Array'),t.typeParameterDeclaration(path.get('elements').map(getAnnotation)));}<span class="fstat-no" title="function not covered" ></span>function getObjectExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var annotation=t.objectTypeAnnotation(path.get('properties').filter(<span class="fstat-no" title="function not covered" >function(prop){<span class="cstat-no" title="statement not covered" ></span>return !prop.node.computed;}</span>).map(getAnnotation).reduce(<span class="fstat-no" title="function not covered" >function(properties,prop){<span class="cstat-no" title="statement not covered" ></span>if(t.isObjectTypeProperty(prop)){<span class="cstat-no" title="statement not covered" >properties.push(prop);}</span>else <span class="cstat-no" title="statement not covered" >if(t.isObjectTypeAnnotation(prop)){<span class="cstat-no" title="statement not covered" >properties.push.apply(properties,_toConsumableArray(prop.properties));}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn properties;}</span>,[]).filter(<span class="fstat-no" title="function not covered" >function(annotation){<span class="cstat-no" title="statement not covered" ></span>return !t.isAnyTypeAnnotation(annotation.value);}</span>));<span class="cstat-no" title="statement not covered" >r</span>eturn annotation;}<span class="fstat-no" title="function not covered" ></span>function getMemberExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>if(path.node.computed){<span class="cstat-no" title="statement not covered" >return getComputedMemberExpressionAnnotation(path);}<span class="cstat-no" title="statement not covered" ></span>v</span>ar stack=[];<span class="cstat-no" title="statement not covered" >v</span>ar target=path;<span class="cstat-no" title="statement not covered" >w</span>hile(target.isMemberExpression()){<span class="cstat-no" title="statement not covered" >stack.push(target);<span class="cstat-no" title="statement not covered" >i</span>f(target.node.computed){<span class="cstat-no" title="statement not covered" >break;}<span class="cstat-no" title="statement not covered" ></span>t</span>arget=target.get('object');}<span class="cstat-no" title="statement not covered" ></span>v</span>ar objectAnnotation=stack.reduceRight(<span class="fstat-no" title="function not covered" >function(last,target){<span class="cstat-no" title="statement not covered" ></span>var annotation=last;<span class="cstat-no" title="statement not covered" >i</span>f(annotation==null){<span class="cstat-no" title="statement not covered" >if(stack.length===1){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(target.get('object'));}</span>else {<span class="cstat-no" title="statement not covered" >return getAnnotation(target);}</span>}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(annotation.type){case 'AnyTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation;c</span>ase 'NullableTypeAnnotation':case 'TypeAnnotation':<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(annotation.type==='GenericTypeAnnotation'){<span class="cstat-no" title="statement not covered" >var typeChecker=getTypeChecker(annotation.id,path.scope);<span class="cstat-no" title="statement not covered" >i</span>f(typeChecker){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(typeChecker);}</span>else <span class="cstat-no" title="statement not covered" >if(isPolymorphicType(annotation.id,path.scope)){<span class="cstat-no" title="statement not covered" >annotation=t.anyTypeAnnotation();}</span>else {<span class="cstat-no" title="statement not covered" >var binding=path.scope.getBinding(annotation.id.name);<span class="cstat-no" title="statement not covered" >i</span>f(binding){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(binding.path);}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span></span>s</span>witch(annotation.type){case 'AnyTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation;c</span>ase 'ObjectTypeAnnotation':<span class="cstat-no" title="statement not covered" >var id=target.get('property').node;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion13=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError13=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError13=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator13=(annotation.properties||[])[Symbol.iterator](),_step13;!(_iteratorNormalCompletion13=(_step13=_iterator13.next()).done);_iteratorNormalCompletion13=true){<span class="cstat-no" title="statement not covered" >var _step13$value=_step13.value;<span class="cstat-no" title="statement not covered" >v</span>ar key=_step13$value.key;<span class="cstat-no" title="statement not covered" >v</span>ar value=_step13$value.value;<span class="cstat-no" title="statement not covered" >i</span>f(key.name===id.name){<span class="cstat-no" title="statement not covered" >return value.type==='VoidTypeAnnotation'||value.type==='NullLiteralTypeAnnotation'?t.anyTypeAnnotation():value;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError13=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError13=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion13&amp;&amp;_iterator13.return){<span class="cstat-no" title="statement not covered" >_iterator13.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError13){<span class="cstat-no" title="statement not covered" >throw _iteratorError13;}</span>}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.anyTypeAnnotation();}</span>,null);<span class="cstat-no" title="statement not covered" >r</span>eturn objectAnnotation||path.getTypeAnnotation();}<span class="fstat-no" title="function not covered" ></span>function getComputedMemberExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var object=path.get('object');<span class="cstat-no" title="statement not covered" >v</span>ar property=path.get('property');<span class="cstat-no" title="statement not covered" >v</span>ar objectAnnotation=getAnnotation(object);<span class="cstat-no" title="statement not covered" >i</span>f(objectAnnotation.type==='TypeAnnotation'||objectAnnotation.type==='NullableTypeAnnotation'){<span class="cstat-no" title="statement not covered" >objectAnnotation=objectAnnotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar propertyAnnotation=getAnnotation(property);<span class="cstat-no" title="statement not covered" >i</span>f(propertyAnnotation.type==='TypeAnnotation'||propertyAnnotation.type==='NullableTypeAnnotation'){<span class="cstat-no" title="statement not covered" >propertyAnnotation=propertyAnnotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _property$evaluate=property.evaluate();<span class="cstat-no" title="statement not covered" >v</span>ar confident=_property$evaluate.confident;<span class="cstat-no" title="statement not covered" >v</span>ar value=_property$evaluate.value;<span class="cstat-no" title="statement not covered" >i</span>f(!confident){<span class="cstat-no" title="statement not covered" >return path.getTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(objectAnnotation.type){case 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(objectAnnotation.types.length===0){<span class="cstat-no" title="statement not covered" >break;}</span>else <span class="cstat-no" title="statement not covered" >if(typeof value==='number'){<span class="cstat-no" title="statement not covered" >if(!objectAnnotation.types[value]){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError('Invalid computed member expression for tuple: '+humanReadableType(objectAnnotation));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn objectAnnotation.types[value];}</span>else {<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError('Invalid computed member expression for tuple: '+humanReadableType(objectAnnotation));}<span class="cstat-no" title="statement not covered" ></span>b</span></span>reak;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn path.getTypeAnnotation();}<span class="fstat-no" title="function not covered" ></span>function getFunctionForIdentifier(path){<span class="cstat-no" title="statement not covered" ></span>if(path.type!=='Identifier'){<span class="cstat-no" title="statement not covered" >return false;}</span>else <span class="cstat-no" title="statement not covered" >if(isTypeChecker(path.node,path.scope)||isPolymorphicType(path.node,path.scope)){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar ref=path.scope.getBinding(path.node.name);<span class="cstat-no" title="statement not covered" >i</span>f(!ref){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.isFunction(ref.path.parent)&amp;&amp;ref.path.parentPath;}</span> /**
   * Determine whether the given annotation is for an array.
   */<span class="fstat-no" title="function not covered" >function isStrictlyArrayAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'ArrayTypeAnnotation':case 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return isStrictlyArrayAnnotation(annotation.typeAnnotation);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation.id.name==='Array'?true:null;c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation.types.every(isStrictlyArrayAnnotation);d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareMaybeUnion(annotation,comparator){<span class="cstat-no" title="statement not covered" ></span>var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion14=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError14=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError14=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator14=annotation.types[Symbol.iterator](),_step14;!(_iteratorNormalCompletion14=(_step14=_iterator14.next()).done);_iteratorNormalCompletion14=true){<span class="cstat-no" title="statement not covered" >var _type5=_step14.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=comparator(_type5);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError14=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError14=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion14&amp;&amp;_iterator14.return){<span class="cstat-no" title="statement not covered" >_iterator14.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError14){<span class="cstat-no" title="statement not covered" >throw _iteratorError14;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a number,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeNumberAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeNumberAnnotation(annotation.typeAnnotation);c</span>ase 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'NumericLiteral':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareMaybeUnion(annotation,maybeNumberAnnotation);c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a string,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeStringAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeStringAnnotation(annotation.typeAnnotation);c</span>ase 'StringTypeAnnotation':case 'StringLiteral':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'StringLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'Number':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion15=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError15=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError15=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator15=annotation.types[Symbol.iterator](),_step15;!(_iteratorNormalCompletion15=(_step15=_iterator15.next()).done);_iteratorNormalCompletion15=true){<span class="cstat-no" title="statement not covered" >var _type6=_step15.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeStringAnnotation(_type6);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError15=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError15=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion15&amp;&amp;_iterator15.return){<span class="cstat-no" title="statement not covered" >_iterator15.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError15){<span class="cstat-no" title="statement not covered" >throw _iteratorError15;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a symbol,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeSymbolAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeSymbolAnnotation(annotation.typeAnnotation);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'Number':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;c</span>ase 'Symbol':<span class="cstat-no" title="statement not covered" >return true;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion16=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError16=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError16=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator16=annotation.types[Symbol.iterator](),_step16;!(_iteratorNormalCompletion16=(_step16=_iterator16.next()).done);_iteratorNormalCompletion16=true){<span class="cstat-no" title="statement not covered" >var _type7=_step16.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeSymbolAnnotation(_type7);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError16=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError16=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion16&amp;&amp;_iterator16.return){<span class="cstat-no" title="statement not covered" >_iterator16.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError16){<span class="cstat-no" title="statement not covered" >throw _iteratorError16;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a boolean,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeBooleanAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeBooleanAnnotation(annotation.typeAnnotation);c</span>ase 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'BooleanLiteral':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'String':case 'Number':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion17=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError17=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError17=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator17=annotation.types[Symbol.iterator](),_step17;!(_iteratorNormalCompletion17=(_step17=_iterator17.next()).done);_iteratorNormalCompletion17=true){<span class="cstat-no" title="statement not covered" >var _type8=_step17.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeBooleanAnnotation(_type8);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError17=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError17=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion17&amp;&amp;_iterator17.return){<span class="cstat-no" title="statement not covered" >_iterator17.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError17){<span class="cstat-no" title="statement not covered" >throw _iteratorError17;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a function,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeFunctionAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeFunctionAnnotation(annotation.typeAnnotation);c</span>ase 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Number':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion18=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError18=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError18=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator18=annotation.types[Symbol.iterator](),_step18;!(_iteratorNormalCompletion18=(_step18=_iterator18.next()).done);_iteratorNormalCompletion18=true){<span class="cstat-no" title="statement not covered" >var _type9=_step18.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeFunctionAnnotation(_type9);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError18=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError18=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion18&amp;&amp;_iterator18.return){<span class="cstat-no" title="statement not covered" >_iterator18.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError18){<span class="cstat-no" title="statement not covered" >throw _iteratorError18;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with an undefined or null type,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeNullableAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'NullableTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'MixedTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return maybeNullableAnnotation(annotation.typeAnnotation);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Number':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;c</span>ase 'Generator':<span class="cstat-no" title="statement not covered" >if(annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1){<span class="cstat-no" title="statement not covered" >return maybeNullableAnnotation(annotation.typeParameters.params[1]);}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion19=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError19=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError19=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator19=annotation.types[Symbol.iterator](),_step19;!(_iteratorNormalCompletion19=(_step19=_iterator19.next()).done);_iteratorNormalCompletion19=true){<span class="cstat-no" title="statement not covered" >var _type10=_step19.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeNullableAnnotation(_type10);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError19=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError19=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion19&amp;&amp;_iterator19.return){<span class="cstat-no" title="statement not covered" >_iterator19.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError19){<span class="cstat-no" title="statement not covered" >throw _iteratorError19;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with an object type,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeInstanceOfAnnotation(annotation,expected,typeParameters){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeInstanceOfAnnotation(annotation.typeAnnotation,expected,typeParameters);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(annotation.id.name===expected.name){<span class="cstat-no" title="statement not covered" >if(typeParameters.length===0){<span class="cstat-no" title="statement not covered" >return true;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length){<span class="cstat-no" title="statement not covered" >var trueCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar nullCount=0;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;typeParameters.length&amp;&amp;i&lt;annotation.typeParameters.params.length;i++){<span class="cstat-no" title="statement not covered" >var result=compareAnnotations(typeParameters[i],annotation.typeParameters.params[i]);<span class="cstat-no" title="statement not covered" >i</span>f(result===false){<span class="cstat-no" title="statement not covered" >return false;}</span>else <span class="cstat-no" title="statement not covered" >if(result===true){<span class="cstat-no" title="statement not covered" >trueCount++;}</span>else {<span class="cstat-no" title="statement not covered" >nullCount++;}</span>}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn trueCount&gt;0&amp;&amp;nullCount===0?true:null;}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null;c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion20=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError20=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError20=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator20=annotation.types[Symbol.iterator](),_step20;!(_iteratorNormalCompletion20=(_step20=_iterator20.next()).done);_iteratorNormalCompletion20=true){<span class="cstat-no" title="statement not covered" >var _type11=_step20.value;<span class="cstat-no" title="statement not covered" >v</span>ar _result=maybeInstanceOfAnnotation(_type11,expected,typeParameters);<span class="cstat-no" title="statement not covered" >i</span>f(_result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(_result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError20=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError20=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion20&amp;&amp;_iterator20.return){<span class="cstat-no" title="statement not covered" >_iterator20.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError20){<span class="cstat-no" title="statement not covered" >throw _iteratorError20;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(expected.name==='Array'||expected.name==='RegExp'||expected.name==='Error'||expected.name==='Function'||expected.name==='String'||expected.name==='Object'){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(expected.name==='Array'||expected.name==='RegExp'||expected.name==='Error'||expected.name==='Function'){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(expected.name==='Function'){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with an array,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeArrayAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeArrayAnnotation(annotation.typeAnnotation);c</span>ase 'TupleTypeAnnotation':case 'ArrayTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation.id.name==='Array'?true:null;c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion21=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError21=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError21=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator21=annotation.types[Symbol.iterator](),_step21;!(_iteratorNormalCompletion21=(_step21=_iterator21.next()).done);_iteratorNormalCompletion21=true){<span class="cstat-no" title="statement not covered" >var _type12=_step21.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeArrayAnnotation(_type12);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError21=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError21=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion21&amp;&amp;_iterator21.return){<span class="cstat-no" title="statement not covered" >_iterator21.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError21){<span class="cstat-no" title="statement not covered" >throw _iteratorError21;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with an iterable,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeIterableAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeIterableAnnotation(annotation.typeAnnotation);c</span>ase 'TupleTypeAnnotation':case 'ArrayTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation.id.name==='Iterable'?true:null;c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion22=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError22=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError22=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator22=annotation.types[Symbol.iterator](),_step22;!(_iteratorNormalCompletion22=(_step22=_iterator22.next()).done);_iteratorNormalCompletion22=true){<span class="cstat-no" title="statement not covered" >var _type13=_step22.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeIterableAnnotation(_type13);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError22=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError22=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion22&amp;&amp;_iterator22.return){<span class="cstat-no" title="statement not covered" >_iterator22.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError22){<span class="cstat-no" title="statement not covered" >throw _iteratorError22;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a tuple,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeTupleAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeTupleAnnotation(annotation.typeAnnotation);c</span>ase 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion23=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError23=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError23=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator23=annotation.types[Symbol.iterator](),_step23;!(_iteratorNormalCompletion23=(_step23=_iterator23.next()).done);_iteratorNormalCompletion23=true){<span class="cstat-no" title="statement not covered" >var _type14=_step23.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeTupleAnnotation(_type14);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError23=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError23=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion23&amp;&amp;_iterator23.return){<span class="cstat-no" title="statement not covered" >_iterator23.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError23){<span class="cstat-no" title="statement not covered" >throw _iteratorError23;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'GenericTypeAnnotation':case 'AnyTypeAnnotation':case 'ArrayTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}<span class="fstat-no" title="function not covered" ></span>function humanReadableType(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return humanReadableType(annotation.typeAnnotation);c</span>ase 'FunctionTypeAnnotation': // @fixme babel doesn't seem to like generating FunctionTypeAnnotations yet</span>
<span class="cstat-no" title="statement not covered" >return '('+annotation.params.map(humanReadableType).join(', ')+') =&gt; '+humanReadableType(annotation.returnType);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >var path=getNodePath(annotation);<span class="cstat-no" title="statement not covered" >v</span>ar checker=path&amp;&amp;getTypeChecker(annotation.id,path.scope);<span class="cstat-no" title="statement not covered" >i</span>f(checker&amp;&amp;checker.node.savedTypeAnnotation){<span class="cstat-no" title="statement not covered" >return humanReadableType(checker.node.savedTypeAnnotation);}</span>else {<span class="cstat-no" title="statement not covered" >return (0,_babelGenerator2.default)(annotation).code;}</span>d</span>efault:<span class="cstat-no" title="statement not covered" >return (0,_babelGenerator2.default)(annotation).code;}</span>} /**
   * Get the path directly from a node.
   */<span class="fstat-no" title="function not covered" >function getNodePath(node){<span class="cstat-no" title="statement not covered" ></span>if(node._paths&amp;&amp;node._paths.length){<span class="cstat-no" title="statement not covered" >return node._paths[0];}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function getTypeChecker(id,scope){<span class="cstat-no" title="statement not covered" ></span>var checker=scope.getData('typechecker:'+id.name);<span class="cstat-no" title="statement not covered" >i</span>f(checker){<span class="cstat-no" title="statement not covered" >return checker;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}<span class="fstat-no" title="function not covered" ></span>function isTypeChecker(id,scope){<span class="cstat-no" title="statement not covered" ></span>return scope.getData('typechecker:'+id.name)!==undefined;}<span class="fstat-no" title="function not covered" ></span>function isPolymorphicType(id,scope){<span class="cstat-no" title="statement not covered" ></span>return scope.getData('typeparam:'+id.name)!==undefined;}<span class="fstat-no" title="function not covered" ></span>function getPolymorphicType(id,scope){<span class="cstat-no" title="statement not covered" ></span>var path=scope.getData('typeparam:'+id.name);<span class="cstat-no" title="statement not covered" >i</span>f(path){<span class="cstat-no" title="statement not covered" >return path.node;}</span>}<span class="fstat-no" title="function not covered" ></span>function collectParamChecks(path,context){<span class="cstat-no" title="statement not covered" ></span>return path.get('params').map(<span class="fstat-no" title="function not covered" >function(param){<span class="cstat-no" title="statement not covered" ></span>var node=param.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='AssignmentPattern'){<span class="cstat-no" title="statement not covered" >if(node.left.typeAnnotation){<span class="cstat-no" title="statement not covered" >return createDefaultParamGuard(param,context);}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='RestElement'){<span class="cstat-no" title="statement not covered" >if(node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return createRestParamGuard(param,context);}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return createParamGuard(param,context);}</span>}</span></span></span>).filter(identity);}<span class="fstat-no" title="function not covered" ></span>function createParamGuard(path,context){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >n</span>ode.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >n</span>ode.savedTypeAnnotation=node.typeAnnotation;<span class="cstat-no" title="statement not covered" >v</span>ar checkable=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='ObjectPattern'){<span class="cstat-no" title="statement not covered" >node.name=path.key;<span class="cstat-no" title="statement not covered" >c</span>heckable=t.memberExpression(t.identifier('arguments'),t.numericLiteral(path.key),true);}</span>else {<span class="cstat-no" title="statement not covered" >checkable=node;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar check=checkAnnotation(checkable,node.typeAnnotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!check){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.optional){<span class="cstat-no" title="statement not covered" >check=t.logicalExpression('||',checks.undefined({input:checkable}),check);}<span class="cstat-no" title="statement not covered" ></span>v</span>ar message=paramTypeErrorMessage(checkable,context,node.typeAnnotation);<span class="cstat-no" title="statement not covered" >r</span>eturn guard({check:check,message:message});}<span class="fstat-no" title="function not covered" ></span>function createDefaultParamGuard(path,context){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.left;<span class="cstat-no" title="statement not covered" >v</span>ar value=node.right;<span class="cstat-no" title="statement not covered" >v</span>ar ok=staticCheckAnnotation(path.get('right'),id.typeAnnotation);<span class="cstat-no" title="statement not covered" >i</span>f(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid default value for argument "'+id.name+'".',id.typeAnnotation,getAnnotation(path.get('right'))));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn createParamGuard(path.get('left'),context);}<span class="fstat-no" title="function not covered" ></span>function createRestParamGuard(path,context){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.argument;<span class="cstat-no" title="statement not covered" >i</span>d.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >n</span>ode.savedTypeAnnotation=node.typeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(isStrictlyArrayAnnotation(node.typeAnnotation)===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid type annotation for rest argument "'+id.name+'".',t.genericTypeAnnotation(t.identifier('Array')),node.typeAnnotation));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar check=checkAnnotation(id,node.typeAnnotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!check){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.optional){<span class="cstat-no" title="statement not covered" >check=t.logicalExpression('||',checks.undefined({input:id}),check);}<span class="cstat-no" title="statement not covered" ></span>v</span>ar message=paramTypeErrorMessage(id,context,node.typeAnnotation);<span class="cstat-no" title="statement not covered" >r</span>eturn guard({check:check,message:message});}<span class="fstat-no" title="function not covered" ></span>function returnTypeErrorMessage(path,fn,id,context){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar name=fn.id?fn.id.name:'';<span class="cstat-no" title="statement not covered" >v</span>ar annotation=fn.returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(fn.generator&amp;&amp;isGeneratorAnnotation(annotation)&amp;&amp;annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters.params[1];}<span class="cstat-no" title="statement not covered" ></span>v</span>ar message='Function '+(name?'"'+name+'" ':'')+'return value violates contract.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn t.binaryExpression('+',t.stringLiteral(message),id?readableName({inspect:context.inspect,input:id}):node.argument?readableName({inspect:context.inspect,input:node.argument}):t.stringLiteral('undefined'));}<span class="fstat-no" title="function not covered" ></span>function yieldTypeErrorMessage(fn,annotation,id,context){<span class="cstat-no" title="statement not covered" ></span>var name=fn.id?fn.id.name:'';<span class="cstat-no" title="statement not covered" >v</span>ar message='Function '+(name?'"'+name+'" ':'')+'yielded an invalid value.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:id}));}<span class="fstat-no" title="function not covered" ></span>function yieldNextTypeErrorMessage(fn,annotation,id,context){<span class="cstat-no" title="statement not covered" ></span>var name=fn.id?fn.id.name:'';<span class="cstat-no" title="statement not covered" >v</span>ar message='Generator '+(name?'"'+name+'" ':'')+'received an invalid next value.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:id}));}<span class="fstat-no" title="function not covered" ></span>function paramTypeErrorMessage(node,context){<span class="cstat-no" title="statement not covered" ></span>var typeAnnotation=arguments.length&lt;=2||arguments[2]===undefined?node.typeAnnotation:arguments[2];<span class="cstat-no" title="statement not covered" >v</span>ar name=node.name;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='MemberExpression'&amp;&amp;node.object.name==='arguments'){<span class="cstat-no" title="statement not covered" >name=node.property.value;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar message='Value of '+(node.optional?'optional ':'')+'argument '+JSON.stringify(name)+' violates contract.\n\nExpected:\n'+humanReadableType(typeAnnotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:node}));}<span class="fstat-no" title="function not covered" ></span>function varTypeErrorMessage(node,context){<span class="cstat-no" title="statement not covered" ></span>var annotation=node.typeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='Identifier'){<span class="cstat-no" title="statement not covered" >var _name3=node.name;<span class="cstat-no" title="statement not covered" >v</span>ar message='Value of variable "'+_name3+'" violates contract.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:node}));}</span>else {<span class="cstat-no" title="statement not covered" >var _message='Value of "'+humanReadableType(node)+'" violates contract.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn t.binaryExpression('+',t.stringLiteral(_message),readableName({inspect:context.inspect,input:node}));}</span>}</span> /**
   * Create a React property validator
   */<span class="fstat-no" title="function not covered" >function generatePropType(annotation,scope,context){<span class="cstat-no" title="statement not covered" ></span>var prop=t.identifier('prop');<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(prop,annotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >return propType({check:check,prop:prop,expected:t.stringLiteral(humanReadableType(annotation)),got:readableName({inspect:context.inspect,input:prop})});}</span>else {<span class="cstat-no" title="statement not covered" >return t.functionExpression(null,[],t.blockStatement([]));}</span>}</span> /**
   * Determine whether the given node can produce purely boolean results.
   */<span class="fstat-no" title="function not covered" >function isBooleanExpression(node){<span class="cstat-no" title="statement not covered" ></span>if(node.type==='BinaryExpression'&amp;&amp;BOOLEAN_BINARY_OPERATORS.indexOf(node.operator)&gt;-1){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='LogicalExpression'){<span class="cstat-no" title="statement not covered" >return isBooleanExpression(node.left)&amp;&amp;isBooleanExpression(node.right);}</span>else {<span class="cstat-no" title="statement not covered" >return false;}</span>}</span></span> /**
   * Convert type specifier to expression.
   */<span class="fstat-no" title="function not covered" >function createTypeExpression(node){<span class="cstat-no" title="statement not covered" ></span>if(node.type=='Identifier'){<span class="cstat-no" title="statement not covered" >return node;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type=='QualifiedTypeIdentifier'){<span class="cstat-no" title="statement not covered" >return t.memberExpression(createTypeExpression(node.qualification),createTypeExpression(node.id));}<span class="cstat-no" title="statement not covered" ></span>t</span></span>hrow this.errorWithNode('Unsupported type: '+node.type);}</span> /**
   * Get name of a type as a string.
   */<span class="fstat-no" title="function not covered" >function getTypeName(node){<span class="cstat-no" title="statement not covered" ></span>if(node.type=='Identifier'){<span class="cstat-no" title="statement not covered" >return node.name;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type=='QualifiedTypeIdentifier'){<span class="cstat-no" title="statement not covered" >return getTypeName(node.qualification)+'.'+getTypeName(node.id);}<span class="cstat-no" title="statement not covered" ></span>t</span></span>hrow this.errorWithNode('Unsupported type: '+node.type);}</span> /**
   * Union two arrays.
   */<span class="fstat-no" title="function not covered" >function union(arr1,arr2){<span class="cstat-no" title="statement not covered" ></span>for(var i=0;i&lt;arr2.length;i++){<span class="cstat-no" title="statement not covered" >var item=arr2[i];<span class="cstat-no" title="statement not covered" >i</span>f(arr1.indexOf(item)===-1){<span class="cstat-no" title="statement not covered" >arr1.push(item);}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn arr1;}</span> /**
   * Determine whether the given annotation allows any value.
   */<span class="fstat-no" title="function not covered" >function allowsAny(annotation){<span class="cstat-no" title="statement not covered" ></span>if(annotation.type==='TypeAnnotation'||annotation.type==='NullableTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return allowsAny(annotation.typeAnnotation);}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.type==='AnyTypeAnnotation'||annotation.type==='MixedTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.type==='UnionTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return annotation.types.some(allowsAny);}</span>else {<span class="cstat-no" title="statement not covered" >return false;}</span>}</span></span></span> /**
   * Determine whether a given node is nully (null or undefined).
   */<span class="fstat-no" title="function not covered" >function isNodeNully(node){<span class="cstat-no" title="statement not covered" ></span>if(node==null){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='Identifier'&amp;&amp;node.name==='undefined'){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='Literal'&amp;&amp;node.value===null){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='UnaryExpression'&amp;&amp;node.operator==='void'){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return false;}</span>}</span></span></span></span> /**
   * Determine whether the file should be checked
   */<span class="fstat-no" title="function not covered" >function mustCheckFile(path,opts){<span class="cstat-no" title="statement not covered" ></span>if(path.node.leadingComments&amp;&amp;path.node.leadingComments.length){<span class="cstat-no" title="statement not covered" >return opts.only&amp;&amp;!skipEnvironment(path.node.leadingComments,opts);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}</span> /**
   * Determine whether the file should be skipped, based on the comments attached to the given node.
   */<span class="fstat-no" title="function not covered" >function maybeSkipFile(path,opts){<span class="cstat-no" title="statement not covered" ></span>if(path.node.leadingComments&amp;&amp;path.node.leadingComments.length){<span class="cstat-no" title="statement not covered" >if(skipEnvironment(path.node.leadingComments,opts)){<span class="cstat-no" title="statement not covered" >return true;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn path.node.leadingComments.some(<span class="fstat-no" title="function not covered" >function(comment){<span class="cstat-no" title="statement not covered" ></span>return PRAGMA_IGNORE_FILE.test(comment.value);}</span>);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}</span> /**
   * Maybe skip the given path if it has a relevant pragma.
   */<span class="fstat-no" title="function not covered" >function maybeSkip(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.hasBeenTypeChecked){<span class="cstat-no" title="statement not covered" >return true;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.leadingComments&amp;&amp;node.leadingComments.length){<span class="cstat-no" title="statement not covered" >var comment=node.leadingComments[node.leadingComments.length-1];<span class="cstat-no" title="statement not covered" >i</span>f(PRAGMA_IGNORE_STATEMENT.test(comment.value)){<span class="cstat-no" title="statement not covered" >path.skip();<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}</span> /**
   * A function that returns its first argument, useful when filtering.
   */<span class="fstat-no" title="function not covered" >function identity(input){<span class="cstat-no" title="statement not covered" ></span>return input;}<span class="fstat-no" title="function not covered" ></span>function getExpression(node){<span class="cstat-no" title="statement not covered" ></span>return t.isExpressionStatement(node)?node.expression:node;}<span class="fstat-no" title="function not covered" ></span>function expression(input){<span class="cstat-no" title="statement not covered" ></span>var fn=template(input);<span class="cstat-no" title="statement not covered" >r</span>eturn <span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var node=fn.apply(undefined,arguments);<span class="cstat-no" title="statement not covered" >r</span>eturn getExpression(node);}</span>;}</span>};var _babelGenerator=require('babel-generator');var _babelGenerator2=_interopRequireDefault(_babelGenerator);function _interopRequireDefault(obj){return obj&amp;&amp;obj.__esModule?obj:<span class="branch-1 cbranch-no" title="branch not covered" >{default:obj};</span>}<span class="fstat-no" title="function not covered" >function _toConsumableArray(arr){<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(arr)){<span class="cstat-no" title="statement not covered" >for(var i=0,arr2=Array(arr.length);i&lt;arr.length;i++){<span class="cstat-no" title="statement not covered" >arr2[i]=arr[i];}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn arr2;}</span>else {<span class="cstat-no" title="statement not covered" >return Array.from(arr);}</span>}</span>
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 23:52:58 GMT+0000 (UTC)</div>
</div>
</body>
</html>


<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/inferers.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header low">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-babel-plugin-typecheck">npmtest-babel-plugin-typecheck (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/inferers.js</span></h1>
    <h2>
        
        Statements: <span class="metric">12.68% <small>(9 / 71)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">0% <small>(0 / 26)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">9.09% <small>(1 / 11)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">14.89% <small>(7 / 47)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../../../../index.html">All files</a> &#187; <a href="index.html">node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/</a> &#187; inferers.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97</td><td class="line-coverage"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">'use strict';
&nbsp;
Object.defineProperty(exports, "__esModule", {
  value: true
});
&nbsp;
var _slicedToArray = function () { <span class="fstat-no" title="function not covered" >function sliceIterator(arr, i) {</span> <span class="cstat-no" title="statement not covered" >var _arr = []; <span class="cstat-no" title="statement not covered" ></span>var _n = true; <span class="cstat-no" title="statement not covered" ></span>var _d = false; <span class="cstat-no" title="statement not covered" ></span>var _e = undefined; <span class="cstat-no" title="statement not covered" ></span>try { <span class="cstat-no" title="statement not covered" >for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { <span class="cstat-no" title="statement not covered" >_arr.push(_s.value); <span class="cstat-no" title="statement not covered" ></span>if (i &amp;&amp; _arr.length === i) <span class="cstat-no" title="statement not covered" >break; </span></span>} </span>} catch (err) { <span class="cstat-no" title="statement not covered" >_d = true; <span class="cstat-no" title="statement not covered" ></span>_e = err; </span>} finally { <span class="cstat-no" title="statement not covered" >try { <span class="cstat-no" title="statement not covered" >if (!_n &amp;&amp; _i["return"]) <span class="cstat-no" title="statement not covered" >_i["return"](); </span></span>} finally { <span class="cstat-no" title="statement not covered" >if (_d) <span class="cstat-no" title="statement not covered" >throw _e; </span></span>} </span>} <span class="cstat-no" title="statement not covered" ></span>return _arr; </span>} return <span class="fstat-no" title="function not covered" >function (arr, i) {</span> <span class="cstat-no" title="statement not covered" >if (Array.isArray(arr)) { <span class="cstat-no" title="statement not covered" >return arr; </span>} else <span class="cstat-no" title="statement not covered" >if (Symbol.iterator in Object(arr)) { <span class="cstat-no" title="statement not covered" >return sliceIterator(arr, i); </span>} else { <span class="cstat-no" title="statement not covered" >throw new TypeError("Invalid attempt to destructure non-iterable instance"); </span>} </span></span>}; }();
&nbsp;
exports.default = make;
/**
 * Register the builtin type inferers and return a function which can infer the type of
 * a given node path.
 */
<span class="fstat-no" title="function not covered" >function make(_ref) {</span>
<span class="cstat-no" title="statement not covered" >  var t = _ref.types;</span>
<span class="cstat-no" title="statement not covered" >  var template = _ref.template;</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >  var INFERENCE_TYPES = {};</span>
&nbsp;
  /**
   * Register a new type inference for the given node type.
   */
<span class="fstat-no" title="function not covered" >  function register(type, fn) {</span>
<span class="cstat-no" title="statement not covered" >    INFERENCE_TYPES[type] = fn;</span>
  }
&nbsp;
  /**
   * Infer the type of the given node path and return an annotation.
   */
<span class="fstat-no" title="function not covered" >  function inferType(path) {</span>
<span class="cstat-no" title="statement not covered" >    var inferer = INFERENCE_TYPES[path.type];</span>
<span class="cstat-no" title="statement not covered" >    if (inferer) {</span>
<span class="cstat-no" title="statement not covered" >      return inferer(path);</span>
    } else {
<span class="cstat-no" title="statement not covered" >      console.log('Unsupported Type: ' + path.type);</span>
<span class="cstat-no" title="statement not covered" >      return path.getTypeAnnotation() || t.anyTypeAnnotation();</span>
    }
  }
&nbsp;
<span class="fstat-no" title="function not covered" >  function lookupGlobalIdentifier(name) {</span>
<span class="cstat-no" title="statement not covered" >    switch (name) {</span>
      case 'Symbol':
<span class="cstat-no" title="statement not covered" >        return t.functionTypeAnnotation(null, [], null, t.anyTypeAnnotation());</span>
<span class="cstat-no" title="statement not covered" >        return t.functionTypeAnnotation(null, [t.functionTypeParam(t.identifier('key'), t.stringTypeAnnotation())], null, t.anyTypeAnnotation() //t.genericTypeAnnotation(t.identifier('Symbol'))</span>
        );
      default:
<span class="cstat-no" title="statement not covered" >        return t.anyTypeAnnotation();</span>
    }
  }
&nbsp;
<span class="cstat-no" title="statement not covered" >  register('ObjectExpression', <span class="fstat-no" title="function not covered" >function (path) {</span></span>
<span class="cstat-no" title="statement not covered" >    var _path$get$reduce = path.get('properties').reduce(<span class="fstat-no" title="function not covered" >function (_ref2, prop) {</span></span>
<span class="cstat-no" title="statement not covered" >      var _ref3 = _slicedToArray(_ref2, 2);</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >      var properties = _ref3[0];</span>
<span class="cstat-no" title="statement not covered" >      var indexers = _ref3[1];</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >      if (prop.node.computed) {</span>
<span class="cstat-no" title="statement not covered" >        var keyType = inferType(prop.get('key'));</span>
<span class="cstat-no" title="statement not covered" >        if (keyType.type === 'AnyTypeAnnotation') {</span>
<span class="cstat-no" title="statement not covered" >          keyType = t.stringTypeAnnotation();</span>
        }
<span class="cstat-no" title="statement not covered" >        indexers.push(t.objectTypeIndexer(t.identifier('key'), keyType, inferType(prop.get('value'))));</span>
      } else {
<span class="cstat-no" title="statement not covered" >        properties.push(t.objectTypeProperty(prop.node.key, inferType(prop.get('value'))));</span>
      }
<span class="cstat-no" title="statement not covered" >      return [properties, indexers];</span>
    }, [[], []]);
&nbsp;
<span class="cstat-no" title="statement not covered" >    var _path$get$reduce2 = _slicedToArray(_path$get$reduce, 2);</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >    var properties = _path$get$reduce2[0];</span>
<span class="cstat-no" title="statement not covered" >    var indexers = _path$get$reduce2[1];</span>
&nbsp;
&nbsp;
<span class="cstat-no" title="statement not covered" >    return t.objectTypeAnnotation(properties, indexers);</span>
  });
&nbsp;
<span class="cstat-no" title="statement not covered" >  register('CallExpression', <span class="fstat-no" title="function not covered" >function (path) {</span></span>
<span class="cstat-no" title="statement not covered" >    var callee = path.get('callee');</span>
<span class="cstat-no" title="statement not covered" >    var annotation = inferType(callee);</span>
<span class="cstat-no" title="statement not covered" >    dump(annotation);</span>
<span class="cstat-no" title="statement not covered" >    return t.anyTypeAnnotation();</span>
  });
&nbsp;
<span class="cstat-no" title="statement not covered" >  register('Identifier', <span class="fstat-no" title="function not covered" >function (path) {</span></span>
<span class="cstat-no" title="statement not covered" >    var binding = path.scope.getBinding(path.node.name);</span>
<span class="cstat-no" title="statement not covered" >    if (!binding) {</span>
<span class="cstat-no" title="statement not covered" >      return lookupGlobalIdentifier(path.node.name);</span>
    } else {
<span class="cstat-no" title="statement not covered" >      console.log(binding);</span>
    }
  });
&nbsp;
<span class="cstat-no" title="statement not covered" >  return inferType;</span>
}
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 23:52:58 GMT+0000 (UTC)</div>
</div>
</body>
</html>


<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/old_index.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header low">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-babel-plugin-typecheck">npmtest-babel-plugin-typecheck (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/old_index.js</span></h1>
    <h2>
        
        Statements: <span class="metric">5.92% <small>(116 / 1961)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">0.19% <small>(3 / 1584)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">1.16% <small>(2 / 172)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">86.49% <small>(32 / 37)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../../../../index.html">All files</a> &#187; <a href="index.html">node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/</a> &#187; old_index.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77</td><td class="line-coverage"><span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _slicedToArray=function(){<span class="fstat-no" title="function not covered" >function sliceIterator(arr,i){<span class="cstat-no" title="statement not covered" ></span>var _arr=[];<span class="cstat-no" title="statement not covered" >v</span>ar _n=true;<span class="cstat-no" title="statement not covered" >v</span>ar _d=false;<span class="cstat-no" title="statement not covered" >v</span>ar _e=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){<span class="cstat-no" title="statement not covered" >_arr.push(_s.value);<span class="cstat-no" title="statement not covered" >i</span>f(i&amp;&amp;_arr.length===i)<span class="cstat-no" title="statement not covered" >break;}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_d=true;<span class="cstat-no" title="statement not covered" >_</span>e=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_n&amp;&amp;_i["return"])<span class="cstat-no" title="statement not covered" >_i["return"]();}</span></span>finally {<span class="cstat-no" title="statement not covered" >if(_d)<span class="cstat-no" title="statement not covered" >throw _e;}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _arr;}</span>return <span class="fstat-no" title="function not covered" >function(arr,i){<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(arr)){<span class="cstat-no" title="statement not covered" >return arr;}</span>else <span class="cstat-no" title="statement not covered" >if(Symbol.iterator in Object(arr)){<span class="cstat-no" title="statement not covered" >return sliceIterator(arr,i);}</span>else {<span class="cstat-no" title="statement not covered" >throw new TypeError("Invalid attempt to destructure non-iterable instance");}</span>}</span></span>;}(); /**
 * # Typecheck Transformer
 */exports.default=<span class="fstat-no" title="function not covered" >function(_ref){<span class="cstat-no" title="statement not covered" ></span>var t=_ref.types;<span class="cstat-no" title="statement not covered" >v</span>ar template=_ref.template; </span>/**
   * Binary Operators that can only produce boolean results.
   */<span class="cstat-no" title="statement not covered" >var BOOLEAN_BINARY_OPERATORS=['==','===','&gt;=','&lt;=','&gt;','&lt;','instanceof'];<span class="cstat-no" title="statement not covered" >v</span>ar checks=createChecks();<span class="cstat-no" title="statement not covered" >v</span>ar staticChecks=createStaticChecks();<span class="cstat-no" title="statement not covered" >v</span>ar checkIsArray=expression('Array.isArray(input)');<span class="cstat-no" title="statement not covered" >v</span>ar checkIsMap=expression('input instanceof Map');<span class="cstat-no" title="statement not covered" >v</span>ar checkIsSet=expression('input instanceof Set');<span class="cstat-no" title="statement not covered" >v</span>ar checkIsClass=expression('typeof input === \'function\' &amp;&amp; input.prototype &amp;&amp; input.prototype.constructor === input');<span class="cstat-no" title="statement not covered" >v</span>ar checkIsGenerator=expression('typeof input === \'function\' &amp;&amp; input.generator');<span class="cstat-no" title="statement not covered" >v</span>ar checkIsIterable=expression('input &amp;&amp; (typeof input[Symbol.iterator] === \'function\' || Array.isArray(input))');<span class="cstat-no" title="statement not covered" >v</span>ar checkIsObject=expression('input != null &amp;&amp; typeof input === \'object\'');<span class="cstat-no" title="statement not covered" >v</span>ar checkNotNull=expression('input != null');<span class="cstat-no" title="statement not covered" >v</span>ar checkEquals=expression('input === expected');<span class="cstat-no" title="statement not covered" >v</span>ar declareTypeChecker=template('\n    const id = (function () {\n      function id (input) {\n        return check;\n      };\n      Object.defineProperty(id, Symbol.hasInstance, {\n        value: function (input) {\n          return id(input);\n        }\n      });\n      return id;\n    })();\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar guard=template('\n    if (!check) {\n      throw new TypeError(message);\n    }\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar thrower=template('\n    if (check) {\n      ret;\n    }\n    else {\n      throw new TypeError(message);\n    }\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar guardInline=expression('\n    (id =&gt; {\n      if (!check) {\n        throw new TypeError(message);\n      }\n      return id;\n    })(input)\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar guardFn=expression('\n    function name (id) {\n      if (!check) {\n        throw new TypeError(message);\n      }\n      return id;\n    }\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar readableName=expression('\n    inspect(input)\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar checkMapKeys=expression('\n    input instanceof Map &amp;&amp; Array.from(input.keys()).every(key =&gt; keyCheck)\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar checkMapValues=expression('\n    input instanceof Map &amp;&amp; Array.from(input.values()).every(value =&gt; valueCheck)\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar checkMapEntries=expression('\n    input instanceof Map &amp;&amp; Array.from(input).every(([key, value]) =&gt; keyCheck &amp;&amp; valueCheck)\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar checkSetEntries=expression('\n    input instanceof Set &amp;&amp; Array.from(input).every(value =&gt; valueCheck)\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar checkObjectIndexers=expression('\n    Object.keys(input).every(key =&gt; {\n      const value = input[key];\n      if (~fixedKeys.indexOf(key)) {\n        return true;\n      }\n      else {\n        return check;\n      }\n    });\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar checkObjectIndexersNoFixed=expression('\n    Object.keys(input).every(key =&gt; {\n      const value = input[key];\n      return check;\n    });\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar propType=expression('\n    (function(props, name, component) {\n      var prop = props[name];\n      if(!check) {\n        return new Error(\n          "Invalid prop `" + name + "` supplied to `" + component\n          + "`.\\n\\nExpected:\\n" + expected + "\\n\\nGot:\\n" + got + "\\n\\n"\n        );\n      }\n    })\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar PRAGMA_IGNORE_STATEMENT=/typecheck:\s*ignore\s+statement/i;<span class="cstat-no" title="statement not covered" >v</span>ar PRAGMA_IGNORE_FILE=/typecheck:\s*ignore\s+file/i;<span class="fstat-no" title="function not covered" >f</span>unction skipEnvironment(comments,opts){<span class="cstat-no" title="statement not covered" ></span>if(!opts.only){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar envs=pragmaEnvironments(comments);<span class="cstat-no" title="statement not covered" >r</span>eturn !opts.only.some(<span class="fstat-no" title="function not covered" >function(env){<span class="cstat-no" title="statement not covered" ></span>return envs[env];}</span>);}<span class="fstat-no" title="function not covered" ></span>function pragmaEnvironments(comments){<span class="cstat-no" title="statement not covered" ></span>var pragma=/@typecheck:\s*(.+)/;<span class="cstat-no" title="statement not covered" >v</span>ar environments={};<span class="cstat-no" title="statement not covered" >c</span>omments.forEach(<span class="fstat-no" title="function not covered" >function(comment){<span class="cstat-no" title="statement not covered" ></span>var m=comment.value.match(pragma);<span class="cstat-no" title="statement not covered" >i</span>f(m){<span class="cstat-no" title="statement not covered" >m[1].split(',').forEach(<span class="fstat-no" title="function not covered" >function(env){<span class="cstat-no" title="statement not covered" ></span>return environments[env.trim()]=true;}</span>);}</span>}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn environments;}<span class="cstat-no" title="statement not covered" ></span>var visitors={Statement:<span class="fstat-no" title="function not covered" >function Statement(path){<span class="cstat-no" title="statement not covered" ></span>maybeSkip(path);}</span>,TypeAlias:<span class="fstat-no" title="function not covered" >function TypeAlias(path){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.replaceWith(createTypeAliasChecks(path));}</span>,InterfaceDeclaration:<span class="fstat-no" title="function not covered" >function InterfaceDeclaration(path){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.replaceWith(createInterfaceChecks(path));}</span>,ExportNamedDeclaration:<span class="fstat-no" title="function not covered" >function ExportNamedDeclaration(path){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >i</span>f(node.declaration&amp;&amp;node.declaration.type==='TypeAlias'){<span class="cstat-no" title="statement not covered" >path.replaceWith(t.exportNamedDeclaration(createTypeAliasChecks(path.get('declaration')),[],null));}</span>}</span>,ImportDeclaration:<span class="fstat-no" title="function not covered" >function ImportDeclaration(path){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(path.node.importKind!=='type'){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _path$get$map$reduce=path.get('specifiers').map(<span class="fstat-no" title="function not covered" >function(specifier){<span class="cstat-no" title="statement not covered" ></span>var local=specifier.get('local');<span class="cstat-no" title="statement not covered" >v</span>ar tmpId=path.scope.generateUidIdentifierBasedOnNode(local.node);<span class="cstat-no" title="statement not covered" >v</span>ar replacement=t.importSpecifier(tmpId,specifier.node.imported);<span class="cstat-no" title="statement not covered" >v</span>ar id=t.identifier(local.node.name);<span class="cstat-no" title="statement not covered" >i</span>d.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >v</span>ar declarator=t.variableDeclarator(id,tmpId);<span class="cstat-no" title="statement not covered" >d</span>eclarator.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >r</span>eturn [declarator,replacement];}</span>).reduce(<span class="fstat-no" title="function not covered" >function(_ref2,_ref3){<span class="cstat-no" title="statement not covered" ></span>var _ref5=_slicedToArray(_ref2,2);<span class="cstat-no" title="statement not covered" >v</span>ar declarators=_ref5[0];<span class="cstat-no" title="statement not covered" >v</span>ar specifiers=_ref5[1];<span class="cstat-no" title="statement not covered" >v</span>ar _ref4=_slicedToArray(_ref3,2);<span class="cstat-no" title="statement not covered" >v</span>ar declarator=_ref4[0];<span class="cstat-no" title="statement not covered" >v</span>ar specifier=_ref4[1];<span class="cstat-no" title="statement not covered" >d</span>eclarators.push(declarator);<span class="cstat-no" title="statement not covered" >s</span>pecifiers.push(specifier);<span class="cstat-no" title="statement not covered" >r</span>eturn [declarators,specifiers];}</span>,[[],[]]);<span class="cstat-no" title="statement not covered" >v</span>ar _path$get$map$reduce2=_slicedToArray(_path$get$map$reduce,2);<span class="cstat-no" title="statement not covered" >v</span>ar declarators=_path$get$map$reduce2[0];<span class="cstat-no" title="statement not covered" >v</span>ar specifiers=_path$get$map$reduce2[1];<span class="cstat-no" title="statement not covered" >v</span>ar declaration=t.variableDeclaration('var',declarators);<span class="cstat-no" title="statement not covered" >d</span>eclaration.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >p</span>ath.replaceWithMultiple([t.importDeclaration(specifiers,path.node.source),declaration]);}</span>,ArrowFunctionExpression:<span class="fstat-no" title="function not covered" >function ArrowFunctionExpression(path){</span> // Look for destructuring args with annotations.</span>
<span class="cstat-no" title="statement not covered" >var params=path.get('params');<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator=params[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){<span class="cstat-no" title="statement not covered" >var param=_step.value;<span class="cstat-no" title="statement not covered" >i</span>f(param.isObjectPattern()&amp;&amp;param.node.typeAnnotation){<span class="cstat-no" title="statement not covered" >var _path$get=path.get('body');<span class="cstat-no" title="statement not covered" >v</span>ar _scope=_path$get.scope;<span class="cstat-no" title="statement not covered" >v</span>ar _id=_scope.generateUidIdentifier('arg'+param.key);<span class="cstat-no" title="statement not covered" >v</span>ar pattern=param.node;<span class="cstat-no" title="statement not covered" >p</span>aram.replaceWith(_id);<span class="cstat-no" title="statement not covered" >i</span>f(path.node.expression){<span class="cstat-no" title="statement not covered" >var block=t.blockStatement([t.variableDeclaration('var',[t.variableDeclarator(pattern,_id)]),t.returnStatement(path.get('body').node)]);<span class="cstat-no" title="statement not covered" >p</span>ath.node.body=block;<span class="cstat-no" title="statement not covered" >p</span>ath.node.expression=false;}</span>else {<span class="cstat-no" title="statement not covered" >path.get('body.body')[0].insertBefore(t.variableDeclaration('var',[t.variableDeclarator(pattern,_id)]));}</span>}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion&amp;&amp;_iterator.return){<span class="cstat-no" title="statement not covered" >_iterator.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError){<span class="cstat-no" title="statement not covered" >throw _iteratorError;}</span>}</span>}</span>}</span>,Function:{enter:<span class="fstat-no" title="function not covered" >function enter(path,context){<span class="cstat-no" title="statement not covered" ></span>var _node$body$body;<span class="cstat-no" title="statement not covered" >i</span>f(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar paramChecks=collectParamChecks(path,context);<span class="cstat-no" title="statement not covered" >i</span>f(node.type==="ArrowFunctionExpression"&amp;&amp;node.expression){<span class="cstat-no" title="statement not covered" >node.expression=false;<span class="cstat-no" title="statement not covered" >n</span>ode.body=t.blockStatement([t.returnStatement(node.body)]);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.returnType){<span class="cstat-no" title="statement not covered" >createFunctionReturnGuard(path,context);<span class="cstat-no" title="statement not covered" >c</span>reateFunctionYieldGuards(path,context);}<span class="cstat-no" title="statement not covered" ></span>(</span>_node$body$body=node.body.body).unshift.apply(_node$body$body,_toConsumableArray(paramChecks));<span class="cstat-no" title="statement not covered" >n</span>ode.savedTypeAnnotation=node.returnType;<span class="cstat-no" title="statement not covered" >n</span>ode.returnCount=0;<span class="cstat-no" title="statement not covered" >n</span>ode.yieldCount=0;}</span>,exit:<span class="fstat-no" title="function not covered" >function exit(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar isVoid=node.savedTypeAnnotation?maybeNullableAnnotation(node.savedTypeAnnotation):null;<span class="cstat-no" title="statement not covered" >i</span>f(!node.returnCount&amp;&amp;isVoid===false){<span class="cstat-no" title="statement not covered" >var annotation=node.savedTypeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.generator&amp;&amp;isGeneratorAnnotation(annotation)&amp;&amp;annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters.params[1];}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow path.buildCodeFrameError(buildErrorMessage('Function '+(node.id?'"'+node.id.name+'" ':'')+'did not return a value.',annotation));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.nextGuardCount){<span class="cstat-no" title="statement not covered" >path.get('body').get('body')[0].insertBefore(node.nextGuard);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.yieldGuardCount){<span class="cstat-no" title="statement not covered" >path.get('body').get('body')[0].insertBefore(node.yieldGuard);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.returnGuardCount){<span class="cstat-no" title="statement not covered" >path.get('body').get('body')[0].insertBefore(node.returnGuard);}</span>}</span>},YieldExpression:<span class="fstat-no" title="function not covered" >function YieldExpression(path,context){<span class="cstat-no" title="statement not covered" ></span>var fn=path.getFunctionParent();<span class="cstat-no" title="statement not covered" >i</span>f(!fn){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>f</span>n.node.yieldCount++;<span class="cstat-no" title="statement not covered" >i</span>f(!isGeneratorAnnotation(fn.node.returnType)||maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar parent=path.parent;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=fn.node.returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='NullableTypeAnnotation'||annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!annotation.typeParameters||annotation.typeParameters.params.length===0){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar yieldType=annotation.typeParameters.params[0];<span class="cstat-no" title="statement not covered" >v</span>ar nextType=annotation.typeParameters.params[2];<span class="cstat-no" title="statement not covered" >v</span>ar ok=staticCheckAnnotation(path.get("argument"),yieldType);<span class="cstat-no" title="statement not covered" >i</span>f(ok===true&amp;&amp;!nextType){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'"'+fn.node.id.name+'" ':'')+'yielded an invalid type.',yieldType,getAnnotation(path.get('argument'))));}<span class="cstat-no" title="statement not covered" ></span>f</span></span>n.node.yieldGuardCount++;<span class="cstat-no" title="statement not covered" >i</span>f(fn.node.yieldGuard){<span class="cstat-no" title="statement not covered" >var _yielder=t.yieldExpression(t.callExpression(fn.node.yieldGuardName,[node.argument||t.identifier('undefined')]));<span class="cstat-no" title="statement not covered" >_</span>yielder.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >i</span>f(fn.node.nextGuard){<span class="cstat-no" title="statement not covered" >fn.node.nextGuardCount++;<span class="cstat-no" title="statement not covered" >p</span>ath.replaceWith(t.callExpression(fn.node.nextGuardName,[_yielder]));}</span>else {<span class="cstat-no" title="statement not covered" >path.replaceWith(_yielder);}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(fn.node.nextGuard){<span class="cstat-no" title="statement not covered" >fn.node.nextGuardCount++;<span class="cstat-no" title="statement not covered" >p</span>ath.replaceWith(t.callExpression(fn.node.nextGuardName,[yielder]));}</span>}</span></span>,ReturnStatement:<span class="fstat-no" title="function not covered" >function ReturnStatement(path,context){<span class="cstat-no" title="statement not covered" ></span>var fn=path.getFunctionParent();<span class="cstat-no" title="statement not covered" >i</span>f(!fn){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>f</span>n.node.returnCount++;<span class="cstat-no" title="statement not covered" >i</span>f(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar parent=path.parent;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar _fn$node=fn.node;<span class="cstat-no" title="statement not covered" >v</span>ar returnType=_fn$node.returnType;<span class="cstat-no" title="statement not covered" >v</span>ar returnGuardName=_fn$node.returnGuardName;<span class="cstat-no" title="statement not covered" >i</span>f(!returnType||!returnGuardName){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!node.argument){<span class="cstat-no" title="statement not covered" >if(maybeNullableAnnotation(returnType)===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'"'+fn.node.id.name+'" ':'')+'did not return a value.',returnType));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar annotation=returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isGeneratorAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1?annotation.typeParameters.params[1]:t.anyTypeAnnotation();}</span>else <span class="cstat-no" title="statement not covered" >if(node.async&amp;&amp;annotation.type==='GenericTypeAnnotation'&amp;&amp;annotation.id.name==='Promise'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters&amp;&amp;annotation.typeParameters[0]||t.anyTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar ok=staticCheckAnnotation(path.get("argument"),annotation);<span class="cstat-no" title="statement not covered" >i</span>f(ok===true){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'"'+fn.node.id.name+'" ':'')+'returned an invalid type.',annotation,getAnnotation(path.get('argument'))));}<span class="cstat-no" title="statement not covered" ></span>f</span></span>n.node.returnGuardCount++;<span class="cstat-no" title="statement not covered" >v</span>ar returner=t.returnStatement(t.callExpression(fn.node.returnGuardName,[node.argument]));<span class="cstat-no" title="statement not covered" >r</span>eturner.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >p</span>ath.replaceWith(returner);}</span>,VariableDeclaration:<span class="fstat-no" title="function not covered" >function VariableDeclaration(path,context){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar collected=[];<span class="cstat-no" title="statement not covered" >v</span>ar declarations=path.get("declarations");<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;node.declarations.length;i++){<span class="cstat-no" title="statement not covered" >var declaration=node.declarations[i];<span class="cstat-no" title="statement not covered" >v</span>ar _id2=declaration.id;<span class="cstat-no" title="statement not covered" >v</span>ar init=declaration.init;<span class="cstat-no" title="statement not covered" >i</span>f(!_id2.typeAnnotation||_id2.hasBeenTypeChecked){<span class="cstat-no" title="statement not covered" >continue;}<span class="cstat-no" title="statement not covered" ></span>_</span>id2.savedTypeAnnotation=_id2.typeAnnotation;<span class="cstat-no" title="statement not covered" >_</span>id2.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >v</span>ar ok=staticCheckAnnotation(declarations[i],_id2.typeAnnotation);<span class="cstat-no" title="statement not covered" >i</span>f(ok===true){<span class="cstat-no" title="statement not covered" >continue;}</span>else <span class="cstat-no" title="statement not covered" >if(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid assignment value for "'+_id2.name+'".',_id2.typeAnnotation,getAnnotation(declarations[i])));}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar check=checkAnnotation(_id2,_id2.typeAnnotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >collected.push(guard({check:check,message:varTypeErrorMessage(_id2,context)}));}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(collected.length&gt;0){<span class="cstat-no" title="statement not covered" >var _check=collected.reduce(<span class="fstat-no" title="function not covered" >function(check,branch){<span class="cstat-no" title="statement not covered" ></span>branch.alternate=check;<span class="cstat-no" title="statement not covered" >r</span>eturn branch;}</span>);<span class="cstat-no" title="statement not covered" >i</span>f(path.parent.type==='Program'||path.parent.type==='BlockStatement'){<span class="cstat-no" title="statement not covered" >path.insertAfter(_check);}</span>else <span class="cstat-no" title="statement not covered" >if(path.parentPath.isForXStatement()||path.parentPath.isForStatement()||path.parentPath.isForInStatement()){<span class="cstat-no" title="statement not covered" >var body=path.parentPath.get('body');<span class="cstat-no" title="statement not covered" >i</span>f(body.type!=='BlockStatement'){<span class="cstat-no" title="statement not covered" >var block=t.blockStatement([body.node]);<span class="cstat-no" title="statement not covered" >b</span>ody.replaceWith(block);<span class="cstat-no" title="statement not covered" >b</span>ody=path.parentPath.get('body');}<span class="cstat-no" title="statement not covered" ></span>v</span>ar children=body.get('body');<span class="cstat-no" title="statement not covered" >i</span>f(children.length===0){<span class="cstat-no" title="statement not covered" >body.replaceWith(_check);}</span>else {<span class="cstat-no" title="statement not covered" >children[0].insertBefore(_check);}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(path.parent.type==='ExportNamedDeclaration'||path.parent.type==='ExportDefaultDeclaration'||path.parent.type==='ExportAllDeclaration'){<span class="cstat-no" title="statement not covered" >path.parentPath.insertAfter(_check);}</span>else {<span class="cstat-no" title="statement not covered" >path.replaceWith(t.blockStatement([node,_check]));}</span>}</span></span></span>}</span>,AssignmentExpression:<span class="fstat-no" title="function not covered" >function AssignmentExpression(path,context){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar left=path.get('left');<span class="cstat-no" title="statement not covered" >v</span>ar annotation=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(node.hasBeenTypeChecked||node.left.hasBeenTypeChecked){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(left.isMemberExpression()){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(left);}</span>else <span class="cstat-no" title="statement not covered" >if(t.isIdentifier(node.left)){<span class="cstat-no" title="statement not covered" >var binding=scope.getBinding(node.left.name);<span class="cstat-no" title="statement not covered" >i</span>f(!binding){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(binding.path.type!=='VariableDeclarator'){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>a</span></span>nnotation=left.getTypeAnnotation();<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='AnyTypeAnnotation'){<span class="cstat-no" title="statement not covered" >var item=binding.path.get('id');<span class="cstat-no" title="statement not covered" >a</span>nnotation=item.node.savedTypeAnnotation||item.getTypeAnnotation();}</span>}</span>else {<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>n</span></span></span>ode.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >n</span>ode.left.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.left;<span class="cstat-no" title="statement not covered" >v</span>ar right=path.get('right');<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='AnyTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar ok=staticCheckAnnotation(right,annotation);<span class="cstat-no" title="statement not covered" >i</span>f(ok===true){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid assignment value for "'+humanReadableType(id)+'".',annotation,getAnnotation(right)));}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar check=checkAnnotation(id,annotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!id.typeAnnotation){<span class="cstat-no" title="statement not covered" >id.typeAnnotation=annotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>d.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >var parent=path.getStatementParent();<span class="cstat-no" title="statement not covered" >p</span>arent.insertAfter(guard({check:check,message:varTypeErrorMessage(id,context)}));}</span>}</span>,TypeCastExpression:<span class="fstat-no" title="function not covered" >function TypeCastExpression(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar target=void 0;<span class="cstat-no" title="statement not covered" >s</span>witch(node.expression.type){case 'Identifier':<span class="cstat-no" title="statement not covered" >target=node.expression;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 'AssignmentExpression':<span class="cstat-no" title="statement not covered" >target=node.expression.left;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault: // unsupported.</span>
<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>var id=path.scope.getBindingIdentifier(target.name);<span class="cstat-no" title="statement not covered" >i</span>f(!id){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>d.savedTypeAnnotation=path.getTypeAnnotation();}</span>,ForOfStatement:<span class="fstat-no" title="function not covered" >function ForOfStatement(path,context){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar left=path.get('left');<span class="cstat-no" title="statement not covered" >v</span>ar right=path.get('right');<span class="cstat-no" title="statement not covered" >v</span>ar rightAnnotation=getAnnotation(right);<span class="cstat-no" title="statement not covered" >v</span>ar leftAnnotation=left.isVariableDeclaration()?getAnnotation(left.get('declarations')[0].get('id')):getAnnotation(left);<span class="cstat-no" title="statement not covered" >i</span>f(rightAnnotation.type!=='VoidTypeAnnotation'&amp;&amp;rightAnnotation.type!=='NullLiteralTypeAnnotation'){<span class="cstat-no" title="statement not covered" >var ok=maybeIterableAnnotation(rightAnnotation);<span class="cstat-no" title="statement not covered" >i</span>f(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError('Cannot iterate '+humanReadableType(rightAnnotation)+'.');}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar id=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(right.isIdentifier()){<span class="cstat-no" title="statement not covered" >id=right.node;}</span>else {<span class="cstat-no" title="statement not covered" >id=path.scope.generateUidIdentifierBasedOnNode(right.node);<span class="cstat-no" title="statement not covered" >p</span>ath.scope.push({id:id});<span class="cstat-no" title="statement not covered" >v</span>ar replacement=t.expressionStatement(t.assignmentExpression('=',id,right.node));<span class="cstat-no" title="statement not covered" >p</span>ath.insertBefore(replacement);<span class="cstat-no" title="statement not covered" >r</span>ight.replaceWith(id);}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.insertBefore(guard({check:checks.iterable({input:id}),message:t.binaryExpression('+',t.stringLiteral('Expected '+humanReadableType(right.node)+' to be iterable, got '),readableName({inspect:context.inspect,input:id}))}));<span class="cstat-no" title="statement not covered" >i</span>f(rightAnnotation.type!=='GenericTypeAnnotation'||rightAnnotation.id.name!=='Iterable'||!rightAnnotation.typeParameters||!rightAnnotation.typeParameters.params.length){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar annotation=rightAnnotation.typeParameters.params[0];<span class="cstat-no" title="statement not covered" >i</span>f(compareAnnotations(annotation,leftAnnotation)===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid iterator type.',annotation,leftAnnotation));}</span>}</span>,ClassDeclaration:<span class="fstat-no" title="function not covered" >function ClassDeclaration(path,context){</span> // Convert React props to propTypes
<span class="cstat-no" title="statement not covered" >if(!path.node.superClass){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar props=void 0;<span class="cstat-no" title="statement not covered" >v</span>ar hasRenderMethod=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion2=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError2=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError2=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator2=path.get('body.body')[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=true){<span class="cstat-no" title="statement not covered" >var memberPath=_step2.value;<span class="cstat-no" title="statement not covered" >v</span>ar classMember=memberPath.node;<span class="cstat-no" title="statement not covered" >i</span>f(t.isClassProperty(classMember)){<span class="cstat-no" title="statement not covered" >if(classMember.key.name==='propTypes'&amp;&amp;classMember.static){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(classMember.key.name==='props'&amp;&amp;!classMember.static){<span class="cstat-no" title="statement not covered" >props=memberPath;}</span>}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(t.isClassMethod(classMember)&amp;&amp;classMember.key.name==='render'){<span class="cstat-no" title="statement not covered" >hasRenderMethod=true;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError2=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError2=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion2&amp;&amp;_iterator2.return){<span class="cstat-no" title="statement not covered" >_iterator2.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError2){<span class="cstat-no" title="statement not covered" >throw _iteratorError2;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar type=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(path.node.superTypeParameters){<span class="cstat-no" title="statement not covered" >if(path.node.superTypeParameters.params.length!==3){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>t</span>ype=path.node.superTypeParameters.params[1];}<span class="cstat-no" title="statement not covered" ></span>i</span>f(props){<span class="cstat-no" title="statement not covered" >type=props.node.typeAnnotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!type||!hasRenderMethod){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t.isGenericTypeAnnotation(type)){<span class="cstat-no" title="statement not covered" >var binding=path.scope.getBinding(type.id.name);<span class="cstat-no" title="statement not covered" >t</span>ype=getAnnotation(binding.path);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!t.isObjectTypeAnnotation(type)){<span class="cstat-no" title="statement not covered" >return;}</span> </span>// Now we have a class that has a superclass, an instance method called 'render'
// and some property type annotations. We can be reasonably sure it's a React component.
<span class="cstat-no" title="statement not covered" >var propTypes=t.objectExpression(type.properties.map(<span class="fstat-no" title="function not covered" >function(prop){<span class="cstat-no" title="statement not covered" ></span>return t.objectProperty(t.identifier(prop.key.name),generatePropType(prop.value,path.scope,context));}</span>));<span class="cstat-no" title="statement not covered" >i</span>f(path.node.decorators){<span class="cstat-no" title="statement not covered" >var property=t.classProperty(t.identifier('propTypes'),propTypes);<span class="cstat-no" title="statement not covered" >p</span>roperty.static=true;<span class="cstat-no" title="statement not covered" >p</span>rops.insertAfter(property);}</span>else {<span class="cstat-no" title="statement not covered" >var root=path.parentPath.isExportDeclaration()?path.parentPath:path;<span class="cstat-no" title="statement not covered" >r</span>oot.insertAfter(t.expressionStatement(t.assignmentExpression("=",t.memberExpression(path.node.id,t.identifier("propTypes")),propTypes)));}</span>}</span>}; /**
   * Collect all the type declarations in the given path and add references to them for retreival later.
   */<span class="fstat-no" title="function not covered" >function collectTypes(path){<span class="cstat-no" title="statement not covered" ></span>path.traverse({TypeAlias:<span class="fstat-no" title="function not covered" >function TypeAlias(path){<span class="cstat-no" title="statement not covered" ></span>path.scope.setData('typechecker:'+path.node.id.name,path.node);}</span>,ImportDeclaration:<span class="fstat-no" title="function not covered" >function ImportDeclaration(path){<span class="cstat-no" title="statement not covered" ></span>if(path.node.importKind!=='type'){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.get('specifiers').forEach(<span class="fstat-no" title="function not covered" >function(specifier){<span class="cstat-no" title="statement not covered" ></span>var local=specifier.get('local');<span class="cstat-no" title="statement not covered" >p</span>ath.scope.setData('typechecker:'+local.node.id.name,specifier.node);}</span>);}</span>});}<span class="cstat-no" title="statement not covered" ></span>return {visitor:{Program:<span class="fstat-no" title="function not covered" >function Program(path,_ref6){<span class="cstat-no" title="statement not covered" ></span>var opts=_ref6.opts;<span class="cstat-no" title="statement not covered" >i</span>f(opts&amp;&amp;opts.disable&amp;&amp;opts.disable[process.env.NODE_ENV]){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checkFile=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion3=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError3=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError3=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator3=path.get('body')[Symbol.iterator](),_step3;!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=true){<span class="cstat-no" title="statement not covered" >var _child=_step3.value;<span class="cstat-no" title="statement not covered" >i</span>f(mustCheckFile(_child,opts)){<span class="cstat-no" title="statement not covered" >checkFile=true;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError3=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError3=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion3&amp;&amp;_iterator3.return){<span class="cstat-no" title="statement not covered" >_iterator3.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError3){<span class="cstat-no" title="statement not covered" >throw _iteratorError3;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!checkFile){<span class="cstat-no" title="statement not covered" >var _iteratorNormalCompletion4=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError4=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError4=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator4=path.get('body')[Symbol.iterator](),_step4;!(_iteratorNormalCompletion4=(_step4=_iterator4.next()).done);_iteratorNormalCompletion4=true){<span class="cstat-no" title="statement not covered" >var child=_step4.value;<span class="cstat-no" title="statement not covered" >i</span>f(maybeSkipFile(child,opts)){<span class="cstat-no" title="statement not covered" >return;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError4=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError4=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion4&amp;&amp;_iterator4.return){<span class="cstat-no" title="statement not covered" >_iterator4.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError4){<span class="cstat-no" title="statement not covered" >throw _iteratorError4;}</span>}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>c</span>ollectTypes(path);<span class="cstat-no" title="statement not covered" >v</span>ar inspect=path.scope.generateUidIdentifier('inspect');<span class="cstat-no" title="statement not covered" >v</span>ar requiresHelpers={inspect:false};<span class="cstat-no" title="statement not covered" >v</span>ar context={get inspect<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>requiresHelpers.inspect=true;<span class="cstat-no" title="statement not covered" >r</span>eturn inspect;}</span>};<span class="cstat-no" title="statement not covered" >p</span>ath.traverse(visitors,context);<span class="cstat-no" title="statement not covered" >i</span>f(requiresHelpers.inspect){<span class="cstat-no" title="statement not covered" >var body=path.get('body');<span class="cstat-no" title="statement not covered" >b</span>ody[body.length-1].insertAfter(template('\n            function id (input, depth) {\n              const maxDepth = 4;\n              const maxKeys = 15;\n              if (depth === undefined) {\n                depth = 0;\n              }\n              depth += 1;\n              if (input === null) {\n                return \'null\';\n              }\n              else if (input === undefined) {\n                return \'void\';\n              }\n              else if (typeof input === \'string\' || typeof input === \'number\' || typeof input === \'boolean\') {\n                return typeof input;\n              }\n              else if (Array.isArray(input)) {\n                if (input.length &gt; 0) {\n                  if (depth &gt; maxDepth) return \'[...]\';\n                  const first = id(input[0], depth);\n                  if (input.every(item =&gt; id(item, depth) === first)) {\n                    return first.trim() + \'[]\';\n                  }\n                  else {\n                    return \'[\' + input.slice(0, maxKeys).map(item =&gt; id(item, depth)).join(\', \') + (input.length &gt;= maxKeys ? \', ...\' : \'\') + \']\';\n                  }\n                }\n                else {\n                  return \'Array\';\n                }\n              }\n              else {\n                const keys = Object.keys(input);\n                if (!keys.length) {\n                  if (input.constructor &amp;&amp; input.constructor.name &amp;&amp; input.constructor.name !== \'Object\') {\n                    return input.constructor.name;\n                  }\n                  else {\n                    return \'Object\';\n                  }\n                }\n                if (depth &gt; maxDepth) return \'{...}\';\n                const indent = \'  \'.repeat(depth - 1);\n                let entries = keys.slice(0, maxKeys).map(key =&gt; {\n                  return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key) ? key : JSON.stringify(key)) + \': \' + id(input[key], depth) + \';\';\n                }).join(\'\\n  \' + indent);\n                if (keys.length &gt;= maxKeys) {\n                  entries += \'\\n  \' + indent + \'...\';\n                }\n                if (input.constructor &amp;&amp; input.constructor.name &amp;&amp; input.constructor.name !== \'Object\') {\n                  return input.constructor.name + \' {\\n  \' + indent + entries + \'\\n\' + indent + \'}\';\n                }\n                else {\n                  return \'{\\n  \' + indent + entries + \'\\n\' + indent + \'}\';\n                }\n              }\n            }\n          ')({id:inspect}));}</span>}</span>}}; </span>/**
   * Create a function which can verify the return type for a function.
   */<span class="fstat-no" title="function not covered" >function createFunctionReturnGuard(path,context){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isGeneratorAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1?annotation.typeParameters.params[1]:t.anyTypeAnnotation();}</span>else <span class="cstat-no" title="statement not covered" >if(node.async&amp;&amp;annotation.type==='GenericTypeAnnotation'&amp;&amp;annotation.id.name==='Promise'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters&amp;&amp;annotation.typeParameters[0]||t.anyTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar name=scope.generateUidIdentifierBasedOnNode(node);<span class="cstat-no" title="statement not covered" >v</span>ar id=scope.generateUidIdentifier('id');<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(id,annotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >node.returnGuard=guardFn({id:id,name:name,check:check,message:returnTypeErrorMessage(path,path.node,id,context)});<span class="cstat-no" title="statement not covered" >n</span>ode.returnGuard.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >n</span>ode.returnGuardName=name;<span class="cstat-no" title="statement not covered" >n</span>ode.returnGuardCount=0;}</span>}<span class="fstat-no" title="function not covered" ></span>function createFunctionYieldGuards(path,context){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='NullableTypeAnnotation'||annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!annotation.typeParameters||annotation.typeParameters.params.length===0){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!isGeneratorAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar yieldType=annotation.typeParameters.params[0];<span class="cstat-no" title="statement not covered" >v</span>ar nextType=annotation.typeParameters.params[2];<span class="cstat-no" title="statement not covered" >i</span>f(yieldType){<span class="cstat-no" title="statement not covered" >var _name=scope.generateUidIdentifier('check'+(node.id?node.id.name.slice(0,1).toUpperCase()+node.id.name.slice(1):'')+'Yield');<span class="cstat-no" title="statement not covered" >v</span>ar _id3=scope.generateUidIdentifier('id');<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(_id3,yieldType,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >node.yieldGuard=guardFn({id:_id3,name:_name,check:check,message:yieldTypeErrorMessage(node,yieldType,_id3,context)});<span class="cstat-no" title="statement not covered" >n</span>ode.yieldGuardName=_name;<span class="cstat-no" title="statement not covered" >n</span>ode.yieldGuardCount=0;}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(nextType){<span class="cstat-no" title="statement not covered" >var _name2=scope.generateUidIdentifier('check'+(node.id?node.id.name.slice(0,1).toUpperCase()+node.id.name.slice(1):'')+'Next');<span class="cstat-no" title="statement not covered" >v</span>ar _id4=scope.generateUidIdentifier('id');<span class="cstat-no" title="statement not covered" >v</span>ar _check2=checkAnnotation(_id4,nextType,scope);<span class="cstat-no" title="statement not covered" >i</span>f(_check2){<span class="cstat-no" title="statement not covered" >node.nextGuard=guardFn({id:_id4,name:_name2,check:_check2,message:yieldNextTypeErrorMessage(node,nextType,_id4,context)});<span class="cstat-no" title="statement not covered" >n</span>ode.nextGuardName=_name2;<span class="cstat-no" title="statement not covered" >n</span>ode.nextGuardCount=0;}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function isThisMemberExpression(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='ThisExpression'){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='MemberExpression'){<span class="cstat-no" title="statement not covered" >return isThisMemberExpression(path.get('object'));}</span>else {<span class="cstat-no" title="statement not covered" >return false;}</span>}<span class="fstat-no" title="function not covered" ></span></span>function isGeneratorAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>if(!annotation){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(annotation.type==='TypeAnnotation'||annotation.type==='NullableTypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn annotation.type==='GenericTypeAnnotation'&amp;&amp;annotation.id.name==='Generator';}<span class="fstat-no" title="function not covered" ></span>function buildErrorMessage(message,expected,got){<span class="cstat-no" title="statement not covered" ></span>if(got){<span class="cstat-no" title="statement not covered" >return message+'\n\nExpected:\n'+humanReadableType(expected)+'\n\nGot:\n'+humanReadableType(got);}</span>else {<span class="cstat-no" title="statement not covered" >return message+'\n\nExpected:\n'+humanReadableType(expected);}</span>}<span class="fstat-no" title="function not covered" ></span>function createChecks(){<span class="cstat-no" title="statement not covered" ></span>return {number:expression('typeof input === \'number\''),numericLiteral:checkNumericLiteral,boolean:expression('typeof input === \'boolean\''),booleanLiteral:checkBooleanLiteral,class:checkClass,function:expression('typeof input === \'function\''),string:expression('typeof input === \'string\''),stringLiteral:checkStringLiteral,symbol:expression('typeof input === \'symbol\''),undefined:expression('input === undefined'),null:expression('input === null'),void:expression('input == null'),instanceof:expression('input instanceof type'),type:expression('type(input)'),mixed:<span class="fstat-no" title="function not covered" >function mixed(){<span class="cstat-no" title="statement not covered" ></span>return null;}</span>,any:<span class="fstat-no" title="function not covered" >function any(){<span class="cstat-no" title="statement not covered" ></span>return null;}</span>,union:checkUnion,intersection:checkIntersection,array:checkArray,map:checkMap,set:checkSet,generator:checkGenerator,iterable:checkIterable,tuple:checkTuple,object:checkObject,nullable:checkNullable,typeof:checkTypeof,int8:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= -128 &amp;&amp; input &lt;= 127 &amp;&amp; input === Math.floor(input)'),uint8:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= 0 &amp;&amp; input &lt;= 255 &amp;&amp; input === Math.floor(input)'),int16:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= -32768 &amp;&amp; input &lt;= 32767 &amp;&amp; input === Math.floor(input)'),uint16:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= 0 &amp;&amp; input &lt;= 65535 &amp;&amp; input === Math.floor(input)'),int32:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= -2147483648 &amp;&amp; input &lt;= 2147483647 &amp;&amp; input === Math.floor(input)'),uint32:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= 0 &amp;&amp; input &lt;= 4294967295 &amp;&amp; input === Math.floor(input)'),float32:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= -3.40282347e+38 &amp;&amp; input &lt;= 3.40282347e+38'),float64:expression('typeof input === \'number\' &amp;&amp; !isNaN(input)'),double:expression('typeof input === \'number\' &amp;&amp; !isNaN(input)')};}<span class="fstat-no" title="function not covered" ></span>function createStaticChecks(){<span class="cstat-no" title="statement not covered" ></span>return {symbol:<span class="fstat-no" title="function not covered" >function symbol(path){<span class="cstat-no" title="statement not covered" ></span>return maybeSymbolAnnotation(getAnnotation(path));}</span>,instanceof:<span class="fstat-no" title="function not covered" >function _instanceof(_ref7){<span class="cstat-no" title="statement not covered" ></span>var path=_ref7.path;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref7.annotation;<span class="cstat-no" title="statement not covered" >v</span>ar type=createTypeExpression(annotation.id);<span class="cstat-no" title="statement not covered" >v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >i</span>f(type.name==='Object'&amp;&amp;node.type==='ObjectExpression'&amp;&amp;!scope.getBinding('Object')){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='Map'&amp;&amp;!scope.getBinding('Map')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='Set'&amp;&amp;!scope.getBinding('Set')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='Class'&amp;&amp;!scope.hasBinding('Class')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='int8'&amp;&amp;!scope.hasBinding('int8')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='uint8'&amp;&amp;!scope.hasBinding('uint8')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='int16'&amp;&amp;!scope.hasBinding('int16')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='uint16'&amp;&amp;!scope.hasBinding('uint16')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='int32'&amp;&amp;!scope.hasBinding('int32')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='uint32'&amp;&amp;!scope.hasBinding('uint32')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='float32'&amp;&amp;!scope.hasBinding('float32')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='float64'&amp;&amp;!scope.hasBinding('float64')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='double'&amp;&amp;!scope.hasBinding('double')){<span class="cstat-no" title="statement not covered" >return null;}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span></span></span></span></span></span></span></span></span></span>eturn maybeInstanceOfAnnotation(getAnnotation(path),type,annotation.typeParameters?annotation.typeParameters.params:[]);}</span>,type:<span class="fstat-no" title="function not covered" >function(_type){<span class="fstat-no" title="function not covered" ></span>function type(_x){<span class="cstat-no" title="statement not covered" ></span>return _type.apply(this,arguments);}<span class="cstat-no" title="statement not covered" ></span>type.toString=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return _type.toString();}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn type;}</span>(<span class="fstat-no" title="function not covered" >function(_ref8){<span class="cstat-no" title="statement not covered" ></span>var path=_ref8.path;<span class="cstat-no" title="statement not covered" >v</span>ar type=_ref8.type;<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span>)};}<span class="fstat-no" title="function not covered" ></span>function compareAnnotations(a,b){<span class="cstat-no" title="statement not covered" ></span>if(a.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >a=a.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(b.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >b=b.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(a.type){case 'StringTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeStringAnnotation(b);c</span>ase 'StringLiteral':case 'StringLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareStringLiteralAnnotations(a,b);c</span>ase 'NumberTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeNumberAnnotation(b);c</span>ase 'NumericLiteral':case 'NumericLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareNumericLiteralAnnotations(a,b);c</span>ase 'BooleanTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeBooleanAnnotation(b);c</span>ase 'BooleanLiteral':case 'BooleanLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareBooleanLiteralAnnotations(a,b);c</span>ase 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeFunctionAnnotation(b);c</span>ase 'AnyTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;c</span>ase 'MixedTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;c</span>ase 'ObjectTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareObjectAnnotation(a,b);c</span>ase 'ArrayTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareArrayAnnotation(a,b);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareGenericAnnotation(a,b);c</span>ase 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareTupleAnnotation(a,b);c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareUnionAnnotation(a,b);c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareIntersectionAnnotation(a,b);c</span>ase 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareNullableAnnotation(a,b);d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareStringLiteralAnnotations(a,b){<span class="cstat-no" title="statement not covered" ></span>if(b.type==='StringLiteralTypeAnnotation'||b.type==='StringLiteral'){<span class="cstat-no" title="statement not covered" >return a.value===b.value;}</span>else {<span class="cstat-no" title="statement not covered" >return maybeStringAnnotation(b)===false?false:null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareBooleanLiteralAnnotations(a,b){<span class="cstat-no" title="statement not covered" ></span>if(b.type==='BooleanLiteralTypeAnnotation'||b.type==='BooleanLiteral'){<span class="cstat-no" title="statement not covered" >return a.value===b.value;}</span>else {<span class="cstat-no" title="statement not covered" >return maybeBooleanAnnotation(b)===false?false:null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareNumericLiteralAnnotations(a,b){<span class="cstat-no" title="statement not covered" ></span>if(b.type==='NumericLiteralTypeAnnotation'||b.type==='NumericLiteral'){<span class="cstat-no" title="statement not covered" >return a.value===b.value;}</span>else {<span class="cstat-no" title="statement not covered" >return maybeNumberAnnotation(b)===false?false:null;}</span>}<span class="fstat-no" title="function not covered" ></span>function unionComparer(a,b,comparator){<span class="cstat-no" title="statement not covered" ></span>if(!a.types||a.types.length===0){<span class="cstat-no" title="statement not covered" >return null;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar trueCount=0;<span class="cstat-no" title="statement not covered" >i</span>f(!a.types){<span class="cstat-no" title="statement not covered" >return null;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion5=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError5=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError5=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator5=a.types[Symbol.iterator](),_step5;!(_iteratorNormalCompletion5=(_step5=_iterator5.next()).done);_iteratorNormalCompletion5=true){<span class="cstat-no" title="statement not covered" >var _type2=_step5.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=comparator(_type2,b);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >if(b.type!=='UnionTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return true;}<span class="cstat-no" title="statement not covered" ></span>t</span>rueCount++;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >if(b.type==='UnionTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>f</span>alseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError5=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError5=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion5&amp;&amp;_iterator5.return){<span class="cstat-no" title="statement not covered" >_iterator5.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError5){<span class="cstat-no" title="statement not covered" >throw _iteratorError5;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===a.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else <span class="cstat-no" title="statement not covered" >if(trueCount===a.types.length){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span></span>function intersectionComparer(a,b,comparator){<span class="cstat-no" title="statement not covered" ></span>var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar trueCount=0;<span class="cstat-no" title="statement not covered" >i</span>f(!a.types){<span class="cstat-no" title="statement not covered" >return null;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion6=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError6=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError6=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator6=a.types[Symbol.iterator](),_step6;!(_iteratorNormalCompletion6=(_step6=_iterator6.next()).done);_iteratorNormalCompletion6=true){<span class="cstat-no" title="statement not covered" >var _type3=_step6.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=comparator(_type3,b);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >trueCount++;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >return false;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError6=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError6=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion6&amp;&amp;_iterator6.return){<span class="cstat-no" title="statement not covered" >_iterator6.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError6){<span class="cstat-no" title="statement not covered" >throw _iteratorError6;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(trueCount===a.types.length){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareObjectAnnotation(a,b){<span class="cstat-no" title="statement not covered" ></span>switch(b.type){case 'ObjectTypeAnnotation':<span class="cstat-no" title="statement not covered" >break;c</span>ase 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareObjectAnnotation(a,b.typeAnnotation);c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return unionComparer(a,b,compareObjectAnnotation);c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return intersectionComparer(a,b,compareObjectAnnotation);c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span> </span>// We're comparing two object annotations.
<span class="cstat-no" title="statement not covered" >var allTrue=true;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion7=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError7=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError7=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator7=a.properties[Symbol.iterator](),_step7;!(_iteratorNormalCompletion7=(_step7=_iterator7.next()).done);_iteratorNormalCompletion7=true){<span class="cstat-no" title="statement not covered" >var aprop=_step7.value;<span class="cstat-no" title="statement not covered" >v</span>ar found=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion8=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError8=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError8=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator8=b.properties[Symbol.iterator](),_step8;!(_iteratorNormalCompletion8=(_step8=_iterator8.next()).done);_iteratorNormalCompletion8=true){<span class="cstat-no" title="statement not covered" >var bprop=_step8.value;<span class="cstat-no" title="statement not covered" >i</span>f(bprop.key.name===aprop.key.name){<span class="cstat-no" title="statement not covered" >var result=compareAnnotations(aprop.value,bprop.value);<span class="cstat-no" title="statement not covered" >i</span>f(result===false&amp;&amp;!(aprop.optional&amp;&amp;(bprop.optional||maybeNullableAnnotation(bprop.value)===true))){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >found=result;}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError8=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError8=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion8&amp;&amp;_iterator8.return){<span class="cstat-no" title="statement not covered" >_iterator8.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError8){<span class="cstat-no" title="statement not covered" >throw _iteratorError8;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(found===false&amp;&amp;!aprop.optional){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>a</span>llTrue=allTrue&amp;&amp;found===true;}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError7=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError7=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion7&amp;&amp;_iterator7.return){<span class="cstat-no" title="statement not covered" >_iterator7.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError7){<span class="cstat-no" title="statement not covered" >throw _iteratorError7;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn allTrue?true:null;}<span class="fstat-no" title="function not covered" ></span>function compareArrayAnnotation(a,b){<span class="cstat-no" title="statement not covered" ></span>switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareArrayAnnotation(a,b.typeAnnotation);c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return unionComparer(a,b,compareArrayAnnotation);c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return intersectionComparer(a,b,compareArrayAnnotation);c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareGenericAnnotation(a,b){<span class="cstat-no" title="statement not covered" ></span>switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareGenericAnnotation(a,b.typeAnnotation);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(b.id.name===a.id.name){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return unionComparer(a,b,compareGenericAnnotation);c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return intersectionComparer(a,b,compareGenericAnnotation);d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareTupleAnnotation(a,b){<span class="cstat-no" title="statement not covered" ></span>if(b.type==='TupleTypeAnnotation'){<span class="cstat-no" title="statement not covered" >if(b.types.length===0){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(b.types.length&lt;a.types.length){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn a.types.every(<span class="fstat-no" title="function not covered" >function(type,index){<span class="cstat-no" title="statement not covered" ></span>return compareAnnotations(type,b.types[index]);}</span>);}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareTupleAnnotation(a,b.typeAnnotation);c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return unionComparer(a,b,compareTupleAnnotation);c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return intersectionComparer(a,b,compareTupleAnnotation);c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareUnionAnnotation(a,b){<span class="cstat-no" title="statement not covered" ></span>switch(b.type){case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareUnionAnnotation(a,b.typeAnnotation);c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return unionComparer(a,b,compareAnnotations);}</span>}<span class="fstat-no" title="function not covered" ></span>function compareNullableAnnotation(a,b){<span class="cstat-no" title="statement not covered" ></span>switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return compareNullableAnnotation(a,b.typeAnnotation);c</span>ase 'NullableTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(compareAnnotations(a.typeAnnotation,b)===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function arrayExpressionToTupleAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var elements=path.get('elements');<span class="cstat-no" title="statement not covered" >r</span>eturn t.tupleTypeAnnotation(elements.map(<span class="fstat-no" title="function not covered" >function(element){<span class="cstat-no" title="statement not covered" ></span>return getAnnotation(element);}</span>));}<span class="fstat-no" title="function not covered" ></span>function checkNullable(_ref9){<span class="cstat-no" title="statement not covered" ></span>var input=_ref9.input;<span class="cstat-no" title="statement not covered" >v</span>ar type=_ref9.type;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref9.scope;<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(input,type,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!check){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logicalExpression("||",checks.void({input:input}),check);}<span class="fstat-no" title="function not covered" ></span>function checkTypeof(_ref10){<span class="cstat-no" title="statement not covered" ></span>var input=_ref10.input;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref10.annotation;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref10.scope;<span class="cstat-no" title="statement not covered" >s</span>witch(annotation.type){case 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >var id=annotation.id;<span class="cstat-no" title="statement not covered" >v</span>ar path=Object.assign({},input,{type:id.type,node:id,scope:scope});<span class="cstat-no" title="statement not covered" >r</span>eturn checkAnnotation(input,getAnnotation(path),scope);d</span>efault:<span class="cstat-no" title="statement not covered" >return checkAnnotation(input,annotation,scope);}</span>}<span class="fstat-no" title="function not covered" ></span>function checkStringLiteral(_ref11){<span class="cstat-no" title="statement not covered" ></span>var input=_ref11.input;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref11.annotation;<span class="cstat-no" title="statement not covered" >r</span>eturn checkEquals({input:input,expected:t.stringLiteral(annotation.value)});}<span class="fstat-no" title="function not covered" ></span>function checkNumericLiteral(_ref12){<span class="cstat-no" title="statement not covered" ></span>var input=_ref12.input;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref12.annotation;<span class="cstat-no" title="statement not covered" >r</span>eturn checkEquals({input:input,expected:t.numericLiteral(annotation.value)});}<span class="fstat-no" title="function not covered" ></span>function checkBooleanLiteral(_ref13){<span class="cstat-no" title="statement not covered" ></span>var input=_ref13.input;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref13.annotation;<span class="cstat-no" title="statement not covered" >r</span>eturn checkEquals({input:input,expected:t.booleanLiteral(annotation.value)});}<span class="fstat-no" title="function not covered" ></span>function checkUnion(_ref14){<span class="cstat-no" title="statement not covered" ></span>var input=_ref14.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref14.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref14.scope;<span class="cstat-no" title="statement not covered" >v</span>ar checks=types.map(<span class="fstat-no" title="function not covered" >function(type){<span class="cstat-no" title="statement not covered" ></span>return checkAnnotation(input,type,scope);}</span>).filter(identity);<span class="cstat-no" title="statement not covered" >r</span>eturn checks.reduce(<span class="fstat-no" title="function not covered" >function(last,check,index){<span class="cstat-no" title="statement not covered" ></span>if(last==null){<span class="cstat-no" title="statement not covered" >return check;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logicalExpression("||",last,check);}</span>,null);}<span class="fstat-no" title="function not covered" ></span>function checkIntersection(_ref15){<span class="cstat-no" title="statement not covered" ></span>var input=_ref15.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref15.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref15.scope;<span class="cstat-no" title="statement not covered" >v</span>ar checks=types.map(<span class="fstat-no" title="function not covered" >function(type){<span class="cstat-no" title="statement not covered" ></span>return checkAnnotation(input,type,scope);}</span>).filter(identity);<span class="cstat-no" title="statement not covered" >r</span>eturn checks.reduce(<span class="fstat-no" title="function not covered" >function(last,check,index){<span class="cstat-no" title="statement not covered" ></span>if(last==null){<span class="cstat-no" title="statement not covered" >return check;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logicalExpression("&amp;&amp;",last,check);}</span>,null);}<span class="fstat-no" title="function not covered" ></span>function checkMap(_ref16){<span class="cstat-no" title="statement not covered" ></span>var input=_ref16.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref16.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref16.scope;<span class="cstat-no" title="statement not covered" >v</span>ar _types=_slicedToArray(types,2);<span class="cstat-no" title="statement not covered" >v</span>ar keyType=_types[0];<span class="cstat-no" title="statement not covered" >v</span>ar valueType=_types[1];<span class="cstat-no" title="statement not covered" >v</span>ar key=t.identifier('key');<span class="cstat-no" title="statement not covered" >v</span>ar value=t.identifier('value');<span class="cstat-no" title="statement not covered" >v</span>ar keyCheck=keyType?checkAnnotation(key,keyType,scope):null;<span class="cstat-no" title="statement not covered" >v</span>ar valueCheck=valueType?checkAnnotation(value,valueType,scope):null;<span class="cstat-no" title="statement not covered" >i</span>f(!keyCheck){<span class="cstat-no" title="statement not covered" >if(!valueCheck){<span class="cstat-no" title="statement not covered" >return checkIsMap({input:input});}</span>else {<span class="cstat-no" title="statement not covered" >return checkMapValues({input:input,value:value,valueCheck:valueCheck});}</span>}</span>else {<span class="cstat-no" title="statement not covered" >if(!valueCheck){<span class="cstat-no" title="statement not covered" >return checkMapKeys({input:input,key:key,keyCheck:keyCheck});}</span>else {<span class="cstat-no" title="statement not covered" >return checkMapEntries({input:input,key:key,value:value,keyCheck:keyCheck,valueCheck:valueCheck});}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function checkSet(_ref17){<span class="cstat-no" title="statement not covered" ></span>var input=_ref17.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref17.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref17.scope;<span class="cstat-no" title="statement not covered" >v</span>ar _types2=_slicedToArray(types,1);<span class="cstat-no" title="statement not covered" >v</span>ar valueType=_types2[0];<span class="cstat-no" title="statement not covered" >v</span>ar value=t.identifier('value');<span class="cstat-no" title="statement not covered" >v</span>ar valueCheck=valueType?checkAnnotation(value,valueType,scope):null;<span class="cstat-no" title="statement not covered" >i</span>f(!valueCheck){<span class="cstat-no" title="statement not covered" >return checkIsSet({input:input});}</span>else {<span class="cstat-no" title="statement not covered" >return checkSetEntries({input:input,value:value,valueCheck:valueCheck});}</span>}<span class="fstat-no" title="function not covered" ></span>function checkGenerator(_ref18){<span class="cstat-no" title="statement not covered" ></span>var input=_ref18.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref18.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref18.scope;<span class="cstat-no" title="statement not covered" >r</span>eturn checkIsGenerator({input:input});}<span class="fstat-no" title="function not covered" ></span>function checkIterable(_ref19){<span class="cstat-no" title="statement not covered" ></span>var input=_ref19.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref19.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref19.scope;<span class="cstat-no" title="statement not covered" >r</span>eturn checkIsIterable({input:input});}<span class="fstat-no" title="function not covered" ></span>function checkClass(_ref20){<span class="cstat-no" title="statement not covered" ></span>var input=_ref20.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref20.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref20.scope;<span class="cstat-no" title="statement not covered" >r</span>eturn checkIsClass({input:input});}<span class="fstat-no" title="function not covered" ></span>function checkArray(_ref21){<span class="cstat-no" title="statement not covered" ></span>var input=_ref21.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref21.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref21.scope;<span class="cstat-no" title="statement not covered" >i</span>f(!types||types.length===0){<span class="cstat-no" title="statement not covered" >return checkIsArray({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(types.length===1){<span class="cstat-no" title="statement not covered" >var item=t.identifier('item');<span class="cstat-no" title="statement not covered" >v</span>ar _type4=types[0];<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(item,_type4,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!check){<span class="cstat-no" title="statement not covered" >return checkIsArray({input:input});}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logicalExpression('&amp;&amp;',checkIsArray({input:input}),t.callExpression(t.memberExpression(input,t.identifier('every')),[t.functionExpression(null,[item],t.blockStatement([t.returnStatement(check)]))]));}</span>else { // This is a tuple</span></span>
<span class="cstat-no" title="statement not covered" >var _checks=types.map(<span class="fstat-no" title="function not covered" >function(type,index){<span class="cstat-no" title="statement not covered" ></span>return checkAnnotation(t.memberExpression(input,t.numericLiteral(index),true),type,scope);}</span>).filter(identity);<span class="cstat-no" title="statement not covered" >v</span>ar checkLength=t.binaryExpression('&gt;=',t.memberExpression(input,t.identifier('length')),t.numericLiteral(types.length));<span class="cstat-no" title="statement not covered" >r</span>eturn _checks.reduce(<span class="fstat-no" title="function not covered" >function(last,check,index){<span class="cstat-no" title="statement not covered" ></span>return t.logicalExpression("&amp;&amp;",last,check);}</span>,t.logicalExpression('&amp;&amp;',checkIsArray({input:input}),checkLength));}</span>}<span class="fstat-no" title="function not covered" >function checkTuple(_ref22){<span class="cstat-no" title="statement not covered" ></span>var input=_ref22.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref22.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref22.scope;<span class="cstat-no" title="statement not covered" >i</span>f(types.length===0){<span class="cstat-no" title="statement not covered" >return checkIsArray({input:input});}</span> </span>// This is a tuple
<span class="cstat-no" title="statement not covered" >var checks=types.map(<span class="fstat-no" title="function not covered" >function(type,index){<span class="cstat-no" title="statement not covered" ></span>return checkAnnotation(t.memberExpression(input,t.numericLiteral(index),true),type,scope);}</span>).filter(identity);<span class="cstat-no" title="statement not covered" >v</span>ar checkLength=t.binaryExpression('&gt;=',t.memberExpression(input,t.identifier('length')),t.numericLiteral(types.length));<span class="cstat-no" title="statement not covered" >r</span>eturn checks.reduce(<span class="fstat-no" title="function not covered" >function(last,check,index){<span class="cstat-no" title="statement not covered" ></span>return t.logicalExpression("&amp;&amp;",last,check);}</span>,t.logicalExpression('&amp;&amp;',checkIsArray({input:input}),checkLength));}<span class="fstat-no" title="function not covered" ></span>function checkObject(_ref23){<span class="cstat-no" title="statement not covered" ></span>var input=_ref23.input;<span class="cstat-no" title="statement not covered" >v</span>ar properties=_ref23.properties;<span class="cstat-no" title="statement not covered" >v</span>ar indexers=_ref23.indexers;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref23.scope;<span class="cstat-no" title="statement not covered" >i</span>f(input.type==='ObjectPattern'){<span class="cstat-no" title="statement not covered" >return checkObjectPattern({input:input,properties:properties,scope:scope});}<span class="cstat-no" title="statement not covered" ></span>v</span>ar propNames=[];<span class="cstat-no" title="statement not covered" >v</span>ar check=properties.length===0?checkIsObject({input:input}):properties.reduce(<span class="fstat-no" title="function not covered" >function(expr,prop,index){<span class="cstat-no" title="statement not covered" ></span>var target=prop.key.type==='Identifier'?t.memberExpression(input,prop.key):t.memberExpression(input,prop.key,true);<span class="cstat-no" title="statement not covered" >p</span>ropNames.push(prop.key.type==='Identifier'?t.stringLiteral(prop.key.name):prop.key);<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(target,prop.value,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >if(prop.optional){<span class="cstat-no" title="statement not covered" >check=t.logicalExpression('||',checks.undefined({input:target}),check);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logicalExpression("&amp;&amp;",expr,check);}</span>else {<span class="cstat-no" title="statement not covered" >return expr;}</span>}</span>,checkNotNull({input:input}));<span class="cstat-no" title="statement not covered" >i</span>f(indexers.length){<span class="cstat-no" title="statement not covered" >return indexers.reduceRight(<span class="fstat-no" title="function not covered" >function(expr,indexer){<span class="cstat-no" title="statement not covered" ></span>if(indexer.value.type==='AnyTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return expr;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar value=scope.generateUidIdentifier(indexer.id.name);<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(value,indexer.value,scope);<span class="cstat-no" title="statement not covered" >v</span>ar fixedKeys=t.arrayExpression(propNames);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >if(propNames.length){<span class="cstat-no" title="statement not covered" >return t.logicalExpression('&amp;&amp;',expr,checkObjectIndexers({input:input,value:value,check:check,fixedKeys:fixedKeys}));}</span>else {<span class="cstat-no" title="statement not covered" >return t.logicalExpression('&amp;&amp;',expr,checkObjectIndexersNoFixed({input:input,value:value,check:check,fixedKeys:fixedKeys}));}</span>}</span>else {<span class="cstat-no" title="statement not covered" >return expr;}</span>}</span>,check);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn check;}<span class="fstat-no" title="function not covered" ></span>function checkObjectPattern(_ref24){<span class="cstat-no" title="statement not covered" ></span>var input=_ref24.input;<span class="cstat-no" title="statement not covered" >v</span>ar properties=_ref24.properties;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref24.scope;<span class="cstat-no" title="statement not covered" >v</span>ar propNames=properties.reduce(<span class="fstat-no" title="function not covered" >function(names,prop){<span class="cstat-no" title="statement not covered" ></span>names[prop.key.name]=prop;<span class="cstat-no" title="statement not covered" >r</span>eturn names;}</span>,{});<span class="cstat-no" title="statement not covered" >v</span>ar propChecks={};<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion9=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError9=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError9=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator9=input.properties[Symbol.iterator](),_step9;!(_iteratorNormalCompletion9=(_step9=_iterator9.next()).done);_iteratorNormalCompletion9=true){<span class="cstat-no" title="statement not covered" >var item=_step9.value;<span class="cstat-no" title="statement not covered" >v</span>ar key=item.key;<span class="cstat-no" title="statement not covered" >v</span>ar _id5=item.value;<span class="cstat-no" title="statement not covered" >v</span>ar prop=propNames[key.name];<span class="cstat-no" title="statement not covered" >i</span>f(!prop){<span class="cstat-no" title="statement not covered" >continue;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar check=checkAnnotation(_id5,prop.value,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >propChecks[key.name]=check;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError9=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError9=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion9&amp;&amp;_iterator9.return){<span class="cstat-no" title="statement not covered" >_iterator9.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError9){<span class="cstat-no" title="statement not covered" >throw _iteratorError9;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Object.keys(propChecks).reduce(<span class="fstat-no" title="function not covered" >function(last,name){<span class="cstat-no" title="statement not covered" ></span>var check=propChecks[name];<span class="cstat-no" title="statement not covered" >i</span>f(last===null){<span class="cstat-no" title="statement not covered" >return check;}</span>else {<span class="cstat-no" title="statement not covered" >return t.logicalExpression('&amp;&amp;',last,check);}</span>}</span>,null);}<span class="fstat-no" title="function not covered" ></span>function createTypeAliasChecks(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.id;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.right;<span class="cstat-no" title="statement not covered" >v</span>ar input=t.identifier('input');<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(input,annotation,scope)||t.booleanLiteral(true);<span class="cstat-no" title="statement not covered" >v</span>ar declaration=declareTypeChecker({id:id,check:check});<span class="cstat-no" title="statement not covered" >d</span>eclaration.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >d</span>eclaration.savedTypeAnnotation=annotation;<span class="cstat-no" title="statement not covered" >d</span>eclaration.declarations[0].savedTypeAnnotation=annotation;<span class="cstat-no" title="statement not covered" >r</span>eturn declaration;}<span class="fstat-no" title="function not covered" ></span>function createInterfaceChecks(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.id;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.body;<span class="cstat-no" title="statement not covered" >v</span>ar input=t.identifier('input');<span class="cstat-no" title="statement not covered" >v</span>ar check=node.extends.reduce(<span class="fstat-no" title="function not covered" >function(check,extender){<span class="cstat-no" title="statement not covered" ></span>return t.logicalExpression('&amp;&amp;',check,checkAnnotation(input,t.genericTypeAnnotation(extender.id),path.scope));<span class="cstat-no" title="statement not covered" >r</span>eturn check;}</span>,checkAnnotation(input,annotation,scope)||t.booleanLiteral(true));<span class="cstat-no" title="statement not covered" >v</span>ar declaration=declareTypeChecker({id:id,check:check});<span class="cstat-no" title="statement not covered" >d</span>eclaration.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >r</span>eturn declaration;}<span class="fstat-no" title="function not covered" ></span>function checkAnnotation(input,annotation,scope){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return checkAnnotation(input,annotation.typeAnnotation,scope);c</span>ase 'TypeofTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.typeof({input:input,annotation:annotation.argument,scope:scope});c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Array'){<span class="cstat-no" title="statement not covered" >return checks.array({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Generator'&amp;&amp;!scope.hasBinding('Generator')){<span class="cstat-no" title="statement not covered" >return checks.generator({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Iterable'&amp;&amp;!scope.hasBinding('Iterable')){<span class="cstat-no" title="statement not covered" >return checks.iterable({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Map'&amp;&amp;!scope.getBinding('Map')){<span class="cstat-no" title="statement not covered" >return checks.map({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Set'&amp;&amp;!scope.getBinding('Set')){<span class="cstat-no" title="statement not covered" >return checks.set({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Function'){<span class="cstat-no" title="statement not covered" >return checks.function({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Class'&amp;&amp;!scope.hasBinding('Class')){<span class="cstat-no" title="statement not covered" >return checks.class({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='int8'&amp;&amp;!scope.hasBinding('int8')){<span class="cstat-no" title="statement not covered" >return checks.int8({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='uint8'&amp;&amp;!scope.hasBinding('uint8')){<span class="cstat-no" title="statement not covered" >return checks.uint8({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='int16'&amp;&amp;!scope.hasBinding('int16')){<span class="cstat-no" title="statement not covered" >return checks.int16({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='uint16'&amp;&amp;!scope.hasBinding('uint16')){<span class="cstat-no" title="statement not covered" >return checks.uint16({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='int32'&amp;&amp;!scope.hasBinding('int32')){<span class="cstat-no" title="statement not covered" >return checks.int32({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='uint32'&amp;&amp;!scope.hasBinding('uint32')){<span class="cstat-no" title="statement not covered" >return checks.uint32({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='float32'&amp;&amp;!scope.hasBinding('float32')){<span class="cstat-no" title="statement not covered" >return checks.float32({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='float64'&amp;&amp;!scope.hasBinding('float64')){<span class="cstat-no" title="statement not covered" >return checks.float64({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='double'&amp;&amp;!scope.hasBinding('double')){<span class="cstat-no" title="statement not covered" >return checks.double({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Symbol'&amp;&amp;!scope.getBinding('Symbol')){<span class="cstat-no" title="statement not covered" >return checks.symbol({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(isTypeChecker(annotation.id,scope)){<span class="cstat-no" title="statement not covered" >return checks.type({input:input,type:annotation.id});}</span>else <span class="cstat-no" title="statement not covered" >if(isPolymorphicType(annotation.id,scope)){<span class="cstat-no" title="statement not covered" >return;}</span>else {<span class="cstat-no" title="statement not covered" >return checks.instanceof({input:input,type:createTypeExpression(annotation.id)});}</span>c</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>ase 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.tuple({input:input,types:annotation.types,scope:scope});c</span>ase 'NumberTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.number({input:input});c</span>ase 'NumericLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.numericLiteral({input:input,annotation:annotation});c</span>ase 'BooleanTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.boolean({input:input});c</span>ase 'BooleanLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.booleanLiteral({input:input,annotation:annotation});c</span>ase 'StringTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.string({input:input});c</span>ase 'StringLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.stringLiteral({input:input,annotation:annotation});c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.union({input:input,types:annotation.types,scope:scope});c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.intersection({input:input,types:annotation.types,scope:scope});c</span>ase 'ObjectTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.object({input:input,properties:annotation.properties||[],indexers:annotation.indexers,scope:scope});c</span>ase 'ArrayTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.array({input:input,types:[annotation.elementType||t.anyTypeAnnotation()],scope:scope});c</span>ase 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.function({input:input,params:annotation.params,returnType:annotation.returnType});c</span>ase 'MixedTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.mixed({input:input});c</span>ase 'AnyTypeAnnotation':case 'ExistentialTypeParam':<span class="cstat-no" title="statement not covered" >return checks.any({input:input});c</span>ase 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.nullable({input:input,type:annotation.typeAnnotation,scope:scope});c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.void({input:input});}</span>}<span class="fstat-no" title="function not covered" ></span>function staticCheckAnnotation(path,annotation){<span class="cstat-no" title="statement not covered" ></span>var other=getAnnotation(path);<span class="cstat-no" title="statement not covered" >s</span>witch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return staticCheckAnnotation(path,annotation.typeAnnotation);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(isTypeChecker(annotation.id,path.scope)){<span class="cstat-no" title="statement not covered" >return staticChecks.type({path:path,type:annotation.id});}</span>else <span class="cstat-no" title="statement not covered" >if(isPolymorphicType(annotation.id,path.scope)){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Symbol'){<span class="cstat-no" title="statement not covered" >return staticChecks.symbol(path);}</span>else {<span class="cstat-no" title="statement not covered" >return staticChecks.instanceof({path:path,annotation:annotation});}</span>}<span class="cstat-no" title="statement not covered" ></span></span></span>r</span>eturn compareAnnotations(annotation,other);}</span> /**
   * Get the type annotation for a given node.
   */<span class="fstat-no" title="function not covered" >function getAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var annotation=void 0;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >annotation=getAnnotationShallow(path);}</span>catch(e){<span class="cstat-no" title="statement not covered" >if(e instanceof SyntaxError){<span class="cstat-no" title="statement not covered" >throw e;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(process.env.TYPECHECK_DEBUG){<span class="cstat-no" title="statement not covered" >console.error(e.stack);}</span>}<span class="cstat-no" title="statement not covered" ></span>w</span>hile(annotation&amp;&amp;annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn annotation||t.anyTypeAnnotation();}<span class="fstat-no" title="function not covered" ></span>function getAnnotationShallow(path){<span class="cstat-no" title="statement not covered" ></span>if(!path||!path.node){<span class="cstat-no" title="statement not covered" >return t.voidTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='TypeAlias'){<span class="cstat-no" title="statement not covered" >return node.right;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ClassProperty'&amp;&amp;node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return getClassPropertyAnnotation(path);}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ClassMethod'&amp;&amp;node.returnType){<span class="cstat-no" title="statement not covered" >return getClassMethodAnnotation(path);}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ObjectProperty'&amp;&amp;node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return getObjectPropertyAnnotation(path);}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='SpreadProperty'&amp;&amp;node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return getSpreadPropertyAnnotation(path);}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ObjectMethod'&amp;&amp;node.returnType){<span class="cstat-no" title="statement not covered" >return getObjectMethodAnnotation(path);}</span>else <span class="cstat-no" title="statement not covered" >if(!node.typeAnnotation&amp;&amp;!node.savedTypeAnnotation&amp;&amp;!node.returnType){<span class="cstat-no" title="statement not covered" >switch(path.type){case 'Identifier':<span class="cstat-no" title="statement not covered" >var binding=scope.getBinding(node.name);<span class="cstat-no" title="statement not covered" >i</span>f(!binding||!binding.identifier){<span class="cstat-no" title="statement not covered" >return path.getTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>v</span>ar id=binding.identifier;<span class="cstat-no" title="statement not covered" >i</span>f(binding.path.type==='ObjectPattern'){<span class="cstat-no" title="statement not covered" >return getObjectPatternAnnotation(binding.path,node.name);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(id.savedTypeAnnotation){<span class="cstat-no" title="statement not covered" >return id.savedTypeAnnotation;}</span>else <span class="cstat-no" title="statement not covered" >if(id.returnType){<span class="cstat-no" title="statement not covered" >return id.returnType;}</span>else <span class="cstat-no" title="statement not covered" >if(id.typeAnnotation){<span class="cstat-no" title="statement not covered" >return id.typeAnnotation;}</span>else <span class="cstat-no" title="statement not covered" >if(isPolymorphicType(id,scope)){<span class="cstat-no" title="statement not covered" >return t.anyTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span>eturn binding.constant?binding.path.getTypeAnnotation():path.getTypeAnnotation();c</span>ase 'StringLiteral':case 'NumericLiteral':case 'BooleanLiteral':<span class="cstat-no" title="statement not covered" >return createLiteralTypeAnnotation(path);c</span>ase 'CallExpression':<span class="cstat-no" title="statement not covered" >var callee=path.get('callee');<span class="cstat-no" title="statement not covered" >i</span>f(callee.type==='Identifier'){<span class="cstat-no" title="statement not covered" >if(callee.name==='Symbol'){<span class="cstat-no" title="statement not covered" >return t.genericTypeAnnotation('Symbol');}<span class="cstat-no" title="statement not covered" ></span>v</span>ar fn=getFunctionForIdentifier(callee);<span class="cstat-no" title="statement not covered" >i</span>f(fn){<span class="cstat-no" title="statement not covered" >return getAnnotation(fn);}</span>}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase 'ThisExpression':<span class="cstat-no" title="statement not covered" >return getThisExpressionAnnotation(path);c</span>ase 'AssignmentExpression':<span class="cstat-no" title="statement not covered" >return getAssignmentExpressionAnnotation(path);c</span>ase 'MemberExpression':<span class="cstat-no" title="statement not covered" >return getMemberExpressionAnnotation(path);c</span>ase 'ArrayExpression':<span class="cstat-no" title="statement not covered" >return getArrayExpressionAnnotation(path);c</span>ase 'ObjectExpression':<span class="cstat-no" title="statement not covered" >return getObjectExpressionAnnotation(path);c</span>ase 'BinaryExpression':<span class="cstat-no" title="statement not covered" >return getBinaryExpressionAnnotation(path);c</span>ase 'LogicalExpression':<span class="cstat-no" title="statement not covered" >return getLogicalExpressionAnnotation(path);c</span>ase 'ConditionalExpression':<span class="cstat-no" title="statement not covered" >return getConditionalExpressionAnnotation(path);c</span>ase 'ObjectMethod':<span class="cstat-no" title="statement not covered" >return getObjectMethodAnnotation(path);c</span>ase 'SpreadProperty':<span class="cstat-no" title="statement not covered" >return getSpreadPropertyAnnotation(path);c</span>ase 'ObjectProperty':<span class="cstat-no" title="statement not covered" >return getObjectPropertyAnnotation(path);c</span>ase 'ClassDeclaration':<span class="cstat-no" title="statement not covered" >return getClassDeclarationAnnotation(path);c</span>ase 'ClassMethod':<span class="cstat-no" title="statement not covered" >return getClassMethodAnnotation(path);c</span>ase 'ClassProperty':<span class="cstat-no" title="statement not covered" >return getClassPropertyAnnotation(path);d</span>efault:<span class="cstat-no" title="statement not covered" >return path.getTypeAnnotation();}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span></span></span></span>eturn node.savedTypeAnnotation||node.returnType||node.typeAnnotation||path.getTypeAnnotation();}<span class="fstat-no" title="function not covered" ></span>function createLiteralTypeAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var annotation=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(path.isStringLiteral()){<span class="cstat-no" title="statement not covered" >annotation=t.stringLiteralTypeAnnotation();}</span>else <span class="cstat-no" title="statement not covered" >if(path.isNumericLiteral()){<span class="cstat-no" title="statement not covered" >annotation=t.numericLiteralTypeAnnotation();}</span>else <span class="cstat-no" title="statement not covered" >if(path.isBooleanLiteral()){<span class="cstat-no" title="statement not covered" >annotation=t.booleanLiteralTypeAnnotation();}</span>else {<span class="cstat-no" title="statement not covered" >return path.getTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>a</span></span></span>nnotation.value=path.node.value;<span class="cstat-no" title="statement not covered" >r</span>eturn annotation;}<span class="fstat-no" title="function not covered" ></span>function getObjectPatternAnnotation(path,name){<span class="cstat-no" title="statement not covered" ></span>var annotation=keyByName(getAnnotation(path),name);<span class="cstat-no" title="statement not covered" >v</span>ar found=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(!path.node.properties){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion10=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError10=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError10=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator10=path.get('properties')[Symbol.iterator](),_step10;!(_iteratorNormalCompletion10=(_step10=_iterator10.next()).done);_iteratorNormalCompletion10=true){<span class="cstat-no" title="statement not covered" >var prop=_step10.value;<span class="cstat-no" title="statement not covered" >i</span>f(prop.node.value&amp;&amp;prop.node.value.name===name){<span class="cstat-no" title="statement not covered" >found=prop.get('key');<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>else <span class="cstat-no" title="statement not covered" >if(prop.node.key.type==='Identifier'&amp;&amp;prop.node.key.name===name){<span class="cstat-no" title="statement not covered" >found=prop.get('key');<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError10=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError10=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion10&amp;&amp;_iterator10.return){<span class="cstat-no" title="statement not covered" >_iterator10.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError10){<span class="cstat-no" title="statement not covered" >throw _iteratorError10;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!annotation||!found){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(found.type==='Identifier'){<span class="cstat-no" title="statement not covered" >annotation.value.authoritative=false;<span class="cstat-no" title="statement not covered" >r</span>eturn annotation.value;}</span>}<span class="fstat-no" title="function not covered" ></span>function keyByName(node,name){<span class="cstat-no" title="statement not covered" ></span>if(!node.properties){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion11=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError11=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError11=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator11=node.properties[Symbol.iterator](),_step11;!(_iteratorNormalCompletion11=(_step11=_iterator11.next()).done);_iteratorNormalCompletion11=true){<span class="cstat-no" title="statement not covered" >var prop=_step11.value;<span class="cstat-no" title="statement not covered" >i</span>f(prop.key&amp;&amp;prop.key.name===name){<span class="cstat-no" title="statement not covered" >return prop;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError11=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError11=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion11&amp;&amp;_iterator11.return){<span class="cstat-no" title="statement not covered" >_iterator11.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError11){<span class="cstat-no" title="statement not covered" >throw _iteratorError11;}</span>}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function valueByName(node,name){<span class="cstat-no" title="statement not covered" ></span>if(!node.properties){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion12=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError12=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError12=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator12=node.properties[Symbol.iterator](),_step12;!(_iteratorNormalCompletion12=(_step12=_iterator12.next()).done);_iteratorNormalCompletion12=true){<span class="cstat-no" title="statement not covered" >var prop=_step12.value;<span class="cstat-no" title="statement not covered" >i</span>f(prop.value&amp;&amp;prop.value.name===name){<span class="cstat-no" title="statement not covered" >return prop;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError12=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError12=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion12&amp;&amp;_iterator12.return){<span class="cstat-no" title="statement not covered" >_iterator12.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError12){<span class="cstat-no" title="statement not covered" >throw _iteratorError12;}</span>}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function getSpreadPropertyAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.typeAnnotation||node.savedTypeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(!annotation){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(path.get('argument'));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn annotation;}<span class="fstat-no" title="function not covered" ></span>function getObjectPropertyAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.typeAnnotation||node.savedTypeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(!annotation){<span class="cstat-no" title="statement not covered" >if(node.value){<span class="cstat-no" title="statement not covered" >if(node.value.typeAnnotation||node.value.savedTypeAnnotation){<span class="cstat-no" title="statement not covered" >annotation=node.value.typeAnnotation||node.value.savedTypeAnnotation;}</span>else <span class="cstat-no" title="statement not covered" >if(node.value.type==='BooleanLiteral'||node.value.type==='NumericLiteral'||node.value.type==='StringLiteral'){<span class="cstat-no" title="statement not covered" >annotation=t[node.value.type](node.value.value);}</span>else {<span class="cstat-no" title="statement not covered" >annotation=t.anyTypeAnnotation();}</span>}</span></span>else {<span class="cstat-no" title="statement not covered" >annotation=t.anyTypeAnnotation();}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.objectTypeProperty(node.key,annotation);}<span class="fstat-no" title="function not covered" ></span>function getObjectMethodAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >r</span>eturn t.objectTypeProperty(t.identifier(node.key.name),t.functionTypeAnnotation(null,node.params.map(<span class="fstat-no" title="function not covered" >function(param){<span class="cstat-no" title="statement not covered" ></span>return param.savedTypeAnnotation||param.typeAnnotation;}</span>),null,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation()));}<span class="fstat-no" title="function not covered" ></span>function getThisExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var parent=path.parentPath;<span class="cstat-no" title="statement not covered" >l</span>oop: <span class="cstat-no" title="statement not covered" >while(parent){<span class="cstat-no" title="statement not covered" >switch(parent.type){case 'ClassDeclaration':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent);c</span>ase 'ClassBody':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath);c</span>ase 'ClassMethod':case 'ClassProperty':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath.parentPath);c</span>ase 'ObjectProperty':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath);c</span>ase 'ObjectMethod':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath);c</span>ase 'FunctionExpression':<span class="cstat-no" title="statement not covered" >if(parent.parentPath.type==='ObjectProperty'){<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath.parentPath);}<span class="cstat-no" title="statement not covered" ></span>b</span>reak loop;c</span>ase 'ArrowFunctionExpression':<span class="cstat-no" title="statement not covered" >parent=parent.parentPath;<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(parent.isFunction()){<span class="cstat-no" title="statement not covered" >break;}<span class="cstat-no" title="statement not covered" ></span>p</span>arent=parent.parentPath;}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn t.objectTypeAnnotation([]);}<span class="fstat-no" title="function not covered" ></span>function getClassDeclarationAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var body=path.get('body').get('body').map(getAnnotation).filter(<span class="fstat-no" title="function not covered" >function(annotation){<span class="cstat-no" title="statement not covered" ></span>return annotation&amp;&amp;annotation.type!=='AnyTypeAnnotation';}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn t.objectTypeAnnotation(body);}<span class="fstat-no" title="function not covered" ></span>function getAssignmentExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>if(path.node.operator==='='){<span class="cstat-no" title="statement not covered" >return getAnnotation(path.get('right'));}</span>}<span class="fstat-no" title="function not covered" ></span>function getClassPropertyAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.computed){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar annotation=node.typeAnnotation||(node.value?node.value.savedTypeAnnotation||node.value.typeAnnotation:t.anyTypeAnnotation());<span class="cstat-no" title="statement not covered" >r</span>eturn t.objectTypeProperty(node.key,annotation||t.anyTypeAnnotation());}<span class="fstat-no" title="function not covered" ></span>function getClassMethodAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.computed){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.kind==='get'){<span class="cstat-no" title="statement not covered" >return t.objectTypeProperty(node.key,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation());}</span>else <span class="cstat-no" title="statement not covered" >if(node.kind==='set'){<span class="cstat-no" title="statement not covered" >return t.objectTypeProperty(node.key,node.params.map(<span class="fstat-no" title="function not covered" >function(param){<span class="cstat-no" title="statement not covered" ></span>return param.savedTypeAnnotation||param.typeAnnotation;}</span>).shift()||t.anyTypeAnnotation());}</span>else {<span class="cstat-no" title="statement not covered" >return t.objectTypeProperty(node.key,t.functionTypeAnnotation(null,node.params.map(<span class="fstat-no" title="function not covered" >function(param){<span class="cstat-no" title="statement not covered" ></span>return param.savedTypeAnnotation||param.typeAnnotation||t.anyTypeAnnotation();}</span>),null,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation()));}</span>}<span class="fstat-no" title="function not covered" ></span></span>function getBinaryExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(isBooleanExpression(node)){<span class="cstat-no" title="statement not covered" >return t.booleanTypeAnnotation();}</span>else {<span class="cstat-no" title="statement not covered" >return t.anyTypeAnnotation();}</span>}<span class="fstat-no" title="function not covered" ></span>function getLogicalExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(isBooleanExpression(node)){<span class="cstat-no" title="statement not covered" >return t.booleanTypeAnnotation();}</span>else {<span class="cstat-no" title="statement not covered" >var left=path.get('left');<span class="cstat-no" title="statement not covered" >v</span>ar right=path.get('right');<span class="cstat-no" title="statement not covered" >s</span>witch(node.operator){case '&amp;&amp;':case '||':<span class="cstat-no" title="statement not covered" >var _ref25=[getAnnotation(left),getAnnotation(right)];<span class="cstat-no" title="statement not covered" >l</span>eft=_ref25[0];<span class="cstat-no" title="statement not covered" >r</span>ight=_ref25[1];<span class="cstat-no" title="statement not covered" >i</span>f(t.isUnionTypeAnnotation(left)){<span class="cstat-no" title="statement not covered" >if(t.isUnionTypeAnnotation(right)){<span class="cstat-no" title="statement not covered" >return t.unionTypeAnnotation(left.types.concat(right.types));}</span>else {<span class="cstat-no" title="statement not covered" >return t.unionTypeAnnotation(left.types.concat(right));}</span>}</span>else {<span class="cstat-no" title="statement not covered" >return t.unionTypeAnnotation([left,right]);}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.anyTypeAnnotation();}</span>}<span class="fstat-no" title="function not covered" ></span>function getConditionalExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar consequent=getAnnotation(path.get('consequent'));<span class="cstat-no" title="statement not covered" >v</span>ar alternate=getAnnotation(path.get('alternate'));<span class="cstat-no" title="statement not covered" >i</span>f(t.isUnionTypeAnnotation(consequent)){<span class="cstat-no" title="statement not covered" >if(t.isUnionTypeAnnotation(alternate)){<span class="cstat-no" title="statement not covered" >return t.unionTypeAnnotation(consequent.types.concat(alternate.types));}</span>else {<span class="cstat-no" title="statement not covered" >return t.unionTypeAnnotation(consequent.types.concat(alternate));}</span>}</span>else {<span class="cstat-no" title="statement not covered" >return t.unionTypeAnnotation([consequent,alternate]);}</span>}<span class="fstat-no" title="function not covered" ></span>function getArrayExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>return t.genericTypeAnnotation(t.identifier('Array'),t.typeParameterDeclaration(path.get('elements').map(getAnnotation)));}<span class="fstat-no" title="function not covered" ></span>function getObjectExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var annotation=t.objectTypeAnnotation(path.get('properties').filter(<span class="fstat-no" title="function not covered" >function(prop){<span class="cstat-no" title="statement not covered" ></span>return !prop.node.computed;}</span>).map(getAnnotation).reduce(<span class="fstat-no" title="function not covered" >function(properties,prop){<span class="cstat-no" title="statement not covered" ></span>if(t.isObjectTypeProperty(prop)){<span class="cstat-no" title="statement not covered" >properties.push(prop);}</span>else <span class="cstat-no" title="statement not covered" >if(t.isObjectTypeAnnotation(prop)){<span class="cstat-no" title="statement not covered" >properties.push.apply(properties,_toConsumableArray(prop.properties));}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn properties;}</span>,[]).filter(<span class="fstat-no" title="function not covered" >function(annotation){<span class="cstat-no" title="statement not covered" ></span>return !t.isAnyTypeAnnotation(annotation.value);}</span>));<span class="cstat-no" title="statement not covered" >r</span>eturn annotation;}<span class="fstat-no" title="function not covered" ></span>function getMemberExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>if(path.node.computed){<span class="cstat-no" title="statement not covered" >return getComputedMemberExpressionAnnotation(path);}<span class="cstat-no" title="statement not covered" ></span>v</span>ar stack=[];<span class="cstat-no" title="statement not covered" >v</span>ar target=path;<span class="cstat-no" title="statement not covered" >w</span>hile(target.isMemberExpression()){<span class="cstat-no" title="statement not covered" >stack.push(target);<span class="cstat-no" title="statement not covered" >i</span>f(target.node.computed){<span class="cstat-no" title="statement not covered" >break;}<span class="cstat-no" title="statement not covered" ></span>t</span>arget=target.get('object');}<span class="cstat-no" title="statement not covered" ></span>v</span>ar objectAnnotation=stack.reduceRight(<span class="fstat-no" title="function not covered" >function(last,target){<span class="cstat-no" title="statement not covered" ></span>var annotation=last;<span class="cstat-no" title="statement not covered" >i</span>f(annotation==null){<span class="cstat-no" title="statement not covered" >if(stack.length===1){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(target.get('object'));}</span>else {<span class="cstat-no" title="statement not covered" >return getAnnotation(target);}</span>}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(annotation.type){case 'AnyTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation;c</span>ase 'NullableTypeAnnotation':case 'TypeAnnotation':<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(annotation.type==='GenericTypeAnnotation'){<span class="cstat-no" title="statement not covered" >var typeChecker=getTypeChecker(annotation.id,path.scope);<span class="cstat-no" title="statement not covered" >i</span>f(typeChecker){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(typeChecker);}</span>else {<span class="cstat-no" title="statement not covered" >var binding=path.scope.getBinding(annotation.id.name);<span class="cstat-no" title="statement not covered" >i</span>f(binding){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(binding.path);}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(annotation.type){case 'AnyTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation;c</span>ase 'ObjectTypeAnnotation':<span class="cstat-no" title="statement not covered" >var id=target.get('property').node;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion13=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError13=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError13=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator13=(annotation.properties||[])[Symbol.iterator](),_step13;!(_iteratorNormalCompletion13=(_step13=_iterator13.next()).done);_iteratorNormalCompletion13=true){<span class="cstat-no" title="statement not covered" >var _step13$value=_step13.value;<span class="cstat-no" title="statement not covered" >v</span>ar key=_step13$value.key;<span class="cstat-no" title="statement not covered" >v</span>ar value=_step13$value.value;<span class="cstat-no" title="statement not covered" >i</span>f(key.name===id.name){<span class="cstat-no" title="statement not covered" >return value.type==='VoidTypeAnnotation'||value.type==='NullLiteralTypeAnnotation'?t.anyTypeAnnotation():value;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError13=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError13=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion13&amp;&amp;_iterator13.return){<span class="cstat-no" title="statement not covered" >_iterator13.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError13){<span class="cstat-no" title="statement not covered" >throw _iteratorError13;}</span>}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.anyTypeAnnotation();}</span>,null);<span class="cstat-no" title="statement not covered" >r</span>eturn objectAnnotation||path.getTypeAnnotation();}<span class="fstat-no" title="function not covered" ></span>function getComputedMemberExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var object=path.get('object');<span class="cstat-no" title="statement not covered" >v</span>ar property=path.get('property');<span class="cstat-no" title="statement not covered" >v</span>ar objectAnnotation=getAnnotation(object);<span class="cstat-no" title="statement not covered" >i</span>f(objectAnnotation.type==='TypeAnnotation'||objectAnnotation.type==='NullableTypeAnnotation'){<span class="cstat-no" title="statement not covered" >objectAnnotation=objectAnnotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar propertyAnnotation=getAnnotation(property);<span class="cstat-no" title="statement not covered" >i</span>f(propertyAnnotation.type==='TypeAnnotation'||propertyAnnotation.type==='NullableTypeAnnotation'){<span class="cstat-no" title="statement not covered" >propertyAnnotation=propertyAnnotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _property$evaluate=property.evaluate();<span class="cstat-no" title="statement not covered" >v</span>ar confident=_property$evaluate.confident;<span class="cstat-no" title="statement not covered" >v</span>ar value=_property$evaluate.value;<span class="cstat-no" title="statement not covered" >i</span>f(!confident){<span class="cstat-no" title="statement not covered" >return path.getTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(objectAnnotation.type){case 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(objectAnnotation.types.length===0){<span class="cstat-no" title="statement not covered" >break;}</span>else <span class="cstat-no" title="statement not covered" >if(typeof value==='number'){<span class="cstat-no" title="statement not covered" >if(!objectAnnotation.types[value]){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError('Invalid computed member expression for tuple: '+humanReadableType(objectAnnotation));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn objectAnnotation.types[value];}</span>else {<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError('Invalid computed member expression for tuple: '+humanReadableType(objectAnnotation));}<span class="cstat-no" title="statement not covered" ></span>b</span></span>reak;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn path.getTypeAnnotation();}<span class="fstat-no" title="function not covered" ></span>function getFunctionForIdentifier(path){<span class="cstat-no" title="statement not covered" ></span>if(path.type!=='Identifier'){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar ref=path.scope.getBinding(path.node.name);<span class="cstat-no" title="statement not covered" >i</span>f(!ref){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.isFunction(ref.path.parent)&amp;&amp;ref.path.parentPath;}</span> /**
   * Determine whether the given annotation is for an array.
   */<span class="fstat-no" title="function not covered" >function isStrictlyArrayAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'ArrayTypeAnnotation':case 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return isStrictlyArrayAnnotation(annotation.typeAnnotation);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation.id.name==='Array'?true:null;c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation.types.every(isStrictlyArrayAnnotation);d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareMaybeUnion(annotation,comparator){<span class="cstat-no" title="statement not covered" ></span>var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion14=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError14=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError14=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator14=annotation.types[Symbol.iterator](),_step14;!(_iteratorNormalCompletion14=(_step14=_iterator14.next()).done);_iteratorNormalCompletion14=true){<span class="cstat-no" title="statement not covered" >var _type5=_step14.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=comparator(_type5);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError14=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError14=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion14&amp;&amp;_iterator14.return){<span class="cstat-no" title="statement not covered" >_iterator14.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError14){<span class="cstat-no" title="statement not covered" >throw _iteratorError14;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a number,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeNumberAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeNumberAnnotation(annotation.typeAnnotation);c</span>ase 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'NumericLiteral':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareMaybeUnion(annotation,maybeNumberAnnotation);c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a string,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeStringAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeStringAnnotation(annotation.typeAnnotation);c</span>ase 'StringTypeAnnotation':case 'StringLiteral':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'StringLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'Number':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion15=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError15=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError15=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator15=annotation.types[Symbol.iterator](),_step15;!(_iteratorNormalCompletion15=(_step15=_iterator15.next()).done);_iteratorNormalCompletion15=true){<span class="cstat-no" title="statement not covered" >var _type6=_step15.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeStringAnnotation(_type6);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError15=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError15=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion15&amp;&amp;_iterator15.return){<span class="cstat-no" title="statement not covered" >_iterator15.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError15){<span class="cstat-no" title="statement not covered" >throw _iteratorError15;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a symbol,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeSymbolAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeSymbolAnnotation(annotation.typeAnnotation);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'Number':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;c</span>ase 'Symbol':<span class="cstat-no" title="statement not covered" >return true;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion16=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError16=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError16=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator16=annotation.types[Symbol.iterator](),_step16;!(_iteratorNormalCompletion16=(_step16=_iterator16.next()).done);_iteratorNormalCompletion16=true){<span class="cstat-no" title="statement not covered" >var _type7=_step16.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeSymbolAnnotation(_type7);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError16=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError16=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion16&amp;&amp;_iterator16.return){<span class="cstat-no" title="statement not covered" >_iterator16.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError16){<span class="cstat-no" title="statement not covered" >throw _iteratorError16;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a boolean,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeBooleanAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeBooleanAnnotation(annotation.typeAnnotation);c</span>ase 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'BooleanLiteral':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'String':case 'Number':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion17=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError17=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError17=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator17=annotation.types[Symbol.iterator](),_step17;!(_iteratorNormalCompletion17=(_step17=_iterator17.next()).done);_iteratorNormalCompletion17=true){<span class="cstat-no" title="statement not covered" >var _type8=_step17.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeBooleanAnnotation(_type8);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError17=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError17=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion17&amp;&amp;_iterator17.return){<span class="cstat-no" title="statement not covered" >_iterator17.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError17){<span class="cstat-no" title="statement not covered" >throw _iteratorError17;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a function,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeFunctionAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeFunctionAnnotation(annotation.typeAnnotation);c</span>ase 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Number':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion18=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError18=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError18=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator18=annotation.types[Symbol.iterator](),_step18;!(_iteratorNormalCompletion18=(_step18=_iterator18.next()).done);_iteratorNormalCompletion18=true){<span class="cstat-no" title="statement not covered" >var _type9=_step18.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeFunctionAnnotation(_type9);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError18=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError18=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion18&amp;&amp;_iterator18.return){<span class="cstat-no" title="statement not covered" >_iterator18.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError18){<span class="cstat-no" title="statement not covered" >throw _iteratorError18;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with an undefined or null type,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeNullableAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'NullableTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'MixedTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return maybeNullableAnnotation(annotation.typeAnnotation);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Number':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;c</span>ase 'Generator':<span class="cstat-no" title="statement not covered" >if(annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1){<span class="cstat-no" title="statement not covered" >return maybeNullableAnnotation(annotation.typeParameters.params[1]);}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion19=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError19=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError19=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator19=annotation.types[Symbol.iterator](),_step19;!(_iteratorNormalCompletion19=(_step19=_iterator19.next()).done);_iteratorNormalCompletion19=true){<span class="cstat-no" title="statement not covered" >var _type10=_step19.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeNullableAnnotation(_type10);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError19=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError19=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion19&amp;&amp;_iterator19.return){<span class="cstat-no" title="statement not covered" >_iterator19.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError19){<span class="cstat-no" title="statement not covered" >throw _iteratorError19;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with an object type,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeInstanceOfAnnotation(annotation,expected,typeParameters){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeInstanceOfAnnotation(annotation.typeAnnotation,expected,typeParameters);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(annotation.id.name===expected.name){<span class="cstat-no" title="statement not covered" >if(typeParameters.length===0){<span class="cstat-no" title="statement not covered" >return true;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length){<span class="cstat-no" title="statement not covered" >var trueCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar nullCount=0;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;typeParameters.length&amp;&amp;i&lt;annotation.typeParameters.params.length;i++){<span class="cstat-no" title="statement not covered" >var result=compareAnnotations(typeParameters[i],annotation.typeParameters.params[i]);<span class="cstat-no" title="statement not covered" >i</span>f(result===false){<span class="cstat-no" title="statement not covered" >return false;}</span>else <span class="cstat-no" title="statement not covered" >if(result===true){<span class="cstat-no" title="statement not covered" >trueCount++;}</span>else {<span class="cstat-no" title="statement not covered" >nullCount++;}</span>}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn trueCount&gt;0&amp;&amp;nullCount===0?true:null;}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null;c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion20=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError20=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError20=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator20=annotation.types[Symbol.iterator](),_step20;!(_iteratorNormalCompletion20=(_step20=_iterator20.next()).done);_iteratorNormalCompletion20=true){<span class="cstat-no" title="statement not covered" >var _type11=_step20.value;<span class="cstat-no" title="statement not covered" >v</span>ar _result=maybeInstanceOfAnnotation(_type11,expected,typeParameters);<span class="cstat-no" title="statement not covered" >i</span>f(_result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(_result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError20=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError20=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion20&amp;&amp;_iterator20.return){<span class="cstat-no" title="statement not covered" >_iterator20.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError20){<span class="cstat-no" title="statement not covered" >throw _iteratorError20;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(expected.name==='Array'||expected.name==='RegExp'||expected.name==='Error'||expected.name==='Function'||expected.name==='String'||expected.name==='Object'){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(expected.name==='Array'||expected.name==='RegExp'||expected.name==='Error'||expected.name==='Function'){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(expected.name==='Function'){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with an array,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeArrayAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeArrayAnnotation(annotation.typeAnnotation);c</span>ase 'TupleTypeAnnotation':case 'ArrayTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation.id.name==='Array'?true:null;c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion21=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError21=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError21=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator21=annotation.types[Symbol.iterator](),_step21;!(_iteratorNormalCompletion21=(_step21=_iterator21.next()).done);_iteratorNormalCompletion21=true){<span class="cstat-no" title="statement not covered" >var _type12=_step21.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeArrayAnnotation(_type12);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError21=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError21=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion21&amp;&amp;_iterator21.return){<span class="cstat-no" title="statement not covered" >_iterator21.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError21){<span class="cstat-no" title="statement not covered" >throw _iteratorError21;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with an iterable,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeIterableAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeIterableAnnotation(annotation.typeAnnotation);c</span>ase 'TupleTypeAnnotation':case 'ArrayTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation.id.name==='Iterable'?true:null;c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion22=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError22=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError22=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator22=annotation.types[Symbol.iterator](),_step22;!(_iteratorNormalCompletion22=(_step22=_iterator22.next()).done);_iteratorNormalCompletion22=true){<span class="cstat-no" title="statement not covered" >var _type13=_step22.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeIterableAnnotation(_type13);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError22=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError22=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion22&amp;&amp;_iterator22.return){<span class="cstat-no" title="statement not covered" >_iterator22.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError22){<span class="cstat-no" title="statement not covered" >throw _iteratorError22;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a tuple,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeTupleAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeTupleAnnotation(annotation.typeAnnotation);c</span>ase 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion23=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError23=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError23=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator23=annotation.types[Symbol.iterator](),_step23;!(_iteratorNormalCompletion23=(_step23=_iterator23.next()).done);_iteratorNormalCompletion23=true){<span class="cstat-no" title="statement not covered" >var _type14=_step23.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeTupleAnnotation(_type14);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError23=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError23=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion23&amp;&amp;_iterator23.return){<span class="cstat-no" title="statement not covered" >_iterator23.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError23){<span class="cstat-no" title="statement not covered" >throw _iteratorError23;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'GenericTypeAnnotation':case 'AnyTypeAnnotation':case 'ArrayTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}<span class="fstat-no" title="function not covered" ></span>function humanReadableType(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return humanReadableType(annotation.typeAnnotation);c</span>ase 'FunctionTypeAnnotation': // @fixme babel doesn't seem to like generating FunctionTypeAnnotations yet</span>
<span class="cstat-no" title="statement not covered" >return '('+annotation.params.map(humanReadableType).join(', ')+') =&gt; '+humanReadableType(annotation.returnType);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >var path=getNodePath(annotation);<span class="cstat-no" title="statement not covered" >v</span>ar checker=path&amp;&amp;getTypeChecker(annotation.id,path.scope);<span class="cstat-no" title="statement not covered" >i</span>f(checker&amp;&amp;checker.node.savedTypeAnnotation){<span class="cstat-no" title="statement not covered" >return humanReadableType(checker.node.savedTypeAnnotation);}</span>else {<span class="cstat-no" title="statement not covered" >return (0,_babelGenerator2.default)(annotation).code;}</span>d</span>efault:<span class="cstat-no" title="statement not covered" >return (0,_babelGenerator2.default)(annotation).code;}</span>} /**
   * Get the path directly from a node.
   */<span class="fstat-no" title="function not covered" >function getNodePath(node){<span class="cstat-no" title="statement not covered" ></span>if(node._paths&amp;&amp;node._paths.length){<span class="cstat-no" title="statement not covered" >return node._paths[0];}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function getTypeChecker(id,scope){<span class="cstat-no" title="statement not covered" ></span>var checker=scope.getData('typechecker:'+id.name);<span class="cstat-no" title="statement not covered" >i</span>f(checker){<span class="cstat-no" title="statement not covered" >return checker;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar binding=scope.getBinding(id.name);<span class="cstat-no" title="statement not covered" >i</span>f(binding===undefined){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar path=binding.path;<span class="cstat-no" title="statement not covered" >i</span>f(path==null){<span class="cstat-no" title="statement not covered" >return false;}</span>else <span class="cstat-no" title="statement not covered" >if(path.type==='TypeAlias'){<span class="cstat-no" title="statement not covered" >return path;}</span>else <span class="cstat-no" title="statement not covered" >if(path.type==='VariableDeclaration'&amp;&amp;path.node.isTypeChecker){<span class="cstat-no" title="statement not covered" >return path.get('declarations')[0];}</span>else <span class="cstat-no" title="statement not covered" >if(path.isImportSpecifier()&amp;&amp;path.parent.importKind==='type'){<span class="cstat-no" title="statement not covered" >return path;}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span>eturn false;}<span class="fstat-no" title="function not covered" ></span>function isTypeChecker(id,scope){<span class="cstat-no" title="statement not covered" ></span>return scope.getData('typechecker:'+id.name)!==undefined;}<span class="fstat-no" title="function not covered" ></span>function isPolymorphicType(id,scope){<span class="cstat-no" title="statement not covered" ></span>var binding=scope.getBinding(id.name);<span class="cstat-no" title="statement not covered" >i</span>f(binding!==undefined){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar path=scope.path;<span class="cstat-no" title="statement not covered" >w</span>hile(path&amp;&amp;path.type!=='Program'){<span class="cstat-no" title="statement not covered" >var _path=path;<span class="cstat-no" title="statement not covered" >v</span>ar _node=_path.node;<span class="cstat-no" title="statement not covered" >i</span>f((t.isFunction(_node)||t.isClass(_node))&amp;&amp;_node.typeParameters){<span class="cstat-no" title="statement not covered" >var _iteratorNormalCompletion24=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError24=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError24=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator24=_node.typeParameters.params[Symbol.iterator](),_step24;!(_iteratorNormalCompletion24=(_step24=_iterator24.next()).done);_iteratorNormalCompletion24=true){<span class="cstat-no" title="statement not covered" >var param=_step24.value;<span class="cstat-no" title="statement not covered" >p</span>aram.isPolymorphicType=true;<span class="cstat-no" title="statement not covered" >i</span>f(param.name===id.name){<span class="cstat-no" title="statement not covered" >return true;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError24=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError24=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion24&amp;&amp;_iterator24.return){<span class="cstat-no" title="statement not covered" >_iterator24.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError24){<span class="cstat-no" title="statement not covered" >throw _iteratorError24;}</span>}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>p</span>ath=path.parentPath;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}<span class="fstat-no" title="function not covered" ></span>function getPolymorphicType(id,scope){<span class="cstat-no" title="statement not covered" ></span>var binding=scope.getBinding(id.name);<span class="cstat-no" title="statement not covered" >i</span>f(binding!==undefined){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar path=scope.path;<span class="cstat-no" title="statement not covered" >w</span>hile(path&amp;&amp;path.type!=='Program'){<span class="cstat-no" title="statement not covered" >var _path2=path;<span class="cstat-no" title="statement not covered" >v</span>ar _node2=_path2.node;<span class="cstat-no" title="statement not covered" >i</span>f(t.isFunction(_node2)&amp;&amp;_node2.typeParameters){<span class="cstat-no" title="statement not covered" >var _iteratorNormalCompletion25=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError25=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError25=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator25=_node2.typeParameters.params[Symbol.iterator](),_step25;!(_iteratorNormalCompletion25=(_step25=_iterator25.next()).done);_iteratorNormalCompletion25=true){<span class="cstat-no" title="statement not covered" >var param=_step25.value;<span class="cstat-no" title="statement not covered" >p</span>aram.isPolymorphicType=true;<span class="cstat-no" title="statement not covered" >i</span>f(param.name===id.name){<span class="cstat-no" title="statement not covered" >return param;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError25=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError25=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion25&amp;&amp;_iterator25.return){<span class="cstat-no" title="statement not covered" >_iterator25.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError25){<span class="cstat-no" title="statement not covered" >throw _iteratorError25;}</span>}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>p</span>ath=path.parent;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null;}<span class="fstat-no" title="function not covered" ></span>function collectParamChecks(path,context){<span class="cstat-no" title="statement not covered" ></span>return path.get('params').map(<span class="fstat-no" title="function not covered" >function(param){<span class="cstat-no" title="statement not covered" ></span>var node=param.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='AssignmentPattern'){<span class="cstat-no" title="statement not covered" >if(node.left.typeAnnotation){<span class="cstat-no" title="statement not covered" >return createDefaultParamGuard(param,context);}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='RestElement'){<span class="cstat-no" title="statement not covered" >if(node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return createRestParamGuard(param,context);}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return createParamGuard(param,context);}</span>}</span></span></span>).filter(identity);}<span class="fstat-no" title="function not covered" ></span>function createParamGuard(path,context){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >n</span>ode.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >n</span>ode.savedTypeAnnotation=node.typeAnnotation;<span class="cstat-no" title="statement not covered" >v</span>ar checkable=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='ObjectPattern'){<span class="cstat-no" title="statement not covered" >node.name=path.key;<span class="cstat-no" title="statement not covered" >c</span>heckable=t.memberExpression(t.identifier('arguments'),t.numericLiteral(path.key),true);}</span>else {<span class="cstat-no" title="statement not covered" >checkable=node;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar check=checkAnnotation(checkable,node.typeAnnotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!check){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.optional){<span class="cstat-no" title="statement not covered" >check=t.logicalExpression('||',checks.undefined({input:checkable}),check);}<span class="cstat-no" title="statement not covered" ></span>v</span>ar message=paramTypeErrorMessage(checkable,context,node.typeAnnotation);<span class="cstat-no" title="statement not covered" >r</span>eturn guard({check:check,message:message});}<span class="fstat-no" title="function not covered" ></span>function createDefaultParamGuard(path,context){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.left;<span class="cstat-no" title="statement not covered" >v</span>ar value=node.right;<span class="cstat-no" title="statement not covered" >v</span>ar ok=staticCheckAnnotation(path.get('right'),id.typeAnnotation);<span class="cstat-no" title="statement not covered" >i</span>f(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid default value for argument "'+id.name+'".',id.typeAnnotation,getAnnotation(path.get('right'))));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn createParamGuard(path.get('left'),context);}<span class="fstat-no" title="function not covered" ></span>function createRestParamGuard(path,context){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.argument;<span class="cstat-no" title="statement not covered" >i</span>d.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >n</span>ode.savedTypeAnnotation=node.typeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(isStrictlyArrayAnnotation(node.typeAnnotation)===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid type annotation for rest argument "'+id.name+'".',t.genericTypeAnnotation(t.identifier('Array')),node.typeAnnotation));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar check=checkAnnotation(id,node.typeAnnotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!check){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.optional){<span class="cstat-no" title="statement not covered" >check=t.logicalExpression('||',checks.undefined({input:id}),check);}<span class="cstat-no" title="statement not covered" ></span>v</span>ar message=paramTypeErrorMessage(id,context,node.typeAnnotation);<span class="cstat-no" title="statement not covered" >r</span>eturn guard({check:check,message:message});}<span class="fstat-no" title="function not covered" ></span>function returnTypeErrorMessage(path,fn,id,context){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar name=fn.id?fn.id.name:'';<span class="cstat-no" title="statement not covered" >v</span>ar annotation=fn.returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(fn.generator&amp;&amp;isGeneratorAnnotation(annotation)&amp;&amp;annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters.params[1];}<span class="cstat-no" title="statement not covered" ></span>v</span>ar message='Function '+(name?'"'+name+'" ':'')+'return value violates contract.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn t.binaryExpression('+',t.stringLiteral(message),id?readableName({inspect:context.inspect,input:id}):node.argument?readableName({inspect:context.inspect,input:node.argument}):t.stringLiteral('undefined'));}<span class="fstat-no" title="function not covered" ></span>function yieldTypeErrorMessage(fn,annotation,id,context){<span class="cstat-no" title="statement not covered" ></span>var name=fn.id?fn.id.name:'';<span class="cstat-no" title="statement not covered" >v</span>ar message='Function '+(name?'"'+name+'" ':'')+'yielded an invalid value.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:id}));}<span class="fstat-no" title="function not covered" ></span>function yieldNextTypeErrorMessage(fn,annotation,id,context){<span class="cstat-no" title="statement not covered" ></span>var name=fn.id?fn.id.name:'';<span class="cstat-no" title="statement not covered" >v</span>ar message='Generator '+(name?'"'+name+'" ':'')+'received an invalid next value.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:id}));}<span class="fstat-no" title="function not covered" ></span>function paramTypeErrorMessage(node,context){<span class="cstat-no" title="statement not covered" ></span>var typeAnnotation=arguments.length&lt;=2||arguments[2]===undefined?node.typeAnnotation:arguments[2];<span class="cstat-no" title="statement not covered" >v</span>ar name=node.name;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='MemberExpression'&amp;&amp;node.object.name==='arguments'){<span class="cstat-no" title="statement not covered" >name=node.property.value;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar message='Value of '+(node.optional?'optional ':'')+'argument '+JSON.stringify(name)+' violates contract.\n\nExpected:\n'+humanReadableType(typeAnnotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:node}));}<span class="fstat-no" title="function not covered" ></span>function varTypeErrorMessage(node,context){<span class="cstat-no" title="statement not covered" ></span>var annotation=node.typeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='Identifier'){<span class="cstat-no" title="statement not covered" >var _name3=node.name;<span class="cstat-no" title="statement not covered" >v</span>ar message='Value of variable "'+_name3+'" violates contract.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:node}));}</span>else {<span class="cstat-no" title="statement not covered" >var _message='Value of "'+humanReadableType(node)+'" violates contract.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn t.binaryExpression('+',t.stringLiteral(_message),readableName({inspect:context.inspect,input:node}));}</span>}</span> /**
   * Create a React property validator
   */<span class="fstat-no" title="function not covered" >function generatePropType(annotation,scope,context){<span class="cstat-no" title="statement not covered" ></span>var prop=t.identifier('prop');<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(prop,annotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >return propType({check:check,prop:prop,expected:t.stringLiteral(humanReadableType(annotation)),got:readableName({inspect:context.inspect,input:prop})});}</span>else {<span class="cstat-no" title="statement not covered" >return t.functionExpression(null,[],t.blockStatement([]));}</span>}</span> /**
   * Determine whether the given node can produce purely boolean results.
   */<span class="fstat-no" title="function not covered" >function isBooleanExpression(node){<span class="cstat-no" title="statement not covered" ></span>if(node.type==='BinaryExpression'&amp;&amp;BOOLEAN_BINARY_OPERATORS.indexOf(node.operator)&gt;-1){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='LogicalExpression'){<span class="cstat-no" title="statement not covered" >return isBooleanExpression(node.left)&amp;&amp;isBooleanExpression(node.right);}</span>else {<span class="cstat-no" title="statement not covered" >return false;}</span>}</span></span> /**
   * Convert type specifier to expression.
   */<span class="fstat-no" title="function not covered" >function createTypeExpression(node){<span class="cstat-no" title="statement not covered" ></span>if(node.type=='Identifier'){<span class="cstat-no" title="statement not covered" >return node;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type=='QualifiedTypeIdentifier'){<span class="cstat-no" title="statement not covered" >return t.memberExpression(createTypeExpression(node.qualification),createTypeExpression(node.id));}<span class="cstat-no" title="statement not covered" ></span>t</span></span>hrow this.errorWithNode('Unsupported type: '+node.type);}</span> /**
   * Get name of a type as a string.
   */<span class="fstat-no" title="function not covered" >function getTypeName(node){<span class="cstat-no" title="statement not covered" ></span>if(node.type=='Identifier'){<span class="cstat-no" title="statement not covered" >return node.name;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type=='QualifiedTypeIdentifier'){<span class="cstat-no" title="statement not covered" >return getTypeName(node.qualification)+'.'+getTypeName(node.id);}<span class="cstat-no" title="statement not covered" ></span>t</span></span>hrow this.errorWithNode('Unsupported type: '+node.type);}</span> /**
   * Union two arrays.
   */<span class="fstat-no" title="function not covered" >function union(arr1,arr2){<span class="cstat-no" title="statement not covered" ></span>for(var i=0;i&lt;arr2.length;i++){<span class="cstat-no" title="statement not covered" >var item=arr2[i];<span class="cstat-no" title="statement not covered" >i</span>f(arr1.indexOf(item)===-1){<span class="cstat-no" title="statement not covered" >arr1.push(item);}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn arr1;}</span> /**
   * Determine whether the given annotation allows any value.
   */<span class="fstat-no" title="function not covered" >function allowsAny(annotation){<span class="cstat-no" title="statement not covered" ></span>if(annotation.type==='TypeAnnotation'||annotation.type==='NullableTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return allowsAny(annotation.typeAnnotation);}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.type==='AnyTypeAnnotation'||annotation.type==='MixedTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.type==='UnionTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return annotation.types.some(allowsAny);}</span>else {<span class="cstat-no" title="statement not covered" >return false;}</span>}</span></span></span> /**
   * Determine whether a given node is nully (null or undefined).
   */<span class="fstat-no" title="function not covered" >function isNodeNully(node){<span class="cstat-no" title="statement not covered" ></span>if(node==null){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='Identifier'&amp;&amp;node.name==='undefined'){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='Literal'&amp;&amp;node.value===null){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='UnaryExpression'&amp;&amp;node.operator==='void'){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return false;}</span>}</span></span></span></span> /**
   * Determine whether the file should be checked
   */<span class="fstat-no" title="function not covered" >function mustCheckFile(path,opts){<span class="cstat-no" title="statement not covered" ></span>if(path.node.leadingComments&amp;&amp;path.node.leadingComments.length){<span class="cstat-no" title="statement not covered" >return opts.only&amp;&amp;!skipEnvironment(path.node.leadingComments,opts);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}</span> /**
   * Determine whether the file should be skipped, based on the comments attached to the given node.
   */<span class="fstat-no" title="function not covered" >function maybeSkipFile(path,opts){<span class="cstat-no" title="statement not covered" ></span>if(path.node.leadingComments&amp;&amp;path.node.leadingComments.length){<span class="cstat-no" title="statement not covered" >if(skipEnvironment(path.node.leadingComments,opts)){<span class="cstat-no" title="statement not covered" >return true;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn path.node.leadingComments.some(<span class="fstat-no" title="function not covered" >function(comment){<span class="cstat-no" title="statement not covered" ></span>return PRAGMA_IGNORE_FILE.test(comment.value);}</span>);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}</span> /**
   * Maybe skip the given path if it has a relevant pragma.
   */<span class="fstat-no" title="function not covered" >function maybeSkip(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.hasBeenTypeChecked){<span class="cstat-no" title="statement not covered" >return true;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.leadingComments&amp;&amp;node.leadingComments.length){<span class="cstat-no" title="statement not covered" >var comment=node.leadingComments[node.leadingComments.length-1];<span class="cstat-no" title="statement not covered" >i</span>f(PRAGMA_IGNORE_STATEMENT.test(comment.value)){<span class="cstat-no" title="statement not covered" >path.skip();<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}</span> /**
   * A function that returns its first argument, useful when filtering.
   */<span class="fstat-no" title="function not covered" >function identity(input){<span class="cstat-no" title="statement not covered" ></span>return input;}<span class="fstat-no" title="function not covered" ></span>function getExpression(node){<span class="cstat-no" title="statement not covered" ></span>return t.isExpressionStatement(node)?node.expression:node;}<span class="fstat-no" title="function not covered" ></span>function expression(input){<span class="cstat-no" title="statement not covered" ></span>var fn=template(input);<span class="cstat-no" title="statement not covered" >r</span>eturn <span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var node=fn.apply(undefined,arguments);<span class="cstat-no" title="statement not covered" >r</span>eturn getExpression(node);}</span>;}</span>};var _babelGenerator=require('babel-generator');var _babelGenerator2=_interopRequireDefault(_babelGenerator);function _interopRequireDefault(obj){return obj&amp;&amp;obj.__esModule?obj:<span class="branch-1 cbranch-no" title="branch not covered" >{default:obj};</span>}<span class="fstat-no" title="function not covered" >function _toConsumableArray(arr){<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(arr)){<span class="cstat-no" title="statement not covered" >for(var i=0,arr2=Array(arr.length);i&lt;arr.length;i++){<span class="cstat-no" title="statement not covered" >arr2[i]=arr[i];}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn arr2;}</span>else {<span class="cstat-no" title="statement not covered" >return Array.from(arr);}</span>}</span>
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 23:52:58 GMT+0000 (UTC)</div>
</div>
</body>
</html>


<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/type-checks.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header low">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-babel-plugin-typecheck">npmtest-babel-plugin-typecheck (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/type-checks.js</span></h1>
    <h2>
        
        Statements: <span class="metric">13.7% <small>(10 / 73)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">0% <small>(0 / 85)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">0% <small>(0 / 17)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">13.7% <small>(10 / 73)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../../../../index.html">All files</a> &#187; <a href="index.html">node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/</a> &#187; type-checks.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214</td><td class="line-coverage"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">'use strict';
&nbsp;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = make;
var INVALID = exports.INVALID = 0;
var NEEDS_CHECK = exports.NEEDS_CHECK = 1;
var STATICALLY_VERIFIED = exports.STATICALLY_VERIFIED = 3;
&nbsp;
<span class="fstat-no" title="function not covered" >function make(_ref) {</span>
<span class="cstat-no" title="statement not covered" >  var t = _ref.types;</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >  var ANNOTATION_TYPES = {};</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >  registerAnnotationType('VoidTypeAnnotation', {</span>
    compatible: ['VoidTypeAnnotation', 'NullableTypeAnnotation'],
    checkAnnotation: <span class="fstat-no" title="function not covered" >function checkAnnotation(expected, candidate) {</span>
<span class="cstat-no" title="statement not covered" >      if (candidate.type === 'VoidTypeAnnotation') {</span>
<span class="cstat-no" title="statement not covered" >        return STATICALLY_VERIFIED;</span>
      } else {
<span class="cstat-no" title="statement not covered" >        return NEEDS_CHECK;</span>
      }
    },
    checkValue: <span class="fstat-no" title="function not covered" >function checkValue(expected, candidate) {</span>
<span class="cstat-no" title="statement not covered" >      if (t.isIdentifier(candidate) &amp;&amp; candidate.node.name === 'undefined') {</span>
<span class="cstat-no" title="statement not covered" >        return STATICALLY_VERIFIED;</span>
      } else {
<span class="cstat-no" title="statement not covered" >        switch (candidate.type) {</span>
          case 'NullLiteral':
          case 'ThisExpression':
          case 'NewExpression':
          case 'ObjectExpression':
          case 'ArrayExpression':
          case 'FunctionExpression':
          case 'ArrowFunctionExpression':
          case 'BooleanLiteral':
          case 'NumericLiteral':
          case 'StringLiteral':
          case 'RegExpLiteral':
<span class="cstat-no" title="statement not covered" >            return INVALID;</span>
          case 'Identifier':
<span class="cstat-no" title="statement not covered" >            return candidate.node.name === 'undefined' ? INVALID : NEEDS_CHECK;</span>
          default:
<span class="cstat-no" title="statement not covered" >            return NEEDS_CHECK;</span>
        }
      }
    },
    runtime: <span class="fstat-no" title="function not covered" >function runtime(expected, id) {</span>
<span class="cstat-no" title="statement not covered" >      return id + ' === undefined';</span>
    }
  });
&nbsp;
<span class="cstat-no" title="statement not covered" >  registerAnnotationType('NullLiteralTypeAnnotation', {</span>
    compatible: ['NullLiteralTypeAnnotation', 'NullableTypeAnnotation'],
    checkAnnotation: <span class="fstat-no" title="function not covered" >function checkAnnotation(expected, candidate) {</span>
<span class="cstat-no" title="statement not covered" >      if (candidate.type === 'NullLiteralTypeAnnotation') {</span>
<span class="cstat-no" title="statement not covered" >        return STATICALLY_VERIFIED;</span>
      } else {
<span class="cstat-no" title="statement not covered" >        return NEEDS_CHECK;</span>
      }
    },
    checkValue: <span class="fstat-no" title="function not covered" >function checkValue(expected, candidate) {</span>
<span class="cstat-no" title="statement not covered" >      if (candidate.type === 'Identifier' &amp;&amp; candidate.node.name === 'undefined') {</span>
<span class="cstat-no" title="statement not covered" >        return INVALID;</span>
      } else <span class="cstat-no" title="statement not covered" >if (candidate.type === 'NullLiteral') {</span>
<span class="cstat-no" title="statement not covered" >        return STATICALLY_VERIFIED;</span>
      } else {
<span class="cstat-no" title="statement not covered" >        switch (candidate.type) {</span>
          case 'ThisExpression':
          case 'NewExpression':
          case 'ObjectExpression':
          case 'ArrayExpression':
          case 'FunctionExpression':
          case 'ArrowFunctionExpression':
          case 'BooleanLiteral':
          case 'NumericLiteral':
          case 'StringLiteral':
          case 'RegExpLiteral':
<span class="cstat-no" title="statement not covered" >            return INVALID;</span>
          default:
<span class="cstat-no" title="statement not covered" >            return NEEDS_CHECK;</span>
        }
      }
    },
    runtime: <span class="fstat-no" title="function not covered" >function runtime(expected, id) {</span>
<span class="cstat-no" title="statement not covered" >      return id + ' === null';</span>
    }
  });
&nbsp;
<span class="cstat-no" title="statement not covered" >  registerLiteralAnnotationType('Boolean');</span>
<span class="cstat-no" title="statement not covered" >  registerLiteralAnnotationType('Numeric');</span>
<span class="cstat-no" title="statement not covered" >  registerLiteralAnnotationType('String');</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >  registerAnnotationType('NullableTypeAnnotation', {</span>
    compatible: ['NullableTypeAnnotation', 'NullLiteralTypeAnnotation', 'VoidTypeAnnotation']
&nbsp;
  });
&nbsp;
  /**
   * Register an annotation type with the given name / config.
   */
<span class="fstat-no" title="function not covered" >  function registerAnnotationType(name, config) {</span>
<span class="cstat-no" title="statement not covered" >    ANNOTATION_TYPES[name] = config;</span>
  }
&nbsp;
  /**
   * Register a literal annotation type.
   */
<span class="fstat-no" title="function not covered" >  function registerLiteralAnnotationType(shortName) {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >    var typeName = shortName + 'Literal';</span>
<span class="cstat-no" title="statement not covered" >    var annotationName = shortName + 'TypeAnnotation';</span>
<span class="cstat-no" title="statement not covered" >    var literalAnnotationName = typeName + 'TypeAnnotation';</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >    registerAnnotationType(literalAnnotationName, {</span>
      compatible: [literalAnnotationName, annotationName],
      checkAnnotation: <span class="fstat-no" title="function not covered" >function checkAnnotation(expected, candidate) {</span>
<span class="cstat-no" title="statement not covered" >        if (candidate.type === literalAnnotationName) {</span>
<span class="cstat-no" title="statement not covered" >          if (candidate.value === expected.value) {</span>
<span class="cstat-no" title="statement not covered" >            return STATICALLY_VERIFIED;</span>
          } else {
<span class="cstat-no" title="statement not covered" >            return INVALID;</span>
          }
        } else {
<span class="cstat-no" title="statement not covered" >          return NEEDS_CHECK;</span>
        }
      },
      checkValue: <span class="fstat-no" title="function not covered" >function checkValue(expected, candidate) {</span>
<span class="cstat-no" title="statement not covered" >        if (candidate.type === typeName) {</span>
<span class="cstat-no" title="statement not covered" >          if (candidate.value === expected.value) {</span>
<span class="cstat-no" title="statement not covered" >            return STATICALLY_VERIFIED;</span>
          } else {
<span class="cstat-no" title="statement not covered" >            return INVALID;</span>
          }
        } else {
<span class="cstat-no" title="statement not covered" >          switch (candidate.type) {</span>
            case 'NullLiteral':
            case 'ThisExpression':
            case 'NewExpression':
            case 'ObjectExpression':
            case 'ArrayExpression':
            case 'FunctionExpression':
            case 'ArrowFunctionExpression':
            case 'BooleanLiteral':
            case 'NumericLiteral':
            case 'StringLiteral':
            case 'RegExpLiteral':
<span class="cstat-no" title="statement not covered" >              return INVALID;</span>
            case 'Identifier':
<span class="cstat-no" title="statement not covered" >              return candidate.node.name === 'undefined' ? INVALID : NEEDS_CHECK;</span>
            default:
<span class="cstat-no" title="statement not covered" >              return NEEDS_CHECK;</span>
          }
        }
      },
      runtime: <span class="fstat-no" title="function not covered" >function runtime(expected, id) {</span>
<span class="cstat-no" title="statement not covered" >        return [id + ' === value', { value: expected.value }];</span>
      }
    });
&nbsp;
<span class="cstat-no" title="statement not covered" >    registerAnnotationType(annotationName, {</span>
      compatible: [annotationName, literalAnnotationName],
      checkAnnotation: <span class="fstat-no" title="function not covered" >function checkAnnotation(expected, candidate) {</span>
<span class="cstat-no" title="statement not covered" >        if (candidate.type === literalAnnotationName) {</span>
<span class="cstat-no" title="statement not covered" >          return STATICALLY_VERIFIED;</span>
        } else {
<span class="cstat-no" title="statement not covered" >          return NEEDS_CHECK;</span>
        }
      },
      checkValue: <span class="fstat-no" title="function not covered" >function checkValue(expected, candidate) {</span>
<span class="cstat-no" title="statement not covered" >        if (candidate.type === typeName) {</span>
<span class="cstat-no" title="statement not covered" >          return STATICALLY_VERIFIED;</span>
        } else {
<span class="cstat-no" title="statement not covered" >          switch (candidate.type) {</span>
            case 'NullLiteral':
            case 'ThisExpression':
            case 'NewExpression':
            case 'ObjectExpression':
            case 'ArrayExpression':
            case 'FunctionExpression':
            case 'ArrowFunctionExpression':
            case 'BooleanLiteral':
            case 'NumericLiteral':
            case 'StringLiteral':
            case 'RegExpLiteral':
<span class="cstat-no" title="statement not covered" >              return INVALID;</span>
            case 'Identifier':
<span class="cstat-no" title="statement not covered" >              return candidate.node.name === 'undefined' ? INVALID : NEEDS_CHECK;</span>
            default:
<span class="cstat-no" title="statement not covered" >              return NEEDS_CHECK;</span>
          }
        }
      },
      runtime: <span class="fstat-no" title="function not covered" >function runtime(expected, id) {</span>
<span class="cstat-no" title="statement not covered" >        switch (shortName) {</span>
          case 'String':
<span class="cstat-no" title="statement not covered" >            return 'typeof ' + id + ' === \'string\'';</span>
          case 'Numeric':
<span class="cstat-no" title="statement not covered" >            return 'typeof ' + id + ' === \'number\'';</span>
          case 'Boolean':
<span class="cstat-no" title="statement not covered" >            return 'typeof ' + id + ' === \'boolean\'';</span>
        }
      }
    });
  }
&nbsp;
<span class="fstat-no" title="function not covered" >  function checkStatic(path) {</span>}
&nbsp;
<span class="fstat-no" title="function not covered" >  function checkRuntime(path) {</span>}
&nbsp;
<span class="cstat-no" title="statement not covered" >  return { checkStatic: checkStatic, checkRuntime: checkRuntime };</span>
}
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 23:52:58 GMT+0000 (UTC)</div>
</div>
</body>
</html>


<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/types.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header high">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-babel-plugin-typecheck">npmtest-babel-plugin-typecheck (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/types.js</span></h1>
    <h2>
        
        Statements: <span class="metric">100% <small>(0 / 0)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">100% <small>(0 / 0)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">100% <small>(0 / 0)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">100% <small>(0 / 0)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../../../../index.html">All files</a> &#187; <a href="index.html">node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/</a> &#187; types.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2</td><td class="line-coverage"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 23:52:58 GMT+0000 (UTC)</div>
</div>
</body>
</html>


</div>
</div>
