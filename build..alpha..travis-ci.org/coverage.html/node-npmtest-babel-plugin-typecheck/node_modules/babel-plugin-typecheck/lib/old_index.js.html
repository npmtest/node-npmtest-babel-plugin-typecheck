<!doctype html>
<html lang="en">
<head>
    <title>Code coverage report for node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/old_index.js</title>
    <meta charset="utf-8">
    <style>
        body, html {
            margin:0; padding: 0;
        }
        body {
            font-family: Arial, Helvetica;
            font-size: 10pt;
        }
        div.header, div.footer {
            background: #eee;
            padding: 1em;
        }
        div.header {
            height: 160px;
            padding: 0 1em 0 1em;
            z-index: 100;
            position: fixed;
            top: 0;
            border-bottom: 1px solid #666;
            width: 100%;
        }
        div.footer {
            border-top: 1px solid #666;
        }
        div.body {
            margin-top: 170px;
        }
        div.meta {
            font-size: 90%;
            text-align: center;
        }
        h1, h2, h3 {
            font-weight: normal;
        }
        h1 {
            font-size: 12pt;
        }
        h2 {
            font-size: 10pt;
        }
        pre {
            font-family: Menlo, Monaco, Consolas, Courier New, monospace;
            margin: 0;
            padding: 0;
            font-size: 14px;
            tab-size: 2;
        }

        div.path { font-size: 110%; }
        div.path a:link, div.path a:visited { color: #000; }
        table.coverage { border-collapse: collapse; margin:0; padding: 0 }

        table.coverage td {
            margin: 0;
            padding: 0;
            color: #111;
            vertical-align: top;
        }
        table.coverage td.line-count {
            width: 50px;
            text-align: right;
            padding-right: 5px;
        }
        table.coverage td.line-coverage {
            color: #777 !important;
            text-align: right;
            border-left: 1px solid #666;
            border-right: 1px solid #666;
        }

        table.coverage td.text {
        }

        table.coverage td span.cline-any {
            display: inline-block;
            padding: 0 5px;
            width: 40px;
        }
        table.coverage td span.cline-neutral {
            background: #eee;
        }
        table.coverage td span.cline-yes {
            background: #b5d592;
            color: #999;
        }
        table.coverage td span.cline-no {
            background: #fc8c84;
        }

        .cstat-yes { color: #111; }
        .cstat-no { background: #fc8c84; color: #111; }
        .fstat-no { background: #ffc520; color: #111 !important; }
        .cbranch-no { background:  yellow !important; color: #111; }

        .cstat-skip { background: #ddd; color: #111; }
        .fstat-skip { background: #ddd; color: #111 !important; }
        .cbranch-skip { background: #ddd !important; color: #111; }

        .missing-if-branch {
            display: inline-block;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: black;
            color: yellow;
        }

        .skip-if-branch {
            display: none;
            margin-right: 10px;
            position: relative;
            padding: 0 4px;
            background: #ccc;
            color: white;
        }

        .missing-if-branch .typ, .skip-if-branch .typ {
            color: inherit !important;
        }

        .entity, .metric { font-weight: bold; }
        .metric { display: inline-block; border: 1px solid #333; padding: 0.3em; background: white; }
        .metric small { font-size: 80%; font-weight: normal; color: #666; }

        div.coverage-summary table { border-collapse: collapse; margin: 3em; font-size: 110%; }
        div.coverage-summary td, div.coverage-summary table  th { margin: 0; padding: 0.25em 1em; border-top: 1px solid #666; border-bottom: 1px solid #666; }
        div.coverage-summary th { text-align: left; border: 1px solid #666; background: #eee; font-weight: normal; }
        div.coverage-summary th.file { border-right: none !important; }
        div.coverage-summary th.pic { border-left: none !important; text-align: right; }
        div.coverage-summary th.pct { border-right: none !important; }
        div.coverage-summary th.abs { border-left: none !important; text-align: right; }
        div.coverage-summary td.pct { text-align: right; border-left: 1px solid #666; }
        div.coverage-summary td.abs { text-align: right; font-size: 90%; color: #444; border-right: 1px solid #666; }
        div.coverage-summary td.file { text-align: right; border-left: 1px solid #666; white-space: nowrap;  }
        div.coverage-summary td.pic { min-width: 120px !important;  }
        div.coverage-summary a:link { color: #000; }
        div.coverage-summary a:visited { color: #333; }
        div.coverage-summary tfoot td { border-top: 1px solid #666; }

        div.coverage-summary .yui3-datatable-sort-indicator, div.coverage-summary .dummy-sort-indicator {
            height: 10px;
            width: 7px;
            display: inline-block;
            margin-left: 0.5em;
        }
        div.coverage-summary .yui3-datatable-sort-indicator {
            background: no-repeat scroll 0 0 transparent;
        }
        div.coverage-summary .yui3-datatable-sorted .yui3-datatable-sort-indicator {
            background-position: 0 -20px;
        }
        div.coverage-summary .yui3-datatable-sorted-desc .yui3-datatable-sort-indicator {
            background-position: 0 -10px;
        }

        .high { background: #b5d592 !important; }
        .medium { background: #ffe87c !important; }
        .low { background: #fc8c84 !important; }

        span.cover-fill, span.cover-empty {
            display:inline-block;
            border:1px solid #444;
            background: white;
            height: 12px;
        }
        span.cover-fill {
            background: #ccc;
            border-right: 1px solid #444;
        }
        span.cover-empty {
            background: white;
            border-left: none;
        }
        span.cover-full {
            border-right: none !important;
        }
        pre.prettyprint {
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .com { color: #999 !important; }
        .ignore-none { color: #999; font-weight: normal; }

    </style>
</head>
<body>
<div class="header low">
    <h1 style="font-weight: bold;">
        <a href="https://github.com/npmtest/node-npmtest-babel-plugin-typecheck">npmtest-babel-plugin-typecheck (v0.0.1)</a>
    </h1>
    <h1>Code coverage report for <span class="entity">node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/old_index.js</span></h1>
    <h2>
        
        Statements: <span class="metric">5.92% <small>(116 / 1961)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Branches: <span class="metric">0.19% <small>(3 / 1584)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Functions: <span class="metric">1.16% <small>(2 / 172)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        
        Lines: <span class="metric">86.49% <small>(32 / 37)</small></span> &nbsp;&nbsp;&nbsp;&nbsp;
        
        Ignored: <span class="metric"><span class="ignore-none">none</span></span> &nbsp;&nbsp;&nbsp;&nbsp;
    </h2>
    <div class="path"><a href="../../../../index.html">All files</a> &#187; <a href="index.html">node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/</a> &#187; old_index.js</div>
</div>
<div class="body">
<pre><table class="coverage">
<tr><td class="line-count">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77</td><td class="line-coverage"><span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _slicedToArray=function(){<span class="fstat-no" title="function not covered" >function sliceIterator(arr,i){<span class="cstat-no" title="statement not covered" ></span>var _arr=[];<span class="cstat-no" title="statement not covered" >v</span>ar _n=true;<span class="cstat-no" title="statement not covered" >v</span>ar _d=false;<span class="cstat-no" title="statement not covered" >v</span>ar _e=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){<span class="cstat-no" title="statement not covered" >_arr.push(_s.value);<span class="cstat-no" title="statement not covered" >i</span>f(i&amp;&amp;_arr.length===i)<span class="cstat-no" title="statement not covered" >break;}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_d=true;<span class="cstat-no" title="statement not covered" >_</span>e=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_n&amp;&amp;_i["return"])<span class="cstat-no" title="statement not covered" >_i["return"]();}</span></span>finally {<span class="cstat-no" title="statement not covered" >if(_d)<span class="cstat-no" title="statement not covered" >throw _e;}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _arr;}</span>return <span class="fstat-no" title="function not covered" >function(arr,i){<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(arr)){<span class="cstat-no" title="statement not covered" >return arr;}</span>else <span class="cstat-no" title="statement not covered" >if(Symbol.iterator in Object(arr)){<span class="cstat-no" title="statement not covered" >return sliceIterator(arr,i);}</span>else {<span class="cstat-no" title="statement not covered" >throw new TypeError("Invalid attempt to destructure non-iterable instance");}</span>}</span></span>;}(); /**
 * # Typecheck Transformer
 */exports.default=<span class="fstat-no" title="function not covered" >function(_ref){<span class="cstat-no" title="statement not covered" ></span>var t=_ref.types;<span class="cstat-no" title="statement not covered" >v</span>ar template=_ref.template; </span>/**
   * Binary Operators that can only produce boolean results.
   */<span class="cstat-no" title="statement not covered" >var BOOLEAN_BINARY_OPERATORS=['==','===','&gt;=','&lt;=','&gt;','&lt;','instanceof'];<span class="cstat-no" title="statement not covered" >v</span>ar checks=createChecks();<span class="cstat-no" title="statement not covered" >v</span>ar staticChecks=createStaticChecks();<span class="cstat-no" title="statement not covered" >v</span>ar checkIsArray=expression('Array.isArray(input)');<span class="cstat-no" title="statement not covered" >v</span>ar checkIsMap=expression('input instanceof Map');<span class="cstat-no" title="statement not covered" >v</span>ar checkIsSet=expression('input instanceof Set');<span class="cstat-no" title="statement not covered" >v</span>ar checkIsClass=expression('typeof input === \'function\' &amp;&amp; input.prototype &amp;&amp; input.prototype.constructor === input');<span class="cstat-no" title="statement not covered" >v</span>ar checkIsGenerator=expression('typeof input === \'function\' &amp;&amp; input.generator');<span class="cstat-no" title="statement not covered" >v</span>ar checkIsIterable=expression('input &amp;&amp; (typeof input[Symbol.iterator] === \'function\' || Array.isArray(input))');<span class="cstat-no" title="statement not covered" >v</span>ar checkIsObject=expression('input != null &amp;&amp; typeof input === \'object\'');<span class="cstat-no" title="statement not covered" >v</span>ar checkNotNull=expression('input != null');<span class="cstat-no" title="statement not covered" >v</span>ar checkEquals=expression('input === expected');<span class="cstat-no" title="statement not covered" >v</span>ar declareTypeChecker=template('\n    const id = (function () {\n      function id (input) {\n        return check;\n      };\n      Object.defineProperty(id, Symbol.hasInstance, {\n        value: function (input) {\n          return id(input);\n        }\n      });\n      return id;\n    })();\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar guard=template('\n    if (!check) {\n      throw new TypeError(message);\n    }\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar thrower=template('\n    if (check) {\n      ret;\n    }\n    else {\n      throw new TypeError(message);\n    }\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar guardInline=expression('\n    (id =&gt; {\n      if (!check) {\n        throw new TypeError(message);\n      }\n      return id;\n    })(input)\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar guardFn=expression('\n    function name (id) {\n      if (!check) {\n        throw new TypeError(message);\n      }\n      return id;\n    }\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar readableName=expression('\n    inspect(input)\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar checkMapKeys=expression('\n    input instanceof Map &amp;&amp; Array.from(input.keys()).every(key =&gt; keyCheck)\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar checkMapValues=expression('\n    input instanceof Map &amp;&amp; Array.from(input.values()).every(value =&gt; valueCheck)\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar checkMapEntries=expression('\n    input instanceof Map &amp;&amp; Array.from(input).every(([key, value]) =&gt; keyCheck &amp;&amp; valueCheck)\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar checkSetEntries=expression('\n    input instanceof Set &amp;&amp; Array.from(input).every(value =&gt; valueCheck)\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar checkObjectIndexers=expression('\n    Object.keys(input).every(key =&gt; {\n      const value = input[key];\n      if (~fixedKeys.indexOf(key)) {\n        return true;\n      }\n      else {\n        return check;\n      }\n    });\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar checkObjectIndexersNoFixed=expression('\n    Object.keys(input).every(key =&gt; {\n      const value = input[key];\n      return check;\n    });\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar propType=expression('\n    (function(props, name, component) {\n      var prop = props[name];\n      if(!check) {\n        return new Error(\n          "Invalid prop `" + name + "` supplied to `" + component\n          + "`.\\n\\nExpected:\\n" + expected + "\\n\\nGot:\\n" + got + "\\n\\n"\n        );\n      }\n    })\n  ');<span class="cstat-no" title="statement not covered" >v</span>ar PRAGMA_IGNORE_STATEMENT=/typecheck:\s*ignore\s+statement/i;<span class="cstat-no" title="statement not covered" >v</span>ar PRAGMA_IGNORE_FILE=/typecheck:\s*ignore\s+file/i;<span class="fstat-no" title="function not covered" >f</span>unction skipEnvironment(comments,opts){<span class="cstat-no" title="statement not covered" ></span>if(!opts.only){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar envs=pragmaEnvironments(comments);<span class="cstat-no" title="statement not covered" >r</span>eturn !opts.only.some(<span class="fstat-no" title="function not covered" >function(env){<span class="cstat-no" title="statement not covered" ></span>return envs[env];}</span>);}<span class="fstat-no" title="function not covered" ></span>function pragmaEnvironments(comments){<span class="cstat-no" title="statement not covered" ></span>var pragma=/@typecheck:\s*(.+)/;<span class="cstat-no" title="statement not covered" >v</span>ar environments={};<span class="cstat-no" title="statement not covered" >c</span>omments.forEach(<span class="fstat-no" title="function not covered" >function(comment){<span class="cstat-no" title="statement not covered" ></span>var m=comment.value.match(pragma);<span class="cstat-no" title="statement not covered" >i</span>f(m){<span class="cstat-no" title="statement not covered" >m[1].split(',').forEach(<span class="fstat-no" title="function not covered" >function(env){<span class="cstat-no" title="statement not covered" ></span>return environments[env.trim()]=true;}</span>);}</span>}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn environments;}<span class="cstat-no" title="statement not covered" ></span>var visitors={Statement:<span class="fstat-no" title="function not covered" >function Statement(path){<span class="cstat-no" title="statement not covered" ></span>maybeSkip(path);}</span>,TypeAlias:<span class="fstat-no" title="function not covered" >function TypeAlias(path){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.replaceWith(createTypeAliasChecks(path));}</span>,InterfaceDeclaration:<span class="fstat-no" title="function not covered" >function InterfaceDeclaration(path){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.replaceWith(createInterfaceChecks(path));}</span>,ExportNamedDeclaration:<span class="fstat-no" title="function not covered" >function ExportNamedDeclaration(path){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >i</span>f(node.declaration&amp;&amp;node.declaration.type==='TypeAlias'){<span class="cstat-no" title="statement not covered" >path.replaceWith(t.exportNamedDeclaration(createTypeAliasChecks(path.get('declaration')),[],null));}</span>}</span>,ImportDeclaration:<span class="fstat-no" title="function not covered" >function ImportDeclaration(path){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(path.node.importKind!=='type'){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _path$get$map$reduce=path.get('specifiers').map(<span class="fstat-no" title="function not covered" >function(specifier){<span class="cstat-no" title="statement not covered" ></span>var local=specifier.get('local');<span class="cstat-no" title="statement not covered" >v</span>ar tmpId=path.scope.generateUidIdentifierBasedOnNode(local.node);<span class="cstat-no" title="statement not covered" >v</span>ar replacement=t.importSpecifier(tmpId,specifier.node.imported);<span class="cstat-no" title="statement not covered" >v</span>ar id=t.identifier(local.node.name);<span class="cstat-no" title="statement not covered" >i</span>d.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >v</span>ar declarator=t.variableDeclarator(id,tmpId);<span class="cstat-no" title="statement not covered" >d</span>eclarator.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >r</span>eturn [declarator,replacement];}</span>).reduce(<span class="fstat-no" title="function not covered" >function(_ref2,_ref3){<span class="cstat-no" title="statement not covered" ></span>var _ref5=_slicedToArray(_ref2,2);<span class="cstat-no" title="statement not covered" >v</span>ar declarators=_ref5[0];<span class="cstat-no" title="statement not covered" >v</span>ar specifiers=_ref5[1];<span class="cstat-no" title="statement not covered" >v</span>ar _ref4=_slicedToArray(_ref3,2);<span class="cstat-no" title="statement not covered" >v</span>ar declarator=_ref4[0];<span class="cstat-no" title="statement not covered" >v</span>ar specifier=_ref4[1];<span class="cstat-no" title="statement not covered" >d</span>eclarators.push(declarator);<span class="cstat-no" title="statement not covered" >s</span>pecifiers.push(specifier);<span class="cstat-no" title="statement not covered" >r</span>eturn [declarators,specifiers];}</span>,[[],[]]);<span class="cstat-no" title="statement not covered" >v</span>ar _path$get$map$reduce2=_slicedToArray(_path$get$map$reduce,2);<span class="cstat-no" title="statement not covered" >v</span>ar declarators=_path$get$map$reduce2[0];<span class="cstat-no" title="statement not covered" >v</span>ar specifiers=_path$get$map$reduce2[1];<span class="cstat-no" title="statement not covered" >v</span>ar declaration=t.variableDeclaration('var',declarators);<span class="cstat-no" title="statement not covered" >d</span>eclaration.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >p</span>ath.replaceWithMultiple([t.importDeclaration(specifiers,path.node.source),declaration]);}</span>,ArrowFunctionExpression:<span class="fstat-no" title="function not covered" >function ArrowFunctionExpression(path){</span> // Look for destructuring args with annotations.</span>
<span class="cstat-no" title="statement not covered" >var params=path.get('params');<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator=params[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){<span class="cstat-no" title="statement not covered" >var param=_step.value;<span class="cstat-no" title="statement not covered" >i</span>f(param.isObjectPattern()&amp;&amp;param.node.typeAnnotation){<span class="cstat-no" title="statement not covered" >var _path$get=path.get('body');<span class="cstat-no" title="statement not covered" >v</span>ar _scope=_path$get.scope;<span class="cstat-no" title="statement not covered" >v</span>ar _id=_scope.generateUidIdentifier('arg'+param.key);<span class="cstat-no" title="statement not covered" >v</span>ar pattern=param.node;<span class="cstat-no" title="statement not covered" >p</span>aram.replaceWith(_id);<span class="cstat-no" title="statement not covered" >i</span>f(path.node.expression){<span class="cstat-no" title="statement not covered" >var block=t.blockStatement([t.variableDeclaration('var',[t.variableDeclarator(pattern,_id)]),t.returnStatement(path.get('body').node)]);<span class="cstat-no" title="statement not covered" >p</span>ath.node.body=block;<span class="cstat-no" title="statement not covered" >p</span>ath.node.expression=false;}</span>else {<span class="cstat-no" title="statement not covered" >path.get('body.body')[0].insertBefore(t.variableDeclaration('var',[t.variableDeclarator(pattern,_id)]));}</span>}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion&amp;&amp;_iterator.return){<span class="cstat-no" title="statement not covered" >_iterator.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError){<span class="cstat-no" title="statement not covered" >throw _iteratorError;}</span>}</span>}</span>}</span>,Function:{enter:<span class="fstat-no" title="function not covered" >function enter(path,context){<span class="cstat-no" title="statement not covered" ></span>var _node$body$body;<span class="cstat-no" title="statement not covered" >i</span>f(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar paramChecks=collectParamChecks(path,context);<span class="cstat-no" title="statement not covered" >i</span>f(node.type==="ArrowFunctionExpression"&amp;&amp;node.expression){<span class="cstat-no" title="statement not covered" >node.expression=false;<span class="cstat-no" title="statement not covered" >n</span>ode.body=t.blockStatement([t.returnStatement(node.body)]);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.returnType){<span class="cstat-no" title="statement not covered" >createFunctionReturnGuard(path,context);<span class="cstat-no" title="statement not covered" >c</span>reateFunctionYieldGuards(path,context);}<span class="cstat-no" title="statement not covered" ></span>(</span>_node$body$body=node.body.body).unshift.apply(_node$body$body,_toConsumableArray(paramChecks));<span class="cstat-no" title="statement not covered" >n</span>ode.savedTypeAnnotation=node.returnType;<span class="cstat-no" title="statement not covered" >n</span>ode.returnCount=0;<span class="cstat-no" title="statement not covered" >n</span>ode.yieldCount=0;}</span>,exit:<span class="fstat-no" title="function not covered" >function exit(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar isVoid=node.savedTypeAnnotation?maybeNullableAnnotation(node.savedTypeAnnotation):null;<span class="cstat-no" title="statement not covered" >i</span>f(!node.returnCount&amp;&amp;isVoid===false){<span class="cstat-no" title="statement not covered" >var annotation=node.savedTypeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.generator&amp;&amp;isGeneratorAnnotation(annotation)&amp;&amp;annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters.params[1];}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow path.buildCodeFrameError(buildErrorMessage('Function '+(node.id?'"'+node.id.name+'" ':'')+'did not return a value.',annotation));}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.nextGuardCount){<span class="cstat-no" title="statement not covered" >path.get('body').get('body')[0].insertBefore(node.nextGuard);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.yieldGuardCount){<span class="cstat-no" title="statement not covered" >path.get('body').get('body')[0].insertBefore(node.yieldGuard);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.returnGuardCount){<span class="cstat-no" title="statement not covered" >path.get('body').get('body')[0].insertBefore(node.returnGuard);}</span>}</span>},YieldExpression:<span class="fstat-no" title="function not covered" >function YieldExpression(path,context){<span class="cstat-no" title="statement not covered" ></span>var fn=path.getFunctionParent();<span class="cstat-no" title="statement not covered" >i</span>f(!fn){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>f</span>n.node.yieldCount++;<span class="cstat-no" title="statement not covered" >i</span>f(!isGeneratorAnnotation(fn.node.returnType)||maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar parent=path.parent;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=fn.node.returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='NullableTypeAnnotation'||annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!annotation.typeParameters||annotation.typeParameters.params.length===0){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar yieldType=annotation.typeParameters.params[0];<span class="cstat-no" title="statement not covered" >v</span>ar nextType=annotation.typeParameters.params[2];<span class="cstat-no" title="statement not covered" >v</span>ar ok=staticCheckAnnotation(path.get("argument"),yieldType);<span class="cstat-no" title="statement not covered" >i</span>f(ok===true&amp;&amp;!nextType){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'"'+fn.node.id.name+'" ':'')+'yielded an invalid type.',yieldType,getAnnotation(path.get('argument'))));}<span class="cstat-no" title="statement not covered" ></span>f</span></span>n.node.yieldGuardCount++;<span class="cstat-no" title="statement not covered" >i</span>f(fn.node.yieldGuard){<span class="cstat-no" title="statement not covered" >var _yielder=t.yieldExpression(t.callExpression(fn.node.yieldGuardName,[node.argument||t.identifier('undefined')]));<span class="cstat-no" title="statement not covered" >_</span>yielder.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >i</span>f(fn.node.nextGuard){<span class="cstat-no" title="statement not covered" >fn.node.nextGuardCount++;<span class="cstat-no" title="statement not covered" >p</span>ath.replaceWith(t.callExpression(fn.node.nextGuardName,[_yielder]));}</span>else {<span class="cstat-no" title="statement not covered" >path.replaceWith(_yielder);}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(fn.node.nextGuard){<span class="cstat-no" title="statement not covered" >fn.node.nextGuardCount++;<span class="cstat-no" title="statement not covered" >p</span>ath.replaceWith(t.callExpression(fn.node.nextGuardName,[yielder]));}</span>}</span></span>,ReturnStatement:<span class="fstat-no" title="function not covered" >function ReturnStatement(path,context){<span class="cstat-no" title="statement not covered" ></span>var fn=path.getFunctionParent();<span class="cstat-no" title="statement not covered" >i</span>f(!fn){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>f</span>n.node.returnCount++;<span class="cstat-no" title="statement not covered" >i</span>f(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar parent=path.parent;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar _fn$node=fn.node;<span class="cstat-no" title="statement not covered" >v</span>ar returnType=_fn$node.returnType;<span class="cstat-no" title="statement not covered" >v</span>ar returnGuardName=_fn$node.returnGuardName;<span class="cstat-no" title="statement not covered" >i</span>f(!returnType||!returnGuardName){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!node.argument){<span class="cstat-no" title="statement not covered" >if(maybeNullableAnnotation(returnType)===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'"'+fn.node.id.name+'" ':'')+'did not return a value.',returnType));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar annotation=returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isGeneratorAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1?annotation.typeParameters.params[1]:t.anyTypeAnnotation();}</span>else <span class="cstat-no" title="statement not covered" >if(node.async&amp;&amp;annotation.type==='GenericTypeAnnotation'&amp;&amp;annotation.id.name==='Promise'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters&amp;&amp;annotation.typeParameters[0]||t.anyTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar ok=staticCheckAnnotation(path.get("argument"),annotation);<span class="cstat-no" title="statement not covered" >i</span>f(ok===true){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'"'+fn.node.id.name+'" ':'')+'returned an invalid type.',annotation,getAnnotation(path.get('argument'))));}<span class="cstat-no" title="statement not covered" ></span>f</span></span>n.node.returnGuardCount++;<span class="cstat-no" title="statement not covered" >v</span>ar returner=t.returnStatement(t.callExpression(fn.node.returnGuardName,[node.argument]));<span class="cstat-no" title="statement not covered" >r</span>eturner.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >p</span>ath.replaceWith(returner);}</span>,VariableDeclaration:<span class="fstat-no" title="function not covered" >function VariableDeclaration(path,context){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar collected=[];<span class="cstat-no" title="statement not covered" >v</span>ar declarations=path.get("declarations");<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;node.declarations.length;i++){<span class="cstat-no" title="statement not covered" >var declaration=node.declarations[i];<span class="cstat-no" title="statement not covered" >v</span>ar _id2=declaration.id;<span class="cstat-no" title="statement not covered" >v</span>ar init=declaration.init;<span class="cstat-no" title="statement not covered" >i</span>f(!_id2.typeAnnotation||_id2.hasBeenTypeChecked){<span class="cstat-no" title="statement not covered" >continue;}<span class="cstat-no" title="statement not covered" ></span>_</span>id2.savedTypeAnnotation=_id2.typeAnnotation;<span class="cstat-no" title="statement not covered" >_</span>id2.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >v</span>ar ok=staticCheckAnnotation(declarations[i],_id2.typeAnnotation);<span class="cstat-no" title="statement not covered" >i</span>f(ok===true){<span class="cstat-no" title="statement not covered" >continue;}</span>else <span class="cstat-no" title="statement not covered" >if(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid assignment value for "'+_id2.name+'".',_id2.typeAnnotation,getAnnotation(declarations[i])));}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar check=checkAnnotation(_id2,_id2.typeAnnotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >collected.push(guard({check:check,message:varTypeErrorMessage(_id2,context)}));}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(collected.length&gt;0){<span class="cstat-no" title="statement not covered" >var _check=collected.reduce(<span class="fstat-no" title="function not covered" >function(check,branch){<span class="cstat-no" title="statement not covered" ></span>branch.alternate=check;<span class="cstat-no" title="statement not covered" >r</span>eturn branch;}</span>);<span class="cstat-no" title="statement not covered" >i</span>f(path.parent.type==='Program'||path.parent.type==='BlockStatement'){<span class="cstat-no" title="statement not covered" >path.insertAfter(_check);}</span>else <span class="cstat-no" title="statement not covered" >if(path.parentPath.isForXStatement()||path.parentPath.isForStatement()||path.parentPath.isForInStatement()){<span class="cstat-no" title="statement not covered" >var body=path.parentPath.get('body');<span class="cstat-no" title="statement not covered" >i</span>f(body.type!=='BlockStatement'){<span class="cstat-no" title="statement not covered" >var block=t.blockStatement([body.node]);<span class="cstat-no" title="statement not covered" >b</span>ody.replaceWith(block);<span class="cstat-no" title="statement not covered" >b</span>ody=path.parentPath.get('body');}<span class="cstat-no" title="statement not covered" ></span>v</span>ar children=body.get('body');<span class="cstat-no" title="statement not covered" >i</span>f(children.length===0){<span class="cstat-no" title="statement not covered" >body.replaceWith(_check);}</span>else {<span class="cstat-no" title="statement not covered" >children[0].insertBefore(_check);}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(path.parent.type==='ExportNamedDeclaration'||path.parent.type==='ExportDefaultDeclaration'||path.parent.type==='ExportAllDeclaration'){<span class="cstat-no" title="statement not covered" >path.parentPath.insertAfter(_check);}</span>else {<span class="cstat-no" title="statement not covered" >path.replaceWith(t.blockStatement([node,_check]));}</span>}</span></span></span>}</span>,AssignmentExpression:<span class="fstat-no" title="function not covered" >function AssignmentExpression(path,context){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar left=path.get('left');<span class="cstat-no" title="statement not covered" >v</span>ar annotation=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(node.hasBeenTypeChecked||node.left.hasBeenTypeChecked){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(left.isMemberExpression()){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(left);}</span>else <span class="cstat-no" title="statement not covered" >if(t.isIdentifier(node.left)){<span class="cstat-no" title="statement not covered" >var binding=scope.getBinding(node.left.name);<span class="cstat-no" title="statement not covered" >i</span>f(!binding){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(binding.path.type!=='VariableDeclarator'){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>a</span></span>nnotation=left.getTypeAnnotation();<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='AnyTypeAnnotation'){<span class="cstat-no" title="statement not covered" >var item=binding.path.get('id');<span class="cstat-no" title="statement not covered" >a</span>nnotation=item.node.savedTypeAnnotation||item.getTypeAnnotation();}</span>}</span>else {<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>n</span></span></span>ode.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >n</span>ode.left.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.left;<span class="cstat-no" title="statement not covered" >v</span>ar right=path.get('right');<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='AnyTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar ok=staticCheckAnnotation(right,annotation);<span class="cstat-no" title="statement not covered" >i</span>f(ok===true){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid assignment value for "'+humanReadableType(id)+'".',annotation,getAnnotation(right)));}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar check=checkAnnotation(id,annotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!id.typeAnnotation){<span class="cstat-no" title="statement not covered" >id.typeAnnotation=annotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>d.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >var parent=path.getStatementParent();<span class="cstat-no" title="statement not covered" >p</span>arent.insertAfter(guard({check:check,message:varTypeErrorMessage(id,context)}));}</span>}</span>,TypeCastExpression:<span class="fstat-no" title="function not covered" >function TypeCastExpression(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar target=void 0;<span class="cstat-no" title="statement not covered" >s</span>witch(node.expression.type){case 'Identifier':<span class="cstat-no" title="statement not covered" >target=node.expression;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 'AssignmentExpression':<span class="cstat-no" title="statement not covered" >target=node.expression.left;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault: // unsupported.</span>
<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>var id=path.scope.getBindingIdentifier(target.name);<span class="cstat-no" title="statement not covered" >i</span>f(!id){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>d.savedTypeAnnotation=path.getTypeAnnotation();}</span>,ForOfStatement:<span class="fstat-no" title="function not covered" >function ForOfStatement(path,context){<span class="cstat-no" title="statement not covered" ></span>if(maybeSkip(path)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar left=path.get('left');<span class="cstat-no" title="statement not covered" >v</span>ar right=path.get('right');<span class="cstat-no" title="statement not covered" >v</span>ar rightAnnotation=getAnnotation(right);<span class="cstat-no" title="statement not covered" >v</span>ar leftAnnotation=left.isVariableDeclaration()?getAnnotation(left.get('declarations')[0].get('id')):getAnnotation(left);<span class="cstat-no" title="statement not covered" >i</span>f(rightAnnotation.type!=='VoidTypeAnnotation'&amp;&amp;rightAnnotation.type!=='NullLiteralTypeAnnotation'){<span class="cstat-no" title="statement not covered" >var ok=maybeIterableAnnotation(rightAnnotation);<span class="cstat-no" title="statement not covered" >i</span>f(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError('Cannot iterate '+humanReadableType(rightAnnotation)+'.');}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar id=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(right.isIdentifier()){<span class="cstat-no" title="statement not covered" >id=right.node;}</span>else {<span class="cstat-no" title="statement not covered" >id=path.scope.generateUidIdentifierBasedOnNode(right.node);<span class="cstat-no" title="statement not covered" >p</span>ath.scope.push({id:id});<span class="cstat-no" title="statement not covered" >v</span>ar replacement=t.expressionStatement(t.assignmentExpression('=',id,right.node));<span class="cstat-no" title="statement not covered" >p</span>ath.insertBefore(replacement);<span class="cstat-no" title="statement not covered" >r</span>ight.replaceWith(id);}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.insertBefore(guard({check:checks.iterable({input:id}),message:t.binaryExpression('+',t.stringLiteral('Expected '+humanReadableType(right.node)+' to be iterable, got '),readableName({inspect:context.inspect,input:id}))}));<span class="cstat-no" title="statement not covered" >i</span>f(rightAnnotation.type!=='GenericTypeAnnotation'||rightAnnotation.id.name!=='Iterable'||!rightAnnotation.typeParameters||!rightAnnotation.typeParameters.params.length){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar annotation=rightAnnotation.typeParameters.params[0];<span class="cstat-no" title="statement not covered" >i</span>f(compareAnnotations(annotation,leftAnnotation)===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid iterator type.',annotation,leftAnnotation));}</span>}</span>,ClassDeclaration:<span class="fstat-no" title="function not covered" >function ClassDeclaration(path,context){</span> // Convert React props to propTypes
<span class="cstat-no" title="statement not covered" >if(!path.node.superClass){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar props=void 0;<span class="cstat-no" title="statement not covered" >v</span>ar hasRenderMethod=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion2=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError2=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError2=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator2=path.get('body.body')[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=true){<span class="cstat-no" title="statement not covered" >var memberPath=_step2.value;<span class="cstat-no" title="statement not covered" >v</span>ar classMember=memberPath.node;<span class="cstat-no" title="statement not covered" >i</span>f(t.isClassProperty(classMember)){<span class="cstat-no" title="statement not covered" >if(classMember.key.name==='propTypes'&amp;&amp;classMember.static){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(classMember.key.name==='props'&amp;&amp;!classMember.static){<span class="cstat-no" title="statement not covered" >props=memberPath;}</span>}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(t.isClassMethod(classMember)&amp;&amp;classMember.key.name==='render'){<span class="cstat-no" title="statement not covered" >hasRenderMethod=true;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError2=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError2=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion2&amp;&amp;_iterator2.return){<span class="cstat-no" title="statement not covered" >_iterator2.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError2){<span class="cstat-no" title="statement not covered" >throw _iteratorError2;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>v</span>ar type=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(path.node.superTypeParameters){<span class="cstat-no" title="statement not covered" >if(path.node.superTypeParameters.params.length!==3){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>t</span>ype=path.node.superTypeParameters.params[1];}<span class="cstat-no" title="statement not covered" ></span>i</span>f(props){<span class="cstat-no" title="statement not covered" >type=props.node.typeAnnotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!type||!hasRenderMethod){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t.isGenericTypeAnnotation(type)){<span class="cstat-no" title="statement not covered" >var binding=path.scope.getBinding(type.id.name);<span class="cstat-no" title="statement not covered" >t</span>ype=getAnnotation(binding.path);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!t.isObjectTypeAnnotation(type)){<span class="cstat-no" title="statement not covered" >return;}</span> </span>// Now we have a class that has a superclass, an instance method called 'render'
// and some property type annotations. We can be reasonably sure it's a React component.
<span class="cstat-no" title="statement not covered" >var propTypes=t.objectExpression(type.properties.map(<span class="fstat-no" title="function not covered" >function(prop){<span class="cstat-no" title="statement not covered" ></span>return t.objectProperty(t.identifier(prop.key.name),generatePropType(prop.value,path.scope,context));}</span>));<span class="cstat-no" title="statement not covered" >i</span>f(path.node.decorators){<span class="cstat-no" title="statement not covered" >var property=t.classProperty(t.identifier('propTypes'),propTypes);<span class="cstat-no" title="statement not covered" >p</span>roperty.static=true;<span class="cstat-no" title="statement not covered" >p</span>rops.insertAfter(property);}</span>else {<span class="cstat-no" title="statement not covered" >var root=path.parentPath.isExportDeclaration()?path.parentPath:path;<span class="cstat-no" title="statement not covered" >r</span>oot.insertAfter(t.expressionStatement(t.assignmentExpression("=",t.memberExpression(path.node.id,t.identifier("propTypes")),propTypes)));}</span>}</span>}; /**
   * Collect all the type declarations in the given path and add references to them for retreival later.
   */<span class="fstat-no" title="function not covered" >function collectTypes(path){<span class="cstat-no" title="statement not covered" ></span>path.traverse({TypeAlias:<span class="fstat-no" title="function not covered" >function TypeAlias(path){<span class="cstat-no" title="statement not covered" ></span>path.scope.setData('typechecker:'+path.node.id.name,path.node);}</span>,ImportDeclaration:<span class="fstat-no" title="function not covered" >function ImportDeclaration(path){<span class="cstat-no" title="statement not covered" ></span>if(path.node.importKind!=='type'){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>p</span>ath.get('specifiers').forEach(<span class="fstat-no" title="function not covered" >function(specifier){<span class="cstat-no" title="statement not covered" ></span>var local=specifier.get('local');<span class="cstat-no" title="statement not covered" >p</span>ath.scope.setData('typechecker:'+local.node.id.name,specifier.node);}</span>);}</span>});}<span class="cstat-no" title="statement not covered" ></span>return {visitor:{Program:<span class="fstat-no" title="function not covered" >function Program(path,_ref6){<span class="cstat-no" title="statement not covered" ></span>var opts=_ref6.opts;<span class="cstat-no" title="statement not covered" >i</span>f(opts&amp;&amp;opts.disable&amp;&amp;opts.disable[process.env.NODE_ENV]){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar checkFile=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion3=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError3=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError3=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator3=path.get('body')[Symbol.iterator](),_step3;!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=true){<span class="cstat-no" title="statement not covered" >var _child=_step3.value;<span class="cstat-no" title="statement not covered" >i</span>f(mustCheckFile(_child,opts)){<span class="cstat-no" title="statement not covered" >checkFile=true;<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError3=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError3=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion3&amp;&amp;_iterator3.return){<span class="cstat-no" title="statement not covered" >_iterator3.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError3){<span class="cstat-no" title="statement not covered" >throw _iteratorError3;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!checkFile){<span class="cstat-no" title="statement not covered" >var _iteratorNormalCompletion4=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError4=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError4=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator4=path.get('body')[Symbol.iterator](),_step4;!(_iteratorNormalCompletion4=(_step4=_iterator4.next()).done);_iteratorNormalCompletion4=true){<span class="cstat-no" title="statement not covered" >var child=_step4.value;<span class="cstat-no" title="statement not covered" >i</span>f(maybeSkipFile(child,opts)){<span class="cstat-no" title="statement not covered" >return;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError4=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError4=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion4&amp;&amp;_iterator4.return){<span class="cstat-no" title="statement not covered" >_iterator4.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError4){<span class="cstat-no" title="statement not covered" >throw _iteratorError4;}</span>}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>c</span>ollectTypes(path);<span class="cstat-no" title="statement not covered" >v</span>ar inspect=path.scope.generateUidIdentifier('inspect');<span class="cstat-no" title="statement not covered" >v</span>ar requiresHelpers={inspect:false};<span class="cstat-no" title="statement not covered" >v</span>ar context={get inspect<span class="fstat-no" title="function not covered" >(){<span class="cstat-no" title="statement not covered" ></span>requiresHelpers.inspect=true;<span class="cstat-no" title="statement not covered" >r</span>eturn inspect;}</span>};<span class="cstat-no" title="statement not covered" >p</span>ath.traverse(visitors,context);<span class="cstat-no" title="statement not covered" >i</span>f(requiresHelpers.inspect){<span class="cstat-no" title="statement not covered" >var body=path.get('body');<span class="cstat-no" title="statement not covered" >b</span>ody[body.length-1].insertAfter(template('\n            function id (input, depth) {\n              const maxDepth = 4;\n              const maxKeys = 15;\n              if (depth === undefined) {\n                depth = 0;\n              }\n              depth += 1;\n              if (input === null) {\n                return \'null\';\n              }\n              else if (input === undefined) {\n                return \'void\';\n              }\n              else if (typeof input === \'string\' || typeof input === \'number\' || typeof input === \'boolean\') {\n                return typeof input;\n              }\n              else if (Array.isArray(input)) {\n                if (input.length &gt; 0) {\n                  if (depth &gt; maxDepth) return \'[...]\';\n                  const first = id(input[0], depth);\n                  if (input.every(item =&gt; id(item, depth) === first)) {\n                    return first.trim() + \'[]\';\n                  }\n                  else {\n                    return \'[\' + input.slice(0, maxKeys).map(item =&gt; id(item, depth)).join(\', \') + (input.length &gt;= maxKeys ? \', ...\' : \'\') + \']\';\n                  }\n                }\n                else {\n                  return \'Array\';\n                }\n              }\n              else {\n                const keys = Object.keys(input);\n                if (!keys.length) {\n                  if (input.constructor &amp;&amp; input.constructor.name &amp;&amp; input.constructor.name !== \'Object\') {\n                    return input.constructor.name;\n                  }\n                  else {\n                    return \'Object\';\n                  }\n                }\n                if (depth &gt; maxDepth) return \'{...}\';\n                const indent = \'  \'.repeat(depth - 1);\n                let entries = keys.slice(0, maxKeys).map(key =&gt; {\n                  return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key) ? key : JSON.stringify(key)) + \': \' + id(input[key], depth) + \';\';\n                }).join(\'\\n  \' + indent);\n                if (keys.length &gt;= maxKeys) {\n                  entries += \'\\n  \' + indent + \'...\';\n                }\n                if (input.constructor &amp;&amp; input.constructor.name &amp;&amp; input.constructor.name !== \'Object\') {\n                  return input.constructor.name + \' {\\n  \' + indent + entries + \'\\n\' + indent + \'}\';\n                }\n                else {\n                  return \'{\\n  \' + indent + entries + \'\\n\' + indent + \'}\';\n                }\n              }\n            }\n          ')({id:inspect}));}</span>}</span>}}; </span>/**
   * Create a function which can verify the return type for a function.
   */<span class="fstat-no" title="function not covered" >function createFunctionReturnGuard(path,context){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(isGeneratorAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1?annotation.typeParameters.params[1]:t.anyTypeAnnotation();}</span>else <span class="cstat-no" title="statement not covered" >if(node.async&amp;&amp;annotation.type==='GenericTypeAnnotation'&amp;&amp;annotation.id.name==='Promise'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters&amp;&amp;annotation.typeParameters[0]||t.anyTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>v</span></span>ar name=scope.generateUidIdentifierBasedOnNode(node);<span class="cstat-no" title="statement not covered" >v</span>ar id=scope.generateUidIdentifier('id');<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(id,annotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >node.returnGuard=guardFn({id:id,name:name,check:check,message:returnTypeErrorMessage(path,path.node,id,context)});<span class="cstat-no" title="statement not covered" >n</span>ode.returnGuard.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >n</span>ode.returnGuardName=name;<span class="cstat-no" title="statement not covered" >n</span>ode.returnGuardCount=0;}</span>}<span class="fstat-no" title="function not covered" ></span>function createFunctionYieldGuards(path,context){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='NullableTypeAnnotation'||annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!annotation.typeParameters||annotation.typeParameters.params.length===0){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!isGeneratorAnnotation(annotation)){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar yieldType=annotation.typeParameters.params[0];<span class="cstat-no" title="statement not covered" >v</span>ar nextType=annotation.typeParameters.params[2];<span class="cstat-no" title="statement not covered" >i</span>f(yieldType){<span class="cstat-no" title="statement not covered" >var _name=scope.generateUidIdentifier('check'+(node.id?node.id.name.slice(0,1).toUpperCase()+node.id.name.slice(1):'')+'Yield');<span class="cstat-no" title="statement not covered" >v</span>ar _id3=scope.generateUidIdentifier('id');<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(_id3,yieldType,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >node.yieldGuard=guardFn({id:_id3,name:_name,check:check,message:yieldTypeErrorMessage(node,yieldType,_id3,context)});<span class="cstat-no" title="statement not covered" >n</span>ode.yieldGuardName=_name;<span class="cstat-no" title="statement not covered" >n</span>ode.yieldGuardCount=0;}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(nextType){<span class="cstat-no" title="statement not covered" >var _name2=scope.generateUidIdentifier('check'+(node.id?node.id.name.slice(0,1).toUpperCase()+node.id.name.slice(1):'')+'Next');<span class="cstat-no" title="statement not covered" >v</span>ar _id4=scope.generateUidIdentifier('id');<span class="cstat-no" title="statement not covered" >v</span>ar _check2=checkAnnotation(_id4,nextType,scope);<span class="cstat-no" title="statement not covered" >i</span>f(_check2){<span class="cstat-no" title="statement not covered" >node.nextGuard=guardFn({id:_id4,name:_name2,check:_check2,message:yieldNextTypeErrorMessage(node,nextType,_id4,context)});<span class="cstat-no" title="statement not covered" >n</span>ode.nextGuardName=_name2;<span class="cstat-no" title="statement not covered" >n</span>ode.nextGuardCount=0;}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function isThisMemberExpression(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='ThisExpression'){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='MemberExpression'){<span class="cstat-no" title="statement not covered" >return isThisMemberExpression(path.get('object'));}</span>else {<span class="cstat-no" title="statement not covered" >return false;}</span>}<span class="fstat-no" title="function not covered" ></span></span>function isGeneratorAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>if(!annotation){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(annotation.type==='TypeAnnotation'||annotation.type==='NullableTypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn annotation.type==='GenericTypeAnnotation'&amp;&amp;annotation.id.name==='Generator';}<span class="fstat-no" title="function not covered" ></span>function buildErrorMessage(message,expected,got){<span class="cstat-no" title="statement not covered" ></span>if(got){<span class="cstat-no" title="statement not covered" >return message+'\n\nExpected:\n'+humanReadableType(expected)+'\n\nGot:\n'+humanReadableType(got);}</span>else {<span class="cstat-no" title="statement not covered" >return message+'\n\nExpected:\n'+humanReadableType(expected);}</span>}<span class="fstat-no" title="function not covered" ></span>function createChecks(){<span class="cstat-no" title="statement not covered" ></span>return {number:expression('typeof input === \'number\''),numericLiteral:checkNumericLiteral,boolean:expression('typeof input === \'boolean\''),booleanLiteral:checkBooleanLiteral,class:checkClass,function:expression('typeof input === \'function\''),string:expression('typeof input === \'string\''),stringLiteral:checkStringLiteral,symbol:expression('typeof input === \'symbol\''),undefined:expression('input === undefined'),null:expression('input === null'),void:expression('input == null'),instanceof:expression('input instanceof type'),type:expression('type(input)'),mixed:<span class="fstat-no" title="function not covered" >function mixed(){<span class="cstat-no" title="statement not covered" ></span>return null;}</span>,any:<span class="fstat-no" title="function not covered" >function any(){<span class="cstat-no" title="statement not covered" ></span>return null;}</span>,union:checkUnion,intersection:checkIntersection,array:checkArray,map:checkMap,set:checkSet,generator:checkGenerator,iterable:checkIterable,tuple:checkTuple,object:checkObject,nullable:checkNullable,typeof:checkTypeof,int8:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= -128 &amp;&amp; input &lt;= 127 &amp;&amp; input === Math.floor(input)'),uint8:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= 0 &amp;&amp; input &lt;= 255 &amp;&amp; input === Math.floor(input)'),int16:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= -32768 &amp;&amp; input &lt;= 32767 &amp;&amp; input === Math.floor(input)'),uint16:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= 0 &amp;&amp; input &lt;= 65535 &amp;&amp; input === Math.floor(input)'),int32:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= -2147483648 &amp;&amp; input &lt;= 2147483647 &amp;&amp; input === Math.floor(input)'),uint32:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= 0 &amp;&amp; input &lt;= 4294967295 &amp;&amp; input === Math.floor(input)'),float32:expression('typeof input === \'number\' &amp;&amp; !isNaN(input) &amp;&amp; input &gt;= -3.40282347e+38 &amp;&amp; input &lt;= 3.40282347e+38'),float64:expression('typeof input === \'number\' &amp;&amp; !isNaN(input)'),double:expression('typeof input === \'number\' &amp;&amp; !isNaN(input)')};}<span class="fstat-no" title="function not covered" ></span>function createStaticChecks(){<span class="cstat-no" title="statement not covered" ></span>return {symbol:<span class="fstat-no" title="function not covered" >function symbol(path){<span class="cstat-no" title="statement not covered" ></span>return maybeSymbolAnnotation(getAnnotation(path));}</span>,instanceof:<span class="fstat-no" title="function not covered" >function _instanceof(_ref7){<span class="cstat-no" title="statement not covered" ></span>var path=_ref7.path;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref7.annotation;<span class="cstat-no" title="statement not covered" >v</span>ar type=createTypeExpression(annotation.id);<span class="cstat-no" title="statement not covered" >v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >i</span>f(type.name==='Object'&amp;&amp;node.type==='ObjectExpression'&amp;&amp;!scope.getBinding('Object')){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='Map'&amp;&amp;!scope.getBinding('Map')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='Set'&amp;&amp;!scope.getBinding('Set')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='Class'&amp;&amp;!scope.hasBinding('Class')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='int8'&amp;&amp;!scope.hasBinding('int8')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='uint8'&amp;&amp;!scope.hasBinding('uint8')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='int16'&amp;&amp;!scope.hasBinding('int16')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='uint16'&amp;&amp;!scope.hasBinding('uint16')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='int32'&amp;&amp;!scope.hasBinding('int32')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='uint32'&amp;&amp;!scope.hasBinding('uint32')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='float32'&amp;&amp;!scope.hasBinding('float32')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='float64'&amp;&amp;!scope.hasBinding('float64')){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(type.name==='double'&amp;&amp;!scope.hasBinding('double')){<span class="cstat-no" title="statement not covered" >return null;}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span></span></span></span></span></span></span></span></span></span>eturn maybeInstanceOfAnnotation(getAnnotation(path),type,annotation.typeParameters?annotation.typeParameters.params:[]);}</span>,type:<span class="fstat-no" title="function not covered" >function(_type){<span class="fstat-no" title="function not covered" ></span>function type(_x){<span class="cstat-no" title="statement not covered" ></span>return _type.apply(this,arguments);}<span class="cstat-no" title="statement not covered" ></span>type.toString=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>return _type.toString();}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn type;}</span>(<span class="fstat-no" title="function not covered" >function(_ref8){<span class="cstat-no" title="statement not covered" ></span>var path=_ref8.path;<span class="cstat-no" title="statement not covered" >v</span>ar type=_ref8.type;<span class="cstat-no" title="statement not covered" >r</span>eturn null;}</span>)};}<span class="fstat-no" title="function not covered" ></span>function compareAnnotations(a,b){<span class="cstat-no" title="statement not covered" ></span>if(a.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >a=a.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(b.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >b=b.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(a.type){case 'StringTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeStringAnnotation(b);c</span>ase 'StringLiteral':case 'StringLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareStringLiteralAnnotations(a,b);c</span>ase 'NumberTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeNumberAnnotation(b);c</span>ase 'NumericLiteral':case 'NumericLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareNumericLiteralAnnotations(a,b);c</span>ase 'BooleanTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeBooleanAnnotation(b);c</span>ase 'BooleanLiteral':case 'BooleanLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareBooleanLiteralAnnotations(a,b);c</span>ase 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeFunctionAnnotation(b);c</span>ase 'AnyTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;c</span>ase 'MixedTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;c</span>ase 'ObjectTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareObjectAnnotation(a,b);c</span>ase 'ArrayTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareArrayAnnotation(a,b);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareGenericAnnotation(a,b);c</span>ase 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareTupleAnnotation(a,b);c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareUnionAnnotation(a,b);c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareIntersectionAnnotation(a,b);c</span>ase 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareNullableAnnotation(a,b);d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareStringLiteralAnnotations(a,b){<span class="cstat-no" title="statement not covered" ></span>if(b.type==='StringLiteralTypeAnnotation'||b.type==='StringLiteral'){<span class="cstat-no" title="statement not covered" >return a.value===b.value;}</span>else {<span class="cstat-no" title="statement not covered" >return maybeStringAnnotation(b)===false?false:null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareBooleanLiteralAnnotations(a,b){<span class="cstat-no" title="statement not covered" ></span>if(b.type==='BooleanLiteralTypeAnnotation'||b.type==='BooleanLiteral'){<span class="cstat-no" title="statement not covered" >return a.value===b.value;}</span>else {<span class="cstat-no" title="statement not covered" >return maybeBooleanAnnotation(b)===false?false:null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareNumericLiteralAnnotations(a,b){<span class="cstat-no" title="statement not covered" ></span>if(b.type==='NumericLiteralTypeAnnotation'||b.type==='NumericLiteral'){<span class="cstat-no" title="statement not covered" >return a.value===b.value;}</span>else {<span class="cstat-no" title="statement not covered" >return maybeNumberAnnotation(b)===false?false:null;}</span>}<span class="fstat-no" title="function not covered" ></span>function unionComparer(a,b,comparator){<span class="cstat-no" title="statement not covered" ></span>if(!a.types||a.types.length===0){<span class="cstat-no" title="statement not covered" >return null;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar trueCount=0;<span class="cstat-no" title="statement not covered" >i</span>f(!a.types){<span class="cstat-no" title="statement not covered" >return null;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion5=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError5=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError5=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator5=a.types[Symbol.iterator](),_step5;!(_iteratorNormalCompletion5=(_step5=_iterator5.next()).done);_iteratorNormalCompletion5=true){<span class="cstat-no" title="statement not covered" >var _type2=_step5.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=comparator(_type2,b);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >if(b.type!=='UnionTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return true;}<span class="cstat-no" title="statement not covered" ></span>t</span>rueCount++;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >if(b.type==='UnionTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>f</span>alseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError5=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError5=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion5&amp;&amp;_iterator5.return){<span class="cstat-no" title="statement not covered" >_iterator5.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError5){<span class="cstat-no" title="statement not covered" >throw _iteratorError5;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===a.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else <span class="cstat-no" title="statement not covered" >if(trueCount===a.types.length){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span></span>function intersectionComparer(a,b,comparator){<span class="cstat-no" title="statement not covered" ></span>var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar trueCount=0;<span class="cstat-no" title="statement not covered" >i</span>f(!a.types){<span class="cstat-no" title="statement not covered" >return null;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion6=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError6=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError6=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator6=a.types[Symbol.iterator](),_step6;!(_iteratorNormalCompletion6=(_step6=_iterator6.next()).done);_iteratorNormalCompletion6=true){<span class="cstat-no" title="statement not covered" >var _type3=_step6.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=comparator(_type3,b);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >trueCount++;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >return false;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError6=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError6=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion6&amp;&amp;_iterator6.return){<span class="cstat-no" title="statement not covered" >_iterator6.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError6){<span class="cstat-no" title="statement not covered" >throw _iteratorError6;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(trueCount===a.types.length){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareObjectAnnotation(a,b){<span class="cstat-no" title="statement not covered" ></span>switch(b.type){case 'ObjectTypeAnnotation':<span class="cstat-no" title="statement not covered" >break;c</span>ase 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareObjectAnnotation(a,b.typeAnnotation);c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return unionComparer(a,b,compareObjectAnnotation);c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return intersectionComparer(a,b,compareObjectAnnotation);c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span> </span>// We're comparing two object annotations.
<span class="cstat-no" title="statement not covered" >var allTrue=true;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion7=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError7=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError7=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator7=a.properties[Symbol.iterator](),_step7;!(_iteratorNormalCompletion7=(_step7=_iterator7.next()).done);_iteratorNormalCompletion7=true){<span class="cstat-no" title="statement not covered" >var aprop=_step7.value;<span class="cstat-no" title="statement not covered" >v</span>ar found=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion8=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError8=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError8=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator8=b.properties[Symbol.iterator](),_step8;!(_iteratorNormalCompletion8=(_step8=_iterator8.next()).done);_iteratorNormalCompletion8=true){<span class="cstat-no" title="statement not covered" >var bprop=_step8.value;<span class="cstat-no" title="statement not covered" >i</span>f(bprop.key.name===aprop.key.name){<span class="cstat-no" title="statement not covered" >var result=compareAnnotations(aprop.value,bprop.value);<span class="cstat-no" title="statement not covered" >i</span>f(result===false&amp;&amp;!(aprop.optional&amp;&amp;(bprop.optional||maybeNullableAnnotation(bprop.value)===true))){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >found=result;}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError8=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError8=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion8&amp;&amp;_iterator8.return){<span class="cstat-no" title="statement not covered" >_iterator8.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError8){<span class="cstat-no" title="statement not covered" >throw _iteratorError8;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(found===false&amp;&amp;!aprop.optional){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>a</span>llTrue=allTrue&amp;&amp;found===true;}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError7=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError7=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion7&amp;&amp;_iterator7.return){<span class="cstat-no" title="statement not covered" >_iterator7.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError7){<span class="cstat-no" title="statement not covered" >throw _iteratorError7;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn allTrue?true:null;}<span class="fstat-no" title="function not covered" ></span>function compareArrayAnnotation(a,b){<span class="cstat-no" title="statement not covered" ></span>switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareArrayAnnotation(a,b.typeAnnotation);c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return unionComparer(a,b,compareArrayAnnotation);c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return intersectionComparer(a,b,compareArrayAnnotation);c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareGenericAnnotation(a,b){<span class="cstat-no" title="statement not covered" ></span>switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareGenericAnnotation(a,b.typeAnnotation);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(b.id.name===a.id.name){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return unionComparer(a,b,compareGenericAnnotation);c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return intersectionComparer(a,b,compareGenericAnnotation);d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareTupleAnnotation(a,b){<span class="cstat-no" title="statement not covered" ></span>if(b.type==='TupleTypeAnnotation'){<span class="cstat-no" title="statement not covered" >if(b.types.length===0){<span class="cstat-no" title="statement not covered" >return null;}</span>else <span class="cstat-no" title="statement not covered" >if(b.types.length&lt;a.types.length){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn a.types.every(<span class="fstat-no" title="function not covered" >function(type,index){<span class="cstat-no" title="statement not covered" ></span>return compareAnnotations(type,b.types[index]);}</span>);}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareTupleAnnotation(a,b.typeAnnotation);c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return unionComparer(a,b,compareTupleAnnotation);c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return intersectionComparer(a,b,compareTupleAnnotation);c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareUnionAnnotation(a,b){<span class="cstat-no" title="statement not covered" ></span>switch(b.type){case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareUnionAnnotation(a,b.typeAnnotation);c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return unionComparer(a,b,compareAnnotations);}</span>}<span class="fstat-no" title="function not covered" ></span>function compareNullableAnnotation(a,b){<span class="cstat-no" title="statement not covered" ></span>switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return compareNullableAnnotation(a,b.typeAnnotation);c</span>ase 'NullableTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(compareAnnotations(a.typeAnnotation,b)===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function arrayExpressionToTupleAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var elements=path.get('elements');<span class="cstat-no" title="statement not covered" >r</span>eturn t.tupleTypeAnnotation(elements.map(<span class="fstat-no" title="function not covered" >function(element){<span class="cstat-no" title="statement not covered" ></span>return getAnnotation(element);}</span>));}<span class="fstat-no" title="function not covered" ></span>function checkNullable(_ref9){<span class="cstat-no" title="statement not covered" ></span>var input=_ref9.input;<span class="cstat-no" title="statement not covered" >v</span>ar type=_ref9.type;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref9.scope;<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(input,type,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!check){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logicalExpression("||",checks.void({input:input}),check);}<span class="fstat-no" title="function not covered" ></span>function checkTypeof(_ref10){<span class="cstat-no" title="statement not covered" ></span>var input=_ref10.input;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref10.annotation;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref10.scope;<span class="cstat-no" title="statement not covered" >s</span>witch(annotation.type){case 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >var id=annotation.id;<span class="cstat-no" title="statement not covered" >v</span>ar path=Object.assign({},input,{type:id.type,node:id,scope:scope});<span class="cstat-no" title="statement not covered" >r</span>eturn checkAnnotation(input,getAnnotation(path),scope);d</span>efault:<span class="cstat-no" title="statement not covered" >return checkAnnotation(input,annotation,scope);}</span>}<span class="fstat-no" title="function not covered" ></span>function checkStringLiteral(_ref11){<span class="cstat-no" title="statement not covered" ></span>var input=_ref11.input;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref11.annotation;<span class="cstat-no" title="statement not covered" >r</span>eturn checkEquals({input:input,expected:t.stringLiteral(annotation.value)});}<span class="fstat-no" title="function not covered" ></span>function checkNumericLiteral(_ref12){<span class="cstat-no" title="statement not covered" ></span>var input=_ref12.input;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref12.annotation;<span class="cstat-no" title="statement not covered" >r</span>eturn checkEquals({input:input,expected:t.numericLiteral(annotation.value)});}<span class="fstat-no" title="function not covered" ></span>function checkBooleanLiteral(_ref13){<span class="cstat-no" title="statement not covered" ></span>var input=_ref13.input;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=_ref13.annotation;<span class="cstat-no" title="statement not covered" >r</span>eturn checkEquals({input:input,expected:t.booleanLiteral(annotation.value)});}<span class="fstat-no" title="function not covered" ></span>function checkUnion(_ref14){<span class="cstat-no" title="statement not covered" ></span>var input=_ref14.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref14.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref14.scope;<span class="cstat-no" title="statement not covered" >v</span>ar checks=types.map(<span class="fstat-no" title="function not covered" >function(type){<span class="cstat-no" title="statement not covered" ></span>return checkAnnotation(input,type,scope);}</span>).filter(identity);<span class="cstat-no" title="statement not covered" >r</span>eturn checks.reduce(<span class="fstat-no" title="function not covered" >function(last,check,index){<span class="cstat-no" title="statement not covered" ></span>if(last==null){<span class="cstat-no" title="statement not covered" >return check;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logicalExpression("||",last,check);}</span>,null);}<span class="fstat-no" title="function not covered" ></span>function checkIntersection(_ref15){<span class="cstat-no" title="statement not covered" ></span>var input=_ref15.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref15.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref15.scope;<span class="cstat-no" title="statement not covered" >v</span>ar checks=types.map(<span class="fstat-no" title="function not covered" >function(type){<span class="cstat-no" title="statement not covered" ></span>return checkAnnotation(input,type,scope);}</span>).filter(identity);<span class="cstat-no" title="statement not covered" >r</span>eturn checks.reduce(<span class="fstat-no" title="function not covered" >function(last,check,index){<span class="cstat-no" title="statement not covered" ></span>if(last==null){<span class="cstat-no" title="statement not covered" >return check;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logicalExpression("&amp;&amp;",last,check);}</span>,null);}<span class="fstat-no" title="function not covered" ></span>function checkMap(_ref16){<span class="cstat-no" title="statement not covered" ></span>var input=_ref16.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref16.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref16.scope;<span class="cstat-no" title="statement not covered" >v</span>ar _types=_slicedToArray(types,2);<span class="cstat-no" title="statement not covered" >v</span>ar keyType=_types[0];<span class="cstat-no" title="statement not covered" >v</span>ar valueType=_types[1];<span class="cstat-no" title="statement not covered" >v</span>ar key=t.identifier('key');<span class="cstat-no" title="statement not covered" >v</span>ar value=t.identifier('value');<span class="cstat-no" title="statement not covered" >v</span>ar keyCheck=keyType?checkAnnotation(key,keyType,scope):null;<span class="cstat-no" title="statement not covered" >v</span>ar valueCheck=valueType?checkAnnotation(value,valueType,scope):null;<span class="cstat-no" title="statement not covered" >i</span>f(!keyCheck){<span class="cstat-no" title="statement not covered" >if(!valueCheck){<span class="cstat-no" title="statement not covered" >return checkIsMap({input:input});}</span>else {<span class="cstat-no" title="statement not covered" >return checkMapValues({input:input,value:value,valueCheck:valueCheck});}</span>}</span>else {<span class="cstat-no" title="statement not covered" >if(!valueCheck){<span class="cstat-no" title="statement not covered" >return checkMapKeys({input:input,key:key,keyCheck:keyCheck});}</span>else {<span class="cstat-no" title="statement not covered" >return checkMapEntries({input:input,key:key,value:value,keyCheck:keyCheck,valueCheck:valueCheck});}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function checkSet(_ref17){<span class="cstat-no" title="statement not covered" ></span>var input=_ref17.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref17.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref17.scope;<span class="cstat-no" title="statement not covered" >v</span>ar _types2=_slicedToArray(types,1);<span class="cstat-no" title="statement not covered" >v</span>ar valueType=_types2[0];<span class="cstat-no" title="statement not covered" >v</span>ar value=t.identifier('value');<span class="cstat-no" title="statement not covered" >v</span>ar valueCheck=valueType?checkAnnotation(value,valueType,scope):null;<span class="cstat-no" title="statement not covered" >i</span>f(!valueCheck){<span class="cstat-no" title="statement not covered" >return checkIsSet({input:input});}</span>else {<span class="cstat-no" title="statement not covered" >return checkSetEntries({input:input,value:value,valueCheck:valueCheck});}</span>}<span class="fstat-no" title="function not covered" ></span>function checkGenerator(_ref18){<span class="cstat-no" title="statement not covered" ></span>var input=_ref18.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref18.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref18.scope;<span class="cstat-no" title="statement not covered" >r</span>eturn checkIsGenerator({input:input});}<span class="fstat-no" title="function not covered" ></span>function checkIterable(_ref19){<span class="cstat-no" title="statement not covered" ></span>var input=_ref19.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref19.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref19.scope;<span class="cstat-no" title="statement not covered" >r</span>eturn checkIsIterable({input:input});}<span class="fstat-no" title="function not covered" ></span>function checkClass(_ref20){<span class="cstat-no" title="statement not covered" ></span>var input=_ref20.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref20.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref20.scope;<span class="cstat-no" title="statement not covered" >r</span>eturn checkIsClass({input:input});}<span class="fstat-no" title="function not covered" ></span>function checkArray(_ref21){<span class="cstat-no" title="statement not covered" ></span>var input=_ref21.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref21.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref21.scope;<span class="cstat-no" title="statement not covered" >i</span>f(!types||types.length===0){<span class="cstat-no" title="statement not covered" >return checkIsArray({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(types.length===1){<span class="cstat-no" title="statement not covered" >var item=t.identifier('item');<span class="cstat-no" title="statement not covered" >v</span>ar _type4=types[0];<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(item,_type4,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!check){<span class="cstat-no" title="statement not covered" >return checkIsArray({input:input});}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logicalExpression('&amp;&amp;',checkIsArray({input:input}),t.callExpression(t.memberExpression(input,t.identifier('every')),[t.functionExpression(null,[item],t.blockStatement([t.returnStatement(check)]))]));}</span>else { // This is a tuple</span></span>
<span class="cstat-no" title="statement not covered" >var _checks=types.map(<span class="fstat-no" title="function not covered" >function(type,index){<span class="cstat-no" title="statement not covered" ></span>return checkAnnotation(t.memberExpression(input,t.numericLiteral(index),true),type,scope);}</span>).filter(identity);<span class="cstat-no" title="statement not covered" >v</span>ar checkLength=t.binaryExpression('&gt;=',t.memberExpression(input,t.identifier('length')),t.numericLiteral(types.length));<span class="cstat-no" title="statement not covered" >r</span>eturn _checks.reduce(<span class="fstat-no" title="function not covered" >function(last,check,index){<span class="cstat-no" title="statement not covered" ></span>return t.logicalExpression("&amp;&amp;",last,check);}</span>,t.logicalExpression('&amp;&amp;',checkIsArray({input:input}),checkLength));}</span>}<span class="fstat-no" title="function not covered" >function checkTuple(_ref22){<span class="cstat-no" title="statement not covered" ></span>var input=_ref22.input;<span class="cstat-no" title="statement not covered" >v</span>ar types=_ref22.types;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref22.scope;<span class="cstat-no" title="statement not covered" >i</span>f(types.length===0){<span class="cstat-no" title="statement not covered" >return checkIsArray({input:input});}</span> </span>// This is a tuple
<span class="cstat-no" title="statement not covered" >var checks=types.map(<span class="fstat-no" title="function not covered" >function(type,index){<span class="cstat-no" title="statement not covered" ></span>return checkAnnotation(t.memberExpression(input,t.numericLiteral(index),true),type,scope);}</span>).filter(identity);<span class="cstat-no" title="statement not covered" >v</span>ar checkLength=t.binaryExpression('&gt;=',t.memberExpression(input,t.identifier('length')),t.numericLiteral(types.length));<span class="cstat-no" title="statement not covered" >r</span>eturn checks.reduce(<span class="fstat-no" title="function not covered" >function(last,check,index){<span class="cstat-no" title="statement not covered" ></span>return t.logicalExpression("&amp;&amp;",last,check);}</span>,t.logicalExpression('&amp;&amp;',checkIsArray({input:input}),checkLength));}<span class="fstat-no" title="function not covered" ></span>function checkObject(_ref23){<span class="cstat-no" title="statement not covered" ></span>var input=_ref23.input;<span class="cstat-no" title="statement not covered" >v</span>ar properties=_ref23.properties;<span class="cstat-no" title="statement not covered" >v</span>ar indexers=_ref23.indexers;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref23.scope;<span class="cstat-no" title="statement not covered" >i</span>f(input.type==='ObjectPattern'){<span class="cstat-no" title="statement not covered" >return checkObjectPattern({input:input,properties:properties,scope:scope});}<span class="cstat-no" title="statement not covered" ></span>v</span>ar propNames=[];<span class="cstat-no" title="statement not covered" >v</span>ar check=properties.length===0?checkIsObject({input:input}):properties.reduce(<span class="fstat-no" title="function not covered" >function(expr,prop,index){<span class="cstat-no" title="statement not covered" ></span>var target=prop.key.type==='Identifier'?t.memberExpression(input,prop.key):t.memberExpression(input,prop.key,true);<span class="cstat-no" title="statement not covered" >p</span>ropNames.push(prop.key.type==='Identifier'?t.stringLiteral(prop.key.name):prop.key);<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(target,prop.value,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >if(prop.optional){<span class="cstat-no" title="statement not covered" >check=t.logicalExpression('||',checks.undefined({input:target}),check);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.logicalExpression("&amp;&amp;",expr,check);}</span>else {<span class="cstat-no" title="statement not covered" >return expr;}</span>}</span>,checkNotNull({input:input}));<span class="cstat-no" title="statement not covered" >i</span>f(indexers.length){<span class="cstat-no" title="statement not covered" >return indexers.reduceRight(<span class="fstat-no" title="function not covered" >function(expr,indexer){<span class="cstat-no" title="statement not covered" ></span>if(indexer.value.type==='AnyTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return expr;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar value=scope.generateUidIdentifier(indexer.id.name);<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(value,indexer.value,scope);<span class="cstat-no" title="statement not covered" >v</span>ar fixedKeys=t.arrayExpression(propNames);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >if(propNames.length){<span class="cstat-no" title="statement not covered" >return t.logicalExpression('&amp;&amp;',expr,checkObjectIndexers({input:input,value:value,check:check,fixedKeys:fixedKeys}));}</span>else {<span class="cstat-no" title="statement not covered" >return t.logicalExpression('&amp;&amp;',expr,checkObjectIndexersNoFixed({input:input,value:value,check:check,fixedKeys:fixedKeys}));}</span>}</span>else {<span class="cstat-no" title="statement not covered" >return expr;}</span>}</span>,check);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn check;}<span class="fstat-no" title="function not covered" ></span>function checkObjectPattern(_ref24){<span class="cstat-no" title="statement not covered" ></span>var input=_ref24.input;<span class="cstat-no" title="statement not covered" >v</span>ar properties=_ref24.properties;<span class="cstat-no" title="statement not covered" >v</span>ar scope=_ref24.scope;<span class="cstat-no" title="statement not covered" >v</span>ar propNames=properties.reduce(<span class="fstat-no" title="function not covered" >function(names,prop){<span class="cstat-no" title="statement not covered" ></span>names[prop.key.name]=prop;<span class="cstat-no" title="statement not covered" >r</span>eturn names;}</span>,{});<span class="cstat-no" title="statement not covered" >v</span>ar propChecks={};<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion9=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError9=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError9=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator9=input.properties[Symbol.iterator](),_step9;!(_iteratorNormalCompletion9=(_step9=_iterator9.next()).done);_iteratorNormalCompletion9=true){<span class="cstat-no" title="statement not covered" >var item=_step9.value;<span class="cstat-no" title="statement not covered" >v</span>ar key=item.key;<span class="cstat-no" title="statement not covered" >v</span>ar _id5=item.value;<span class="cstat-no" title="statement not covered" >v</span>ar prop=propNames[key.name];<span class="cstat-no" title="statement not covered" >i</span>f(!prop){<span class="cstat-no" title="statement not covered" >continue;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar check=checkAnnotation(_id5,prop.value,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >propChecks[key.name]=check;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError9=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError9=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion9&amp;&amp;_iterator9.return){<span class="cstat-no" title="statement not covered" >_iterator9.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError9){<span class="cstat-no" title="statement not covered" >throw _iteratorError9;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Object.keys(propChecks).reduce(<span class="fstat-no" title="function not covered" >function(last,name){<span class="cstat-no" title="statement not covered" ></span>var check=propChecks[name];<span class="cstat-no" title="statement not covered" >i</span>f(last===null){<span class="cstat-no" title="statement not covered" >return check;}</span>else {<span class="cstat-no" title="statement not covered" >return t.logicalExpression('&amp;&amp;',last,check);}</span>}</span>,null);}<span class="fstat-no" title="function not covered" ></span>function createTypeAliasChecks(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.id;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.right;<span class="cstat-no" title="statement not covered" >v</span>ar input=t.identifier('input');<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(input,annotation,scope)||t.booleanLiteral(true);<span class="cstat-no" title="statement not covered" >v</span>ar declaration=declareTypeChecker({id:id,check:check});<span class="cstat-no" title="statement not covered" >d</span>eclaration.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >d</span>eclaration.savedTypeAnnotation=annotation;<span class="cstat-no" title="statement not covered" >d</span>eclaration.declarations[0].savedTypeAnnotation=annotation;<span class="cstat-no" title="statement not covered" >r</span>eturn declaration;}<span class="fstat-no" title="function not covered" ></span>function createInterfaceChecks(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.id;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.body;<span class="cstat-no" title="statement not covered" >v</span>ar input=t.identifier('input');<span class="cstat-no" title="statement not covered" >v</span>ar check=node.extends.reduce(<span class="fstat-no" title="function not covered" >function(check,extender){<span class="cstat-no" title="statement not covered" ></span>return t.logicalExpression('&amp;&amp;',check,checkAnnotation(input,t.genericTypeAnnotation(extender.id),path.scope));<span class="cstat-no" title="statement not covered" >r</span>eturn check;}</span>,checkAnnotation(input,annotation,scope)||t.booleanLiteral(true));<span class="cstat-no" title="statement not covered" >v</span>ar declaration=declareTypeChecker({id:id,check:check});<span class="cstat-no" title="statement not covered" >d</span>eclaration.isTypeChecker=true;<span class="cstat-no" title="statement not covered" >r</span>eturn declaration;}<span class="fstat-no" title="function not covered" ></span>function checkAnnotation(input,annotation,scope){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return checkAnnotation(input,annotation.typeAnnotation,scope);c</span>ase 'TypeofTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.typeof({input:input,annotation:annotation.argument,scope:scope});c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Array'){<span class="cstat-no" title="statement not covered" >return checks.array({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Generator'&amp;&amp;!scope.hasBinding('Generator')){<span class="cstat-no" title="statement not covered" >return checks.generator({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Iterable'&amp;&amp;!scope.hasBinding('Iterable')){<span class="cstat-no" title="statement not covered" >return checks.iterable({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Map'&amp;&amp;!scope.getBinding('Map')){<span class="cstat-no" title="statement not covered" >return checks.map({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Set'&amp;&amp;!scope.getBinding('Set')){<span class="cstat-no" title="statement not covered" >return checks.set({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Function'){<span class="cstat-no" title="statement not covered" >return checks.function({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Class'&amp;&amp;!scope.hasBinding('Class')){<span class="cstat-no" title="statement not covered" >return checks.class({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='int8'&amp;&amp;!scope.hasBinding('int8')){<span class="cstat-no" title="statement not covered" >return checks.int8({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='uint8'&amp;&amp;!scope.hasBinding('uint8')){<span class="cstat-no" title="statement not covered" >return checks.uint8({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='int16'&amp;&amp;!scope.hasBinding('int16')){<span class="cstat-no" title="statement not covered" >return checks.int16({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='uint16'&amp;&amp;!scope.hasBinding('uint16')){<span class="cstat-no" title="statement not covered" >return checks.uint16({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='int32'&amp;&amp;!scope.hasBinding('int32')){<span class="cstat-no" title="statement not covered" >return checks.int32({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='uint32'&amp;&amp;!scope.hasBinding('uint32')){<span class="cstat-no" title="statement not covered" >return checks.uint32({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='float32'&amp;&amp;!scope.hasBinding('float32')){<span class="cstat-no" title="statement not covered" >return checks.float32({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='float64'&amp;&amp;!scope.hasBinding('float64')){<span class="cstat-no" title="statement not covered" >return checks.float64({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='double'&amp;&amp;!scope.hasBinding('double')){<span class="cstat-no" title="statement not covered" >return checks.double({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Symbol'&amp;&amp;!scope.getBinding('Symbol')){<span class="cstat-no" title="statement not covered" >return checks.symbol({input:input});}</span>else <span class="cstat-no" title="statement not covered" >if(isTypeChecker(annotation.id,scope)){<span class="cstat-no" title="statement not covered" >return checks.type({input:input,type:annotation.id});}</span>else <span class="cstat-no" title="statement not covered" >if(isPolymorphicType(annotation.id,scope)){<span class="cstat-no" title="statement not covered" >return;}</span>else {<span class="cstat-no" title="statement not covered" >return checks.instanceof({input:input,type:createTypeExpression(annotation.id)});}</span>c</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>ase 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.tuple({input:input,types:annotation.types,scope:scope});c</span>ase 'NumberTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.number({input:input});c</span>ase 'NumericLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.numericLiteral({input:input,annotation:annotation});c</span>ase 'BooleanTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.boolean({input:input});c</span>ase 'BooleanLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.booleanLiteral({input:input,annotation:annotation});c</span>ase 'StringTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.string({input:input});c</span>ase 'StringLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.stringLiteral({input:input,annotation:annotation});c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.union({input:input,types:annotation.types,scope:scope});c</span>ase 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.intersection({input:input,types:annotation.types,scope:scope});c</span>ase 'ObjectTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.object({input:input,properties:annotation.properties||[],indexers:annotation.indexers,scope:scope});c</span>ase 'ArrayTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.array({input:input,types:[annotation.elementType||t.anyTypeAnnotation()],scope:scope});c</span>ase 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.function({input:input,params:annotation.params,returnType:annotation.returnType});c</span>ase 'MixedTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.mixed({input:input});c</span>ase 'AnyTypeAnnotation':case 'ExistentialTypeParam':<span class="cstat-no" title="statement not covered" >return checks.any({input:input});c</span>ase 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.nullable({input:input,type:annotation.typeAnnotation,scope:scope});c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return checks.void({input:input});}</span>}<span class="fstat-no" title="function not covered" ></span>function staticCheckAnnotation(path,annotation){<span class="cstat-no" title="statement not covered" ></span>var other=getAnnotation(path);<span class="cstat-no" title="statement not covered" >s</span>witch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return staticCheckAnnotation(path,annotation.typeAnnotation);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(isTypeChecker(annotation.id,path.scope)){<span class="cstat-no" title="statement not covered" >return staticChecks.type({path:path,type:annotation.id});}</span>else <span class="cstat-no" title="statement not covered" >if(isPolymorphicType(annotation.id,path.scope)){<span class="cstat-no" title="statement not covered" >return;}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.id.name==='Symbol'){<span class="cstat-no" title="statement not covered" >return staticChecks.symbol(path);}</span>else {<span class="cstat-no" title="statement not covered" >return staticChecks.instanceof({path:path,annotation:annotation});}</span>}<span class="cstat-no" title="statement not covered" ></span></span></span>r</span>eturn compareAnnotations(annotation,other);}</span> /**
   * Get the type annotation for a given node.
   */<span class="fstat-no" title="function not covered" >function getAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var annotation=void 0;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >annotation=getAnnotationShallow(path);}</span>catch(e){<span class="cstat-no" title="statement not covered" >if(e instanceof SyntaxError){<span class="cstat-no" title="statement not covered" >throw e;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(process.env.TYPECHECK_DEBUG){<span class="cstat-no" title="statement not covered" >console.error(e.stack);}</span>}<span class="cstat-no" title="statement not covered" ></span>w</span>hile(annotation&amp;&amp;annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn annotation||t.anyTypeAnnotation();}<span class="fstat-no" title="function not covered" ></span>function getAnnotationShallow(path){<span class="cstat-no" title="statement not covered" ></span>if(!path||!path.node){<span class="cstat-no" title="statement not covered" >return t.voidTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>v</span>ar node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='TypeAlias'){<span class="cstat-no" title="statement not covered" >return node.right;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ClassProperty'&amp;&amp;node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return getClassPropertyAnnotation(path);}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ClassMethod'&amp;&amp;node.returnType){<span class="cstat-no" title="statement not covered" >return getClassMethodAnnotation(path);}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ObjectProperty'&amp;&amp;node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return getObjectPropertyAnnotation(path);}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='SpreadProperty'&amp;&amp;node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return getSpreadPropertyAnnotation(path);}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='ObjectMethod'&amp;&amp;node.returnType){<span class="cstat-no" title="statement not covered" >return getObjectMethodAnnotation(path);}</span>else <span class="cstat-no" title="statement not covered" >if(!node.typeAnnotation&amp;&amp;!node.savedTypeAnnotation&amp;&amp;!node.returnType){<span class="cstat-no" title="statement not covered" >switch(path.type){case 'Identifier':<span class="cstat-no" title="statement not covered" >var binding=scope.getBinding(node.name);<span class="cstat-no" title="statement not covered" >i</span>f(!binding||!binding.identifier){<span class="cstat-no" title="statement not covered" >return path.getTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>v</span>ar id=binding.identifier;<span class="cstat-no" title="statement not covered" >i</span>f(binding.path.type==='ObjectPattern'){<span class="cstat-no" title="statement not covered" >return getObjectPatternAnnotation(binding.path,node.name);}<span class="cstat-no" title="statement not covered" ></span>i</span>f(id.savedTypeAnnotation){<span class="cstat-no" title="statement not covered" >return id.savedTypeAnnotation;}</span>else <span class="cstat-no" title="statement not covered" >if(id.returnType){<span class="cstat-no" title="statement not covered" >return id.returnType;}</span>else <span class="cstat-no" title="statement not covered" >if(id.typeAnnotation){<span class="cstat-no" title="statement not covered" >return id.typeAnnotation;}</span>else <span class="cstat-no" title="statement not covered" >if(isPolymorphicType(id,scope)){<span class="cstat-no" title="statement not covered" >return t.anyTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span>eturn binding.constant?binding.path.getTypeAnnotation():path.getTypeAnnotation();c</span>ase 'StringLiteral':case 'NumericLiteral':case 'BooleanLiteral':<span class="cstat-no" title="statement not covered" >return createLiteralTypeAnnotation(path);c</span>ase 'CallExpression':<span class="cstat-no" title="statement not covered" >var callee=path.get('callee');<span class="cstat-no" title="statement not covered" >i</span>f(callee.type==='Identifier'){<span class="cstat-no" title="statement not covered" >if(callee.name==='Symbol'){<span class="cstat-no" title="statement not covered" >return t.genericTypeAnnotation('Symbol');}<span class="cstat-no" title="statement not covered" ></span>v</span>ar fn=getFunctionForIdentifier(callee);<span class="cstat-no" title="statement not covered" >i</span>f(fn){<span class="cstat-no" title="statement not covered" >return getAnnotation(fn);}</span>}<span class="cstat-no" title="statement not covered" ></span>b</span>reak;c</span>ase 'ThisExpression':<span class="cstat-no" title="statement not covered" >return getThisExpressionAnnotation(path);c</span>ase 'AssignmentExpression':<span class="cstat-no" title="statement not covered" >return getAssignmentExpressionAnnotation(path);c</span>ase 'MemberExpression':<span class="cstat-no" title="statement not covered" >return getMemberExpressionAnnotation(path);c</span>ase 'ArrayExpression':<span class="cstat-no" title="statement not covered" >return getArrayExpressionAnnotation(path);c</span>ase 'ObjectExpression':<span class="cstat-no" title="statement not covered" >return getObjectExpressionAnnotation(path);c</span>ase 'BinaryExpression':<span class="cstat-no" title="statement not covered" >return getBinaryExpressionAnnotation(path);c</span>ase 'LogicalExpression':<span class="cstat-no" title="statement not covered" >return getLogicalExpressionAnnotation(path);c</span>ase 'ConditionalExpression':<span class="cstat-no" title="statement not covered" >return getConditionalExpressionAnnotation(path);c</span>ase 'ObjectMethod':<span class="cstat-no" title="statement not covered" >return getObjectMethodAnnotation(path);c</span>ase 'SpreadProperty':<span class="cstat-no" title="statement not covered" >return getSpreadPropertyAnnotation(path);c</span>ase 'ObjectProperty':<span class="cstat-no" title="statement not covered" >return getObjectPropertyAnnotation(path);c</span>ase 'ClassDeclaration':<span class="cstat-no" title="statement not covered" >return getClassDeclarationAnnotation(path);c</span>ase 'ClassMethod':<span class="cstat-no" title="statement not covered" >return getClassMethodAnnotation(path);c</span>ase 'ClassProperty':<span class="cstat-no" title="statement not covered" >return getClassPropertyAnnotation(path);d</span>efault:<span class="cstat-no" title="statement not covered" >return path.getTypeAnnotation();}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span></span></span></span>eturn node.savedTypeAnnotation||node.returnType||node.typeAnnotation||path.getTypeAnnotation();}<span class="fstat-no" title="function not covered" ></span>function createLiteralTypeAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var annotation=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(path.isStringLiteral()){<span class="cstat-no" title="statement not covered" >annotation=t.stringLiteralTypeAnnotation();}</span>else <span class="cstat-no" title="statement not covered" >if(path.isNumericLiteral()){<span class="cstat-no" title="statement not covered" >annotation=t.numericLiteralTypeAnnotation();}</span>else <span class="cstat-no" title="statement not covered" >if(path.isBooleanLiteral()){<span class="cstat-no" title="statement not covered" >annotation=t.booleanLiteralTypeAnnotation();}</span>else {<span class="cstat-no" title="statement not covered" >return path.getTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>a</span></span></span>nnotation.value=path.node.value;<span class="cstat-no" title="statement not covered" >r</span>eturn annotation;}<span class="fstat-no" title="function not covered" ></span>function getObjectPatternAnnotation(path,name){<span class="cstat-no" title="statement not covered" ></span>var annotation=keyByName(getAnnotation(path),name);<span class="cstat-no" title="statement not covered" >v</span>ar found=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(!path.node.properties){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion10=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError10=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError10=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator10=path.get('properties')[Symbol.iterator](),_step10;!(_iteratorNormalCompletion10=(_step10=_iterator10.next()).done);_iteratorNormalCompletion10=true){<span class="cstat-no" title="statement not covered" >var prop=_step10.value;<span class="cstat-no" title="statement not covered" >i</span>f(prop.node.value&amp;&amp;prop.node.value.name===name){<span class="cstat-no" title="statement not covered" >found=prop.get('key');<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>else <span class="cstat-no" title="statement not covered" >if(prop.node.key.type==='Identifier'&amp;&amp;prop.node.key.name===name){<span class="cstat-no" title="statement not covered" >found=prop.get('key');<span class="cstat-no" title="statement not covered" >b</span>reak;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError10=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError10=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion10&amp;&amp;_iterator10.return){<span class="cstat-no" title="statement not covered" >_iterator10.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError10){<span class="cstat-no" title="statement not covered" >throw _iteratorError10;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!annotation||!found){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(found.type==='Identifier'){<span class="cstat-no" title="statement not covered" >annotation.value.authoritative=false;<span class="cstat-no" title="statement not covered" >r</span>eturn annotation.value;}</span>}<span class="fstat-no" title="function not covered" ></span>function keyByName(node,name){<span class="cstat-no" title="statement not covered" ></span>if(!node.properties){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion11=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError11=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError11=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator11=node.properties[Symbol.iterator](),_step11;!(_iteratorNormalCompletion11=(_step11=_iterator11.next()).done);_iteratorNormalCompletion11=true){<span class="cstat-no" title="statement not covered" >var prop=_step11.value;<span class="cstat-no" title="statement not covered" >i</span>f(prop.key&amp;&amp;prop.key.name===name){<span class="cstat-no" title="statement not covered" >return prop;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError11=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError11=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion11&amp;&amp;_iterator11.return){<span class="cstat-no" title="statement not covered" >_iterator11.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError11){<span class="cstat-no" title="statement not covered" >throw _iteratorError11;}</span>}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function valueByName(node,name){<span class="cstat-no" title="statement not covered" ></span>if(!node.properties){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _iteratorNormalCompletion12=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError12=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError12=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator12=node.properties[Symbol.iterator](),_step12;!(_iteratorNormalCompletion12=(_step12=_iterator12.next()).done);_iteratorNormalCompletion12=true){<span class="cstat-no" title="statement not covered" >var prop=_step12.value;<span class="cstat-no" title="statement not covered" >i</span>f(prop.value&amp;&amp;prop.value.name===name){<span class="cstat-no" title="statement not covered" >return prop;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError12=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError12=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion12&amp;&amp;_iterator12.return){<span class="cstat-no" title="statement not covered" >_iterator12.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError12){<span class="cstat-no" title="statement not covered" >throw _iteratorError12;}</span>}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>function getSpreadPropertyAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.typeAnnotation||node.savedTypeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(!annotation){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(path.get('argument'));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn annotation;}<span class="fstat-no" title="function not covered" ></span>function getObjectPropertyAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar annotation=node.typeAnnotation||node.savedTypeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(!annotation){<span class="cstat-no" title="statement not covered" >if(node.value){<span class="cstat-no" title="statement not covered" >if(node.value.typeAnnotation||node.value.savedTypeAnnotation){<span class="cstat-no" title="statement not covered" >annotation=node.value.typeAnnotation||node.value.savedTypeAnnotation;}</span>else <span class="cstat-no" title="statement not covered" >if(node.value.type==='BooleanLiteral'||node.value.type==='NumericLiteral'||node.value.type==='StringLiteral'){<span class="cstat-no" title="statement not covered" >annotation=t[node.value.type](node.value.value);}</span>else {<span class="cstat-no" title="statement not covered" >annotation=t.anyTypeAnnotation();}</span>}</span></span>else {<span class="cstat-no" title="statement not covered" >annotation=t.anyTypeAnnotation();}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.objectTypeProperty(node.key,annotation);}<span class="fstat-no" title="function not covered" ></span>function getObjectMethodAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >r</span>eturn t.objectTypeProperty(t.identifier(node.key.name),t.functionTypeAnnotation(null,node.params.map(<span class="fstat-no" title="function not covered" >function(param){<span class="cstat-no" title="statement not covered" ></span>return param.savedTypeAnnotation||param.typeAnnotation;}</span>),null,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation()));}<span class="fstat-no" title="function not covered" ></span>function getThisExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var parent=path.parentPath;<span class="cstat-no" title="statement not covered" >l</span>oop: <span class="cstat-no" title="statement not covered" >while(parent){<span class="cstat-no" title="statement not covered" >switch(parent.type){case 'ClassDeclaration':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent);c</span>ase 'ClassBody':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath);c</span>ase 'ClassMethod':case 'ClassProperty':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath.parentPath);c</span>ase 'ObjectProperty':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath);c</span>ase 'ObjectMethod':<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath);c</span>ase 'FunctionExpression':<span class="cstat-no" title="statement not covered" >if(parent.parentPath.type==='ObjectProperty'){<span class="cstat-no" title="statement not covered" >return getAnnotation(parent.parentPath.parentPath);}<span class="cstat-no" title="statement not covered" ></span>b</span>reak loop;c</span>ase 'ArrowFunctionExpression':<span class="cstat-no" title="statement not covered" >parent=parent.parentPath;<span class="cstat-no" title="statement not covered" >c</span>ontinue;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(parent.isFunction()){<span class="cstat-no" title="statement not covered" >break;}<span class="cstat-no" title="statement not covered" ></span>p</span>arent=parent.parentPath;}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn t.objectTypeAnnotation([]);}<span class="fstat-no" title="function not covered" ></span>function getClassDeclarationAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var body=path.get('body').get('body').map(getAnnotation).filter(<span class="fstat-no" title="function not covered" >function(annotation){<span class="cstat-no" title="statement not covered" ></span>return annotation&amp;&amp;annotation.type!=='AnyTypeAnnotation';}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn t.objectTypeAnnotation(body);}<span class="fstat-no" title="function not covered" ></span>function getAssignmentExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>if(path.node.operator==='='){<span class="cstat-no" title="statement not covered" >return getAnnotation(path.get('right'));}</span>}<span class="fstat-no" title="function not covered" ></span>function getClassPropertyAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.computed){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar annotation=node.typeAnnotation||(node.value?node.value.savedTypeAnnotation||node.value.typeAnnotation:t.anyTypeAnnotation());<span class="cstat-no" title="statement not covered" >r</span>eturn t.objectTypeProperty(node.key,annotation||t.anyTypeAnnotation());}<span class="fstat-no" title="function not covered" ></span>function getClassMethodAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.computed){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.kind==='get'){<span class="cstat-no" title="statement not covered" >return t.objectTypeProperty(node.key,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation());}</span>else <span class="cstat-no" title="statement not covered" >if(node.kind==='set'){<span class="cstat-no" title="statement not covered" >return t.objectTypeProperty(node.key,node.params.map(<span class="fstat-no" title="function not covered" >function(param){<span class="cstat-no" title="statement not covered" ></span>return param.savedTypeAnnotation||param.typeAnnotation;}</span>).shift()||t.anyTypeAnnotation());}</span>else {<span class="cstat-no" title="statement not covered" >return t.objectTypeProperty(node.key,t.functionTypeAnnotation(null,node.params.map(<span class="fstat-no" title="function not covered" >function(param){<span class="cstat-no" title="statement not covered" ></span>return param.savedTypeAnnotation||param.typeAnnotation||t.anyTypeAnnotation();}</span>),null,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation()));}</span>}<span class="fstat-no" title="function not covered" ></span></span>function getBinaryExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(isBooleanExpression(node)){<span class="cstat-no" title="statement not covered" >return t.booleanTypeAnnotation();}</span>else {<span class="cstat-no" title="statement not covered" >return t.anyTypeAnnotation();}</span>}<span class="fstat-no" title="function not covered" ></span>function getLogicalExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(isBooleanExpression(node)){<span class="cstat-no" title="statement not covered" >return t.booleanTypeAnnotation();}</span>else {<span class="cstat-no" title="statement not covered" >var left=path.get('left');<span class="cstat-no" title="statement not covered" >v</span>ar right=path.get('right');<span class="cstat-no" title="statement not covered" >s</span>witch(node.operator){case '&amp;&amp;':case '||':<span class="cstat-no" title="statement not covered" >var _ref25=[getAnnotation(left),getAnnotation(right)];<span class="cstat-no" title="statement not covered" >l</span>eft=_ref25[0];<span class="cstat-no" title="statement not covered" >r</span>ight=_ref25[1];<span class="cstat-no" title="statement not covered" >i</span>f(t.isUnionTypeAnnotation(left)){<span class="cstat-no" title="statement not covered" >if(t.isUnionTypeAnnotation(right)){<span class="cstat-no" title="statement not covered" >return t.unionTypeAnnotation(left.types.concat(right.types));}</span>else {<span class="cstat-no" title="statement not covered" >return t.unionTypeAnnotation(left.types.concat(right));}</span>}</span>else {<span class="cstat-no" title="statement not covered" >return t.unionTypeAnnotation([left,right]);}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.anyTypeAnnotation();}</span>}<span class="fstat-no" title="function not covered" ></span>function getConditionalExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar consequent=getAnnotation(path.get('consequent'));<span class="cstat-no" title="statement not covered" >v</span>ar alternate=getAnnotation(path.get('alternate'));<span class="cstat-no" title="statement not covered" >i</span>f(t.isUnionTypeAnnotation(consequent)){<span class="cstat-no" title="statement not covered" >if(t.isUnionTypeAnnotation(alternate)){<span class="cstat-no" title="statement not covered" >return t.unionTypeAnnotation(consequent.types.concat(alternate.types));}</span>else {<span class="cstat-no" title="statement not covered" >return t.unionTypeAnnotation(consequent.types.concat(alternate));}</span>}</span>else {<span class="cstat-no" title="statement not covered" >return t.unionTypeAnnotation([consequent,alternate]);}</span>}<span class="fstat-no" title="function not covered" ></span>function getArrayExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>return t.genericTypeAnnotation(t.identifier('Array'),t.typeParameterDeclaration(path.get('elements').map(getAnnotation)));}<span class="fstat-no" title="function not covered" ></span>function getObjectExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var annotation=t.objectTypeAnnotation(path.get('properties').filter(<span class="fstat-no" title="function not covered" >function(prop){<span class="cstat-no" title="statement not covered" ></span>return !prop.node.computed;}</span>).map(getAnnotation).reduce(<span class="fstat-no" title="function not covered" >function(properties,prop){<span class="cstat-no" title="statement not covered" ></span>if(t.isObjectTypeProperty(prop)){<span class="cstat-no" title="statement not covered" >properties.push(prop);}</span>else <span class="cstat-no" title="statement not covered" >if(t.isObjectTypeAnnotation(prop)){<span class="cstat-no" title="statement not covered" >properties.push.apply(properties,_toConsumableArray(prop.properties));}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn properties;}</span>,[]).filter(<span class="fstat-no" title="function not covered" >function(annotation){<span class="cstat-no" title="statement not covered" ></span>return !t.isAnyTypeAnnotation(annotation.value);}</span>));<span class="cstat-no" title="statement not covered" >r</span>eturn annotation;}<span class="fstat-no" title="function not covered" ></span>function getMemberExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>if(path.node.computed){<span class="cstat-no" title="statement not covered" >return getComputedMemberExpressionAnnotation(path);}<span class="cstat-no" title="statement not covered" ></span>v</span>ar stack=[];<span class="cstat-no" title="statement not covered" >v</span>ar target=path;<span class="cstat-no" title="statement not covered" >w</span>hile(target.isMemberExpression()){<span class="cstat-no" title="statement not covered" >stack.push(target);<span class="cstat-no" title="statement not covered" >i</span>f(target.node.computed){<span class="cstat-no" title="statement not covered" >break;}<span class="cstat-no" title="statement not covered" ></span>t</span>arget=target.get('object');}<span class="cstat-no" title="statement not covered" ></span>v</span>ar objectAnnotation=stack.reduceRight(<span class="fstat-no" title="function not covered" >function(last,target){<span class="cstat-no" title="statement not covered" ></span>var annotation=last;<span class="cstat-no" title="statement not covered" >i</span>f(annotation==null){<span class="cstat-no" title="statement not covered" >if(stack.length===1){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(target.get('object'));}</span>else {<span class="cstat-no" title="statement not covered" >return getAnnotation(target);}</span>}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(annotation.type){case 'AnyTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation;c</span>ase 'NullableTypeAnnotation':case 'TypeAnnotation':<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(annotation.type==='GenericTypeAnnotation'){<span class="cstat-no" title="statement not covered" >var typeChecker=getTypeChecker(annotation.id,path.scope);<span class="cstat-no" title="statement not covered" >i</span>f(typeChecker){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(typeChecker);}</span>else {<span class="cstat-no" title="statement not covered" >var binding=path.scope.getBinding(annotation.id.name);<span class="cstat-no" title="statement not covered" >i</span>f(binding){<span class="cstat-no" title="statement not covered" >annotation=getAnnotation(binding.path);}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(annotation.type){case 'AnyTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation;c</span>ase 'ObjectTypeAnnotation':<span class="cstat-no" title="statement not covered" >var id=target.get('property').node;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion13=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError13=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError13=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator13=(annotation.properties||[])[Symbol.iterator](),_step13;!(_iteratorNormalCompletion13=(_step13=_iterator13.next()).done);_iteratorNormalCompletion13=true){<span class="cstat-no" title="statement not covered" >var _step13$value=_step13.value;<span class="cstat-no" title="statement not covered" >v</span>ar key=_step13$value.key;<span class="cstat-no" title="statement not covered" >v</span>ar value=_step13$value.value;<span class="cstat-no" title="statement not covered" >i</span>f(key.name===id.name){<span class="cstat-no" title="statement not covered" >return value.type==='VoidTypeAnnotation'||value.type==='NullLiteralTypeAnnotation'?t.anyTypeAnnotation():value;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError13=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError13=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion13&amp;&amp;_iterator13.return){<span class="cstat-no" title="statement not covered" >_iterator13.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError13){<span class="cstat-no" title="statement not covered" >throw _iteratorError13;}</span>}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.anyTypeAnnotation();}</span>,null);<span class="cstat-no" title="statement not covered" >r</span>eturn objectAnnotation||path.getTypeAnnotation();}<span class="fstat-no" title="function not covered" ></span>function getComputedMemberExpressionAnnotation(path){<span class="cstat-no" title="statement not covered" ></span>var object=path.get('object');<span class="cstat-no" title="statement not covered" >v</span>ar property=path.get('property');<span class="cstat-no" title="statement not covered" >v</span>ar objectAnnotation=getAnnotation(object);<span class="cstat-no" title="statement not covered" >i</span>f(objectAnnotation.type==='TypeAnnotation'||objectAnnotation.type==='NullableTypeAnnotation'){<span class="cstat-no" title="statement not covered" >objectAnnotation=objectAnnotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar propertyAnnotation=getAnnotation(property);<span class="cstat-no" title="statement not covered" >i</span>f(propertyAnnotation.type==='TypeAnnotation'||propertyAnnotation.type==='NullableTypeAnnotation'){<span class="cstat-no" title="statement not covered" >propertyAnnotation=propertyAnnotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar _property$evaluate=property.evaluate();<span class="cstat-no" title="statement not covered" >v</span>ar confident=_property$evaluate.confident;<span class="cstat-no" title="statement not covered" >v</span>ar value=_property$evaluate.value;<span class="cstat-no" title="statement not covered" >i</span>f(!confident){<span class="cstat-no" title="statement not covered" >return path.getTypeAnnotation();}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(objectAnnotation.type){case 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(objectAnnotation.types.length===0){<span class="cstat-no" title="statement not covered" >break;}</span>else <span class="cstat-no" title="statement not covered" >if(typeof value==='number'){<span class="cstat-no" title="statement not covered" >if(!objectAnnotation.types[value]){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError('Invalid computed member expression for tuple: '+humanReadableType(objectAnnotation));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn objectAnnotation.types[value];}</span>else {<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError('Invalid computed member expression for tuple: '+humanReadableType(objectAnnotation));}<span class="cstat-no" title="statement not covered" ></span>b</span></span>reak;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn path.getTypeAnnotation();}<span class="fstat-no" title="function not covered" ></span>function getFunctionForIdentifier(path){<span class="cstat-no" title="statement not covered" ></span>if(path.type!=='Identifier'){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar ref=path.scope.getBinding(path.node.name);<span class="cstat-no" title="statement not covered" >i</span>f(!ref){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.isFunction(ref.path.parent)&amp;&amp;ref.path.parentPath;}</span> /**
   * Determine whether the given annotation is for an array.
   */<span class="fstat-no" title="function not covered" >function isStrictlyArrayAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'ArrayTypeAnnotation':case 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return isStrictlyArrayAnnotation(annotation.typeAnnotation);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation.id.name==='Array'?true:null;c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation.types.every(isStrictlyArrayAnnotation);d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}<span class="fstat-no" title="function not covered" ></span>function compareMaybeUnion(annotation,comparator){<span class="cstat-no" title="statement not covered" ></span>var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion14=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError14=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError14=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator14=annotation.types[Symbol.iterator](),_step14;!(_iteratorNormalCompletion14=(_step14=_iterator14.next()).done);_iteratorNormalCompletion14=true){<span class="cstat-no" title="statement not covered" >var _type5=_step14.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=comparator(_type5);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError14=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError14=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion14&amp;&amp;_iterator14.return){<span class="cstat-no" title="statement not covered" >_iterator14.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError14){<span class="cstat-no" title="statement not covered" >throw _iteratorError14;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a number,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeNumberAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeNumberAnnotation(annotation.typeAnnotation);c</span>ase 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'NumericLiteral':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return compareMaybeUnion(annotation,maybeNumberAnnotation);c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a string,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeStringAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeStringAnnotation(annotation.typeAnnotation);c</span>ase 'StringTypeAnnotation':case 'StringLiteral':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'StringLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'Number':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion15=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError15=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError15=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator15=annotation.types[Symbol.iterator](),_step15;!(_iteratorNormalCompletion15=(_step15=_iterator15.next()).done);_iteratorNormalCompletion15=true){<span class="cstat-no" title="statement not covered" >var _type6=_step15.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeStringAnnotation(_type6);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError15=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError15=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion15&amp;&amp;_iterator15.return){<span class="cstat-no" title="statement not covered" >_iterator15.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError15){<span class="cstat-no" title="statement not covered" >throw _iteratorError15;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a symbol,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeSymbolAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeSymbolAnnotation(annotation.typeAnnotation);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'Number':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;c</span>ase 'Symbol':<span class="cstat-no" title="statement not covered" >return true;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion16=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError16=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError16=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator16=annotation.types[Symbol.iterator](),_step16;!(_iteratorNormalCompletion16=(_step16=_iterator16.next()).done);_iteratorNormalCompletion16=true){<span class="cstat-no" title="statement not covered" >var _type7=_step16.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeSymbolAnnotation(_type7);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError16=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError16=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion16&amp;&amp;_iterator16.return){<span class="cstat-no" title="statement not covered" >_iterator16.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError16){<span class="cstat-no" title="statement not covered" >throw _iteratorError16;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a boolean,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeBooleanAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeBooleanAnnotation(annotation.typeAnnotation);c</span>ase 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'BooleanLiteral':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'String':case 'Number':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion17=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError17=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError17=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator17=annotation.types[Symbol.iterator](),_step17;!(_iteratorNormalCompletion17=(_step17=_iterator17.next()).done);_iteratorNormalCompletion17=true){<span class="cstat-no" title="statement not covered" >var _type8=_step17.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeBooleanAnnotation(_type8);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError17=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError17=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion17&amp;&amp;_iterator17.return){<span class="cstat-no" title="statement not covered" >_iterator17.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError17){<span class="cstat-no" title="statement not covered" >throw _iteratorError17;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a function,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeFunctionAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeFunctionAnnotation(annotation.typeAnnotation);c</span>ase 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Number':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion18=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError18=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError18=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator18=annotation.types[Symbol.iterator](),_step18;!(_iteratorNormalCompletion18=(_step18=_iterator18.next()).done);_iteratorNormalCompletion18=true){<span class="cstat-no" title="statement not covered" >var _type9=_step18.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeFunctionAnnotation(_type9);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError18=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError18=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion18&amp;&amp;_iterator18.return){<span class="cstat-no" title="statement not covered" >_iterator18.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError18){<span class="cstat-no" title="statement not covered" >throw _iteratorError18;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with an undefined or null type,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeNullableAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'NullableTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'MixedTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return maybeNullableAnnotation(annotation.typeAnnotation);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >switch(annotation.id.name){case 'Array':case 'Number':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':<span class="cstat-no" title="statement not covered" >return false;c</span>ase 'Generator':<span class="cstat-no" title="statement not covered" >if(annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1){<span class="cstat-no" title="statement not covered" >return maybeNullableAnnotation(annotation.typeParameters.params[1]);}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion19=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError19=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError19=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator19=annotation.types[Symbol.iterator](),_step19;!(_iteratorNormalCompletion19=(_step19=_iterator19.next()).done);_iteratorNormalCompletion19=true){<span class="cstat-no" title="statement not covered" >var _type10=_step19.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeNullableAnnotation(_type10);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError19=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError19=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion19&amp;&amp;_iterator19.return){<span class="cstat-no" title="statement not covered" >_iterator19.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError19){<span class="cstat-no" title="statement not covered" >throw _iteratorError19;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with an object type,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeInstanceOfAnnotation(annotation,expected,typeParameters){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeInstanceOfAnnotation(annotation.typeAnnotation,expected,typeParameters);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(annotation.id.name===expected.name){<span class="cstat-no" title="statement not covered" >if(typeParameters.length===0){<span class="cstat-no" title="statement not covered" >return true;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length){<span class="cstat-no" title="statement not covered" >var trueCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar nullCount=0;<span class="cstat-no" title="statement not covered" >f</span>or(var i=0;i&lt;typeParameters.length&amp;&amp;i&lt;annotation.typeParameters.params.length;i++){<span class="cstat-no" title="statement not covered" >var result=compareAnnotations(typeParameters[i],annotation.typeParameters.params[i]);<span class="cstat-no" title="statement not covered" >i</span>f(result===false){<span class="cstat-no" title="statement not covered" >return false;}</span>else <span class="cstat-no" title="statement not covered" >if(result===true){<span class="cstat-no" title="statement not covered" >trueCount++;}</span>else {<span class="cstat-no" title="statement not covered" >nullCount++;}</span>}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn trueCount&gt;0&amp;&amp;nullCount===0?true:null;}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null;c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion20=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError20=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError20=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator20=annotation.types[Symbol.iterator](),_step20;!(_iteratorNormalCompletion20=(_step20=_iterator20.next()).done);_iteratorNormalCompletion20=true){<span class="cstat-no" title="statement not covered" >var _type11=_step20.value;<span class="cstat-no" title="statement not covered" >v</span>ar _result=maybeInstanceOfAnnotation(_type11,expected,typeParameters);<span class="cstat-no" title="statement not covered" >i</span>f(_result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(_result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError20=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError20=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion20&amp;&amp;_iterator20.return){<span class="cstat-no" title="statement not covered" >_iterator20.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError20){<span class="cstat-no" title="statement not covered" >throw _iteratorError20;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(expected.name==='Array'||expected.name==='RegExp'||expected.name==='Error'||expected.name==='Function'||expected.name==='String'||expected.name==='Object'){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(expected.name==='Array'||expected.name==='RegExp'||expected.name==='Error'||expected.name==='Function'){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'FunctionTypeAnnotation':<span class="cstat-no" title="statement not covered" >if(expected.name==='Function'){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with an array,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeArrayAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeArrayAnnotation(annotation.typeAnnotation);c</span>ase 'TupleTypeAnnotation':case 'ArrayTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation.id.name==='Array'?true:null;c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion21=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError21=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError21=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator21=annotation.types[Symbol.iterator](),_step21;!(_iteratorNormalCompletion21=(_step21=_iterator21.next()).done);_iteratorNormalCompletion21=true){<span class="cstat-no" title="statement not covered" >var _type12=_step21.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeArrayAnnotation(_type12);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError21=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError21=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion21&amp;&amp;_iterator21.return){<span class="cstat-no" title="statement not covered" >_iterator21.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError21){<span class="cstat-no" title="statement not covered" >throw _iteratorError21;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with an iterable,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeIterableAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeIterableAnnotation(annotation.typeAnnotation);c</span>ase 'TupleTypeAnnotation':case 'ArrayTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >return annotation.id.name==='Iterable'?true:null;c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion22=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError22=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError22=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator22=annotation.types[Symbol.iterator](),_step22;!(_iteratorNormalCompletion22=(_step22=_iterator22.next()).done);_iteratorNormalCompletion22=true){<span class="cstat-no" title="statement not covered" >var _type13=_step22.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeIterableAnnotation(_type13);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError22=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError22=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion22&amp;&amp;_iterator22.return){<span class="cstat-no" title="statement not covered" >_iterator22.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError22){<span class="cstat-no" title="statement not covered" >throw _iteratorError22;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':<span class="cstat-no" title="statement not covered" >return false;d</span>efault:<span class="cstat-no" title="statement not covered" >return null;}</span>}</span> /**
   * Returns `true` if the annotation is compatible with a tuple,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */<span class="fstat-no" title="function not covered" >function maybeTupleAnnotation(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':<span class="cstat-no" title="statement not covered" >return maybeTupleAnnotation(annotation.typeAnnotation);c</span>ase 'TupleTypeAnnotation':<span class="cstat-no" title="statement not covered" >return true;c</span>ase 'UnionTypeAnnotation':<span class="cstat-no" title="statement not covered" >var falseCount=0;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorNormalCompletion23=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError23=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError23=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator23=annotation.types[Symbol.iterator](),_step23;!(_iteratorNormalCompletion23=(_step23=_iterator23.next()).done);_iteratorNormalCompletion23=true){<span class="cstat-no" title="statement not covered" >var _type14=_step23.value;<span class="cstat-no" title="statement not covered" >v</span>ar result=maybeTupleAnnotation(_type14);<span class="cstat-no" title="statement not covered" >i</span>f(result===true){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(result===false){<span class="cstat-no" title="statement not covered" >falseCount++;}</span>}</span></span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError23=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError23=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion23&amp;&amp;_iterator23.return){<span class="cstat-no" title="statement not covered" >_iterator23.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError23){<span class="cstat-no" title="statement not covered" >throw _iteratorError23;}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(falseCount===annotation.types.length){<span class="cstat-no" title="statement not covered" >return false;}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>c</span>ase 'GenericTypeAnnotation':case 'AnyTypeAnnotation':case 'ArrayTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':<span class="cstat-no" title="statement not covered" >return null;d</span>efault:<span class="cstat-no" title="statement not covered" >return false;}</span>}<span class="fstat-no" title="function not covered" ></span>function humanReadableType(annotation){<span class="cstat-no" title="statement not covered" ></span>switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':<span class="cstat-no" title="statement not covered" >return humanReadableType(annotation.typeAnnotation);c</span>ase 'FunctionTypeAnnotation': // @fixme babel doesn't seem to like generating FunctionTypeAnnotations yet</span>
<span class="cstat-no" title="statement not covered" >return '('+annotation.params.map(humanReadableType).join(', ')+') =&gt; '+humanReadableType(annotation.returnType);c</span>ase 'GenericTypeAnnotation':<span class="cstat-no" title="statement not covered" >var path=getNodePath(annotation);<span class="cstat-no" title="statement not covered" >v</span>ar checker=path&amp;&amp;getTypeChecker(annotation.id,path.scope);<span class="cstat-no" title="statement not covered" >i</span>f(checker&amp;&amp;checker.node.savedTypeAnnotation){<span class="cstat-no" title="statement not covered" >return humanReadableType(checker.node.savedTypeAnnotation);}</span>else {<span class="cstat-no" title="statement not covered" >return (0,_babelGenerator2.default)(annotation).code;}</span>d</span>efault:<span class="cstat-no" title="statement not covered" >return (0,_babelGenerator2.default)(annotation).code;}</span>} /**
   * Get the path directly from a node.
   */<span class="fstat-no" title="function not covered" >function getNodePath(node){<span class="cstat-no" title="statement not covered" ></span>if(node._paths&amp;&amp;node._paths.length){<span class="cstat-no" title="statement not covered" >return node._paths[0];}</span>else {<span class="cstat-no" title="statement not covered" >return null;}</span>}<span class="fstat-no" title="function not covered" ></span>function getTypeChecker(id,scope){<span class="cstat-no" title="statement not covered" ></span>var checker=scope.getData('typechecker:'+id.name);<span class="cstat-no" title="statement not covered" >i</span>f(checker){<span class="cstat-no" title="statement not covered" >return checker;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar binding=scope.getBinding(id.name);<span class="cstat-no" title="statement not covered" >i</span>f(binding===undefined){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar path=binding.path;<span class="cstat-no" title="statement not covered" >i</span>f(path==null){<span class="cstat-no" title="statement not covered" >return false;}</span>else <span class="cstat-no" title="statement not covered" >if(path.type==='TypeAlias'){<span class="cstat-no" title="statement not covered" >return path;}</span>else <span class="cstat-no" title="statement not covered" >if(path.type==='VariableDeclaration'&amp;&amp;path.node.isTypeChecker){<span class="cstat-no" title="statement not covered" >return path.get('declarations')[0];}</span>else <span class="cstat-no" title="statement not covered" >if(path.isImportSpecifier()&amp;&amp;path.parent.importKind==='type'){<span class="cstat-no" title="statement not covered" >return path;}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span>eturn false;}<span class="fstat-no" title="function not covered" ></span>function isTypeChecker(id,scope){<span class="cstat-no" title="statement not covered" ></span>return scope.getData('typechecker:'+id.name)!==undefined;}<span class="fstat-no" title="function not covered" ></span>function isPolymorphicType(id,scope){<span class="cstat-no" title="statement not covered" ></span>var binding=scope.getBinding(id.name);<span class="cstat-no" title="statement not covered" >i</span>f(binding!==undefined){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar path=scope.path;<span class="cstat-no" title="statement not covered" >w</span>hile(path&amp;&amp;path.type!=='Program'){<span class="cstat-no" title="statement not covered" >var _path=path;<span class="cstat-no" title="statement not covered" >v</span>ar _node=_path.node;<span class="cstat-no" title="statement not covered" >i</span>f((t.isFunction(_node)||t.isClass(_node))&amp;&amp;_node.typeParameters){<span class="cstat-no" title="statement not covered" >var _iteratorNormalCompletion24=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError24=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError24=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator24=_node.typeParameters.params[Symbol.iterator](),_step24;!(_iteratorNormalCompletion24=(_step24=_iterator24.next()).done);_iteratorNormalCompletion24=true){<span class="cstat-no" title="statement not covered" >var param=_step24.value;<span class="cstat-no" title="statement not covered" >p</span>aram.isPolymorphicType=true;<span class="cstat-no" title="statement not covered" >i</span>f(param.name===id.name){<span class="cstat-no" title="statement not covered" >return true;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError24=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError24=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion24&amp;&amp;_iterator24.return){<span class="cstat-no" title="statement not covered" >_iterator24.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError24){<span class="cstat-no" title="statement not covered" >throw _iteratorError24;}</span>}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>p</span>ath=path.parentPath;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}<span class="fstat-no" title="function not covered" ></span>function getPolymorphicType(id,scope){<span class="cstat-no" title="statement not covered" ></span>var binding=scope.getBinding(id.name);<span class="cstat-no" title="statement not covered" >i</span>f(binding!==undefined){<span class="cstat-no" title="statement not covered" >return false;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar path=scope.path;<span class="cstat-no" title="statement not covered" >w</span>hile(path&amp;&amp;path.type!=='Program'){<span class="cstat-no" title="statement not covered" >var _path2=path;<span class="cstat-no" title="statement not covered" >v</span>ar _node2=_path2.node;<span class="cstat-no" title="statement not covered" >i</span>f(t.isFunction(_node2)&amp;&amp;_node2.typeParameters){<span class="cstat-no" title="statement not covered" >var _iteratorNormalCompletion25=true;<span class="cstat-no" title="statement not covered" >v</span>ar _didIteratorError25=false;<span class="cstat-no" title="statement not covered" >v</span>ar _iteratorError25=undefined;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >for(var _iterator25=_node2.typeParameters.params[Symbol.iterator](),_step25;!(_iteratorNormalCompletion25=(_step25=_iterator25.next()).done);_iteratorNormalCompletion25=true){<span class="cstat-no" title="statement not covered" >var param=_step25.value;<span class="cstat-no" title="statement not covered" >p</span>aram.isPolymorphicType=true;<span class="cstat-no" title="statement not covered" >i</span>f(param.name===id.name){<span class="cstat-no" title="statement not covered" >return param;}</span>}</span>}</span>catch(err){<span class="cstat-no" title="statement not covered" >_didIteratorError25=true;<span class="cstat-no" title="statement not covered" >_</span>iteratorError25=err;}</span>finally {<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(!_iteratorNormalCompletion25&amp;&amp;_iterator25.return){<span class="cstat-no" title="statement not covered" >_iterator25.return();}</span>}</span>finally {<span class="cstat-no" title="statement not covered" >if(_didIteratorError25){<span class="cstat-no" title="statement not covered" >throw _iteratorError25;}</span>}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>p</span>ath=path.parent;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null;}<span class="fstat-no" title="function not covered" ></span>function collectParamChecks(path,context){<span class="cstat-no" title="statement not covered" ></span>return path.get('params').map(<span class="fstat-no" title="function not covered" >function(param){<span class="cstat-no" title="statement not covered" ></span>var node=param.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='AssignmentPattern'){<span class="cstat-no" title="statement not covered" >if(node.left.typeAnnotation){<span class="cstat-no" title="statement not covered" >return createDefaultParamGuard(param,context);}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='RestElement'){<span class="cstat-no" title="statement not covered" >if(node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return createRestParamGuard(param,context);}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(node.typeAnnotation){<span class="cstat-no" title="statement not covered" >return createParamGuard(param,context);}</span>}</span></span></span>).filter(identity);}<span class="fstat-no" title="function not covered" ></span>function createParamGuard(path,context){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >n</span>ode.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >n</span>ode.savedTypeAnnotation=node.typeAnnotation;<span class="cstat-no" title="statement not covered" >v</span>ar checkable=void 0;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='ObjectPattern'){<span class="cstat-no" title="statement not covered" >node.name=path.key;<span class="cstat-no" title="statement not covered" >c</span>heckable=t.memberExpression(t.identifier('arguments'),t.numericLiteral(path.key),true);}</span>else {<span class="cstat-no" title="statement not covered" >checkable=node;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar check=checkAnnotation(checkable,node.typeAnnotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!check){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.optional){<span class="cstat-no" title="statement not covered" >check=t.logicalExpression('||',checks.undefined({input:checkable}),check);}<span class="cstat-no" title="statement not covered" ></span>v</span>ar message=paramTypeErrorMessage(checkable,context,node.typeAnnotation);<span class="cstat-no" title="statement not covered" >r</span>eturn guard({check:check,message:message});}<span class="fstat-no" title="function not covered" ></span>function createDefaultParamGuard(path,context){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.left;<span class="cstat-no" title="statement not covered" >v</span>ar value=node.right;<span class="cstat-no" title="statement not covered" >v</span>ar ok=staticCheckAnnotation(path.get('right'),id.typeAnnotation);<span class="cstat-no" title="statement not covered" >i</span>f(ok===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid default value for argument "'+id.name+'".',id.typeAnnotation,getAnnotation(path.get('right'))));}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn createParamGuard(path.get('left'),context);}<span class="fstat-no" title="function not covered" ></span>function createRestParamGuard(path,context){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar id=node.argument;<span class="cstat-no" title="statement not covered" >i</span>d.hasBeenTypeChecked=true;<span class="cstat-no" title="statement not covered" >n</span>ode.savedTypeAnnotation=node.typeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(isStrictlyArrayAnnotation(node.typeAnnotation)===false){<span class="cstat-no" title="statement not covered" >throw path.buildCodeFrameError(buildErrorMessage('Invalid type annotation for rest argument "'+id.name+'".',t.genericTypeAnnotation(t.identifier('Array')),node.typeAnnotation));}<span class="cstat-no" title="statement not covered" ></span>v</span>ar check=checkAnnotation(id,node.typeAnnotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(!check){<span class="cstat-no" title="statement not covered" >return;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.optional){<span class="cstat-no" title="statement not covered" >check=t.logicalExpression('||',checks.undefined({input:id}),check);}<span class="cstat-no" title="statement not covered" ></span>v</span>ar message=paramTypeErrorMessage(id,context,node.typeAnnotation);<span class="cstat-no" title="statement not covered" >r</span>eturn guard({check:check,message:message});}<span class="fstat-no" title="function not covered" ></span>function returnTypeErrorMessage(path,fn,id,context){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >v</span>ar scope=path.scope;<span class="cstat-no" title="statement not covered" >v</span>ar name=fn.id?fn.id.name:'';<span class="cstat-no" title="statement not covered" >v</span>ar annotation=fn.returnType;<span class="cstat-no" title="statement not covered" >i</span>f(annotation.type==='TypeAnnotation'){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeAnnotation;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(fn.generator&amp;&amp;isGeneratorAnnotation(annotation)&amp;&amp;annotation.typeParameters&amp;&amp;annotation.typeParameters.params.length&gt;1){<span class="cstat-no" title="statement not covered" >annotation=annotation.typeParameters.params[1];}<span class="cstat-no" title="statement not covered" ></span>v</span>ar message='Function '+(name?'"'+name+'" ':'')+'return value violates contract.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn t.binaryExpression('+',t.stringLiteral(message),id?readableName({inspect:context.inspect,input:id}):node.argument?readableName({inspect:context.inspect,input:node.argument}):t.stringLiteral('undefined'));}<span class="fstat-no" title="function not covered" ></span>function yieldTypeErrorMessage(fn,annotation,id,context){<span class="cstat-no" title="statement not covered" ></span>var name=fn.id?fn.id.name:'';<span class="cstat-no" title="statement not covered" >v</span>ar message='Function '+(name?'"'+name+'" ':'')+'yielded an invalid value.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:id}));}<span class="fstat-no" title="function not covered" ></span>function yieldNextTypeErrorMessage(fn,annotation,id,context){<span class="cstat-no" title="statement not covered" ></span>var name=fn.id?fn.id.name:'';<span class="cstat-no" title="statement not covered" >v</span>ar message='Generator '+(name?'"'+name+'" ':'')+'received an invalid next value.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:id}));}<span class="fstat-no" title="function not covered" ></span>function paramTypeErrorMessage(node,context){<span class="cstat-no" title="statement not covered" ></span>var typeAnnotation=arguments.length&lt;=2||arguments[2]===undefined?node.typeAnnotation:arguments[2];<span class="cstat-no" title="statement not covered" >v</span>ar name=node.name;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='MemberExpression'&amp;&amp;node.object.name==='arguments'){<span class="cstat-no" title="statement not covered" >name=node.property.value;}<span class="cstat-no" title="statement not covered" ></span>v</span>ar message='Value of '+(node.optional?'optional ':'')+'argument '+JSON.stringify(name)+' violates contract.\n\nExpected:\n'+humanReadableType(typeAnnotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:node}));}<span class="fstat-no" title="function not covered" ></span>function varTypeErrorMessage(node,context){<span class="cstat-no" title="statement not covered" ></span>var annotation=node.typeAnnotation;<span class="cstat-no" title="statement not covered" >i</span>f(node.type==='Identifier'){<span class="cstat-no" title="statement not covered" >var _name3=node.name;<span class="cstat-no" title="statement not covered" >v</span>ar message='Value of variable "'+_name3+'" violates contract.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:node}));}</span>else {<span class="cstat-no" title="statement not covered" >var _message='Value of "'+humanReadableType(node)+'" violates contract.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';<span class="cstat-no" title="statement not covered" >r</span>eturn t.binaryExpression('+',t.stringLiteral(_message),readableName({inspect:context.inspect,input:node}));}</span>}</span> /**
   * Create a React property validator
   */<span class="fstat-no" title="function not covered" >function generatePropType(annotation,scope,context){<span class="cstat-no" title="statement not covered" ></span>var prop=t.identifier('prop');<span class="cstat-no" title="statement not covered" >v</span>ar check=checkAnnotation(prop,annotation,scope);<span class="cstat-no" title="statement not covered" >i</span>f(check){<span class="cstat-no" title="statement not covered" >return propType({check:check,prop:prop,expected:t.stringLiteral(humanReadableType(annotation)),got:readableName({inspect:context.inspect,input:prop})});}</span>else {<span class="cstat-no" title="statement not covered" >return t.functionExpression(null,[],t.blockStatement([]));}</span>}</span> /**
   * Determine whether the given node can produce purely boolean results.
   */<span class="fstat-no" title="function not covered" >function isBooleanExpression(node){<span class="cstat-no" title="statement not covered" ></span>if(node.type==='BinaryExpression'&amp;&amp;BOOLEAN_BINARY_OPERATORS.indexOf(node.operator)&gt;-1){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='LogicalExpression'){<span class="cstat-no" title="statement not covered" >return isBooleanExpression(node.left)&amp;&amp;isBooleanExpression(node.right);}</span>else {<span class="cstat-no" title="statement not covered" >return false;}</span>}</span></span> /**
   * Convert type specifier to expression.
   */<span class="fstat-no" title="function not covered" >function createTypeExpression(node){<span class="cstat-no" title="statement not covered" ></span>if(node.type=='Identifier'){<span class="cstat-no" title="statement not covered" >return node;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type=='QualifiedTypeIdentifier'){<span class="cstat-no" title="statement not covered" >return t.memberExpression(createTypeExpression(node.qualification),createTypeExpression(node.id));}<span class="cstat-no" title="statement not covered" ></span>t</span></span>hrow this.errorWithNode('Unsupported type: '+node.type);}</span> /**
   * Get name of a type as a string.
   */<span class="fstat-no" title="function not covered" >function getTypeName(node){<span class="cstat-no" title="statement not covered" ></span>if(node.type=='Identifier'){<span class="cstat-no" title="statement not covered" >return node.name;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type=='QualifiedTypeIdentifier'){<span class="cstat-no" title="statement not covered" >return getTypeName(node.qualification)+'.'+getTypeName(node.id);}<span class="cstat-no" title="statement not covered" ></span>t</span></span>hrow this.errorWithNode('Unsupported type: '+node.type);}</span> /**
   * Union two arrays.
   */<span class="fstat-no" title="function not covered" >function union(arr1,arr2){<span class="cstat-no" title="statement not covered" ></span>for(var i=0;i&lt;arr2.length;i++){<span class="cstat-no" title="statement not covered" >var item=arr2[i];<span class="cstat-no" title="statement not covered" >i</span>f(arr1.indexOf(item)===-1){<span class="cstat-no" title="statement not covered" >arr1.push(item);}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn arr1;}</span> /**
   * Determine whether the given annotation allows any value.
   */<span class="fstat-no" title="function not covered" >function allowsAny(annotation){<span class="cstat-no" title="statement not covered" ></span>if(annotation.type==='TypeAnnotation'||annotation.type==='NullableTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return allowsAny(annotation.typeAnnotation);}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.type==='AnyTypeAnnotation'||annotation.type==='MixedTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(annotation.type==='UnionTypeAnnotation'){<span class="cstat-no" title="statement not covered" >return annotation.types.some(allowsAny);}</span>else {<span class="cstat-no" title="statement not covered" >return false;}</span>}</span></span></span> /**
   * Determine whether a given node is nully (null or undefined).
   */<span class="fstat-no" title="function not covered" >function isNodeNully(node){<span class="cstat-no" title="statement not covered" ></span>if(node==null){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='Identifier'&amp;&amp;node.name==='undefined'){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='Literal'&amp;&amp;node.value===null){<span class="cstat-no" title="statement not covered" >return true;}</span>else <span class="cstat-no" title="statement not covered" >if(node.type==='UnaryExpression'&amp;&amp;node.operator==='void'){<span class="cstat-no" title="statement not covered" >return true;}</span>else {<span class="cstat-no" title="statement not covered" >return false;}</span>}</span></span></span></span> /**
   * Determine whether the file should be checked
   */<span class="fstat-no" title="function not covered" >function mustCheckFile(path,opts){<span class="cstat-no" title="statement not covered" ></span>if(path.node.leadingComments&amp;&amp;path.node.leadingComments.length){<span class="cstat-no" title="statement not covered" >return opts.only&amp;&amp;!skipEnvironment(path.node.leadingComments,opts);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}</span> /**
   * Determine whether the file should be skipped, based on the comments attached to the given node.
   */<span class="fstat-no" title="function not covered" >function maybeSkipFile(path,opts){<span class="cstat-no" title="statement not covered" ></span>if(path.node.leadingComments&amp;&amp;path.node.leadingComments.length){<span class="cstat-no" title="statement not covered" >if(skipEnvironment(path.node.leadingComments,opts)){<span class="cstat-no" title="statement not covered" >return true;}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn path.node.leadingComments.some(<span class="fstat-no" title="function not covered" >function(comment){<span class="cstat-no" title="statement not covered" ></span>return PRAGMA_IGNORE_FILE.test(comment.value);}</span>);}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}</span> /**
   * Maybe skip the given path if it has a relevant pragma.
   */<span class="fstat-no" title="function not covered" >function maybeSkip(path){<span class="cstat-no" title="statement not covered" ></span>var node=path.node;<span class="cstat-no" title="statement not covered" >i</span>f(node.hasBeenTypeChecked){<span class="cstat-no" title="statement not covered" >return true;}<span class="cstat-no" title="statement not covered" ></span>i</span>f(node.leadingComments&amp;&amp;node.leadingComments.length){<span class="cstat-no" title="statement not covered" >var comment=node.leadingComments[node.leadingComments.length-1];<span class="cstat-no" title="statement not covered" >i</span>f(PRAGMA_IGNORE_STATEMENT.test(comment.value)){<span class="cstat-no" title="statement not covered" >path.skip();<span class="cstat-no" title="statement not covered" >r</span>eturn true;}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn false;}</span> /**
   * A function that returns its first argument, useful when filtering.
   */<span class="fstat-no" title="function not covered" >function identity(input){<span class="cstat-no" title="statement not covered" ></span>return input;}<span class="fstat-no" title="function not covered" ></span>function getExpression(node){<span class="cstat-no" title="statement not covered" ></span>return t.isExpressionStatement(node)?node.expression:node;}<span class="fstat-no" title="function not covered" ></span>function expression(input){<span class="cstat-no" title="statement not covered" ></span>var fn=template(input);<span class="cstat-no" title="statement not covered" >r</span>eturn <span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ></span>var node=fn.apply(undefined,arguments);<span class="cstat-no" title="statement not covered" >r</span>eturn getExpression(node);}</span>;}</span>};var _babelGenerator=require('babel-generator');var _babelGenerator2=_interopRequireDefault(_babelGenerator);function _interopRequireDefault(obj){return obj&amp;&amp;obj.__esModule?obj:<span class="branch-1 cbranch-no" title="branch not covered" >{default:obj};</span>}<span class="fstat-no" title="function not covered" >function _toConsumableArray(arr){<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(arr)){<span class="cstat-no" title="statement not covered" >for(var i=0,arr2=Array(arr.length);i&lt;arr.length;i++){<span class="cstat-no" title="statement not covered" >arr2[i]=arr[i];}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn arr2;}</span>else {<span class="cstat-no" title="statement not covered" >return Array.from(arr);}</span>}</span>
&nbsp;</pre></td></tr>
</table></pre>
</div>
<div class="footer">
    <div class="meta">Generated by <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a> at Fri Apr 21 2017 23:52:58 GMT+0000 (UTC)</div>
</div>
</body>
</html>
