{"/home/travis/build/npmtest/node-npmtest-babel-plugin-typecheck/test.js":"/* istanbul instrument in package npmtest_babel_plugin_typecheck */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-babel-plugin-typecheck/lib.npmtest_babel_plugin_typecheck.js":"/* istanbul instrument in package npmtest_babel_plugin_typecheck */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_babel_plugin_typecheck = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_babel_plugin_typecheck = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-babel-plugin-typecheck/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-babel-plugin-typecheck && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_babel_plugin_typecheck */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_babel_plugin_typecheck\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_babel_plugin_typecheck.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_babel_plugin_typecheck.rollup.js'] =\n            local.assetsDict['/assets.npmtest_babel_plugin_typecheck.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_babel_plugin_typecheck.__dirname + '/lib.npmtest_babel_plugin_typecheck.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/index.js":"'use strict';Object.defineProperty(exports,\"__esModule\",{value:true});var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally {try{if(!_n&&_i[\"return\"])_i[\"return\"]();}finally {if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else {throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");}};}(); /**\n * # Typecheck Transformer\n */exports.default=function(_ref){var t=_ref.types;var template=_ref.template; /**\n   * Binary Operators that can only produce boolean results.\n   */var BOOLEAN_BINARY_OPERATORS=['==','===','>=','<=','>','<','instanceof'];var checks=createChecks();var staticChecks=createStaticChecks();var checkIsArray=expression('Array.isArray(input)');var checkIsMap=expression('input instanceof Map');var checkIsSet=expression('input instanceof Set');var checkIsClass=expression('typeof input === \\'function\\' && input.prototype && input.prototype.constructor === input');var checkIsGenerator=expression('typeof input === \\'function\\' && input.generator');var checkIsIterable=expression('input && (typeof input[Symbol.iterator] === \\'function\\' || Array.isArray(input))');var checkIsObject=expression('input != null && typeof input === \\'object\\'');var checkNotNull=expression('input != null');var checkEquals=expression('input === expected');var declareTypeChecker=template('\\n    const id = (function () {\\n      function id (input) {\\n        return check;\\n      };\\n      Object.defineProperty(id, Symbol.hasInstance, {\\n        value: function (input) {\\n          return id(input);\\n        }\\n      });\\n      return id;\\n    })();\\n  ');var guard=template('\\n    if (!check) {\\n      throw new TypeError(message);\\n    }\\n  ');var thrower=template('\\n    if (check) {\\n      ret;\\n    }\\n    else {\\n      throw new TypeError(message);\\n    }\\n  ');var guardInline=expression('\\n    (id => {\\n      if (!check) {\\n        throw new TypeError(message);\\n      }\\n      return id;\\n    })(input)\\n  ');var guardFn=expression('\\n    function name (id) {\\n      if (!check) {\\n        throw new TypeError(message);\\n      }\\n      return id;\\n    }\\n  ');var readableName=expression('\\n    inspect(input)\\n  ');var checkMapKeys=expression('\\n    input instanceof Map && Array.from(input.keys()).every(key => keyCheck)\\n  ');var checkMapValues=expression('\\n    input instanceof Map && Array.from(input.values()).every(value => valueCheck)\\n  ');var checkMapEntries=expression('\\n    input instanceof Map && Array.from(input).every(([key, value]) => keyCheck && valueCheck)\\n  ');var checkSetEntries=expression('\\n    input instanceof Set && Array.from(input).every(value => valueCheck)\\n  ');var checkObjectIndexers=expression('\\n    Object.keys(input).every(key => {\\n      const value = input[key];\\n      if (~fixedKeys.indexOf(key)) {\\n        return true;\\n      }\\n      else {\\n        return check;\\n      }\\n    });\\n  ');var checkObjectIndexersNoFixed=expression('\\n    Object.keys(input).every(key => {\\n      const value = input[key];\\n      return check;\\n    });\\n  ');var propType=expression('\\n    (function(props, name, component) {\\n      var prop = props[name];\\n      if(!check) {\\n        return new Error(\\n          \"Invalid prop `\" + name + \"` supplied to `\" + component\\n          + \"`.\\\\n\\\\nExpected:\\\\n\" + expected + \"\\\\n\\\\nGot:\\\\n\" + got + \"\\\\n\\\\n\"\\n        );\\n      }\\n    })\\n  ');var PRAGMA_IGNORE_STATEMENT=/typecheck:\\s*ignore\\s+statement/i;var PRAGMA_IGNORE_FILE=/typecheck:\\s*ignore\\s+file/i;function skipEnvironment(comments,opts){if(!opts.only){return false;}var envs=pragmaEnvironments(comments);return !opts.only.some(function(env){return envs[env];});}function pragmaEnvironments(comments){var pragma=/@typecheck:\\s*(.+)/;var environments={};comments.forEach(function(comment){var m=comment.value.match(pragma);if(m){m[1].split(',').forEach(function(env){return environments[env.trim()]=true;});}});return environments;}var visitors={Statement:function Statement(path){maybeSkip(path);},TypeAlias:function TypeAlias(path){if(maybeSkip(path)){return;}path.replaceWith(createTypeAliasChecks(path));},InterfaceDeclaration:function InterfaceDeclaration(path){if(maybeSkip(path)){return;}path.replaceWith(createInterfaceChecks(path));},ExportNamedDeclaration:function ExportNamedDeclaration(path){if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;if(node.declaration&&node.declaration.type==='TypeAlias'){var declaration=path.get('declaration');declaration.replaceWith(createTypeAliasChecks(declaration));node.exportKind='value';}},ImportDeclaration:function ImportDeclaration(path){if(maybeSkip(path)){return;}if(path.node.importKind!=='type'){return;}var _path$get$map$reduce=path.get('specifiers').map(function(specifier){var local=specifier.get('local');var tmpId=path.scope.generateUidIdentifierBasedOnNode(local.node);var replacement=t.importSpecifier(tmpId,specifier.node.imported);var id=t.identifier(local.node.name);id.isTypeChecker=true;var declarator=t.variableDeclarator(id,tmpId);declarator.isTypeChecker=true;return [declarator,replacement];}).reduce(function(_ref2,_ref3){var _ref5=_slicedToArray(_ref2,2);var declarators=_ref5[0];var specifiers=_ref5[1];var _ref4=_slicedToArray(_ref3,2);var declarator=_ref4[0];var specifier=_ref4[1];declarators.push(declarator);specifiers.push(specifier);return [declarators,specifiers];},[[],[]]);var _path$get$map$reduce2=_slicedToArray(_path$get$map$reduce,2);var declarators=_path$get$map$reduce2[0];var specifiers=_path$get$map$reduce2[1];var declaration=t.variableDeclaration('var',declarators);declaration.isTypeChecker=true;path.replaceWithMultiple([t.importDeclaration(specifiers,path.node.source),declaration]);},ArrowFunctionExpression:function ArrowFunctionExpression(path){ // Look for destructuring args with annotations.\nvar params=path.get('params');var _iteratorNormalCompletion=true;var _didIteratorError=false;var _iteratorError=undefined;try{for(var _iterator=params[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){var param=_step.value;if(param.isObjectPattern()&&param.node.typeAnnotation){var _path$get=path.get('body');var _scope=_path$get.scope;var _id=_scope.generateUidIdentifier('arg'+param.key);var pattern=param.node;param.replaceWith(_id);if(path.node.expression){var block=t.blockStatement([t.variableDeclaration('var',[t.variableDeclarator(pattern,_id)]),t.returnStatement(path.get('body').node)]);path.node.body=block;path.node.expression=false;}else {path.get('body.body')[0].insertBefore(t.variableDeclaration('var',[t.variableDeclarator(pattern,_id)]));}}}}catch(err){_didIteratorError=true;_iteratorError=err;}finally {try{if(!_iteratorNormalCompletion&&_iterator.return){_iterator.return();}}finally {if(_didIteratorError){throw _iteratorError;}}}},Function:{enter:function enter(path,context){var _node$body$body;if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;var paramChecks=collectParamChecks(path,context);if(node.type===\"ArrowFunctionExpression\"&&node.expression){node.expression=false;node.body=t.blockStatement([t.returnStatement(node.body)]);}if(node.returnType){createFunctionReturnGuard(path,context);createFunctionYieldGuards(path,context);}(_node$body$body=node.body.body).unshift.apply(_node$body$body,_toConsumableArray(paramChecks));node.savedTypeAnnotation=node.returnType;node.returnCount=0;node.yieldCount=0;},exit:function exit(path){var node=path.node;var scope=path.scope;var isVoid=node.savedTypeAnnotation?maybeNullableAnnotation(node.savedTypeAnnotation):null;if(!node.returnCount&&isVoid===false){var annotation=node.savedTypeAnnotation;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(node.generator&&isGeneratorAnnotation(annotation)&&annotation.typeParameters&&annotation.typeParameters.params.length>1){annotation=annotation.typeParameters.params[1];}throw path.buildCodeFrameError(buildErrorMessage('Function '+(node.id?'\"'+node.id.name+'\" ':'')+'did not return a value.',annotation));}if(node.nextGuardCount){path.get('body').get('body')[0].insertBefore(node.nextGuard);}if(node.yieldGuardCount){path.get('body').get('body')[0].insertBefore(node.yieldGuard);}if(node.returnGuardCount){path.get('body').get('body')[0].insertBefore(node.returnGuard);}}},YieldExpression:function YieldExpression(path,context){var fn=path.getFunctionParent();if(!fn){return;}fn.node.yieldCount++;if(!isGeneratorAnnotation(fn.node.returnType)||maybeSkip(path)){return;}var node=path.node;var parent=path.parent;var scope=path.scope;var annotation=fn.node.returnType;if(annotation.type==='NullableTypeAnnotation'||annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(!annotation.typeParameters||annotation.typeParameters.params.length===0){return;}var yieldType=annotation.typeParameters.params[0];var nextType=annotation.typeParameters.params[2];var ok=staticCheckAnnotation(path.get(\"argument\"),yieldType);if(ok===true&&!nextType){return;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'\"'+fn.node.id.name+'\" ':'')+'yielded an invalid type.',yieldType,getAnnotation(path.get('argument'))));}fn.node.yieldGuardCount++;if(fn.node.yieldGuard){var _yielder=t.yieldExpression(t.callExpression(fn.node.yieldGuardName,[node.argument||t.identifier('undefined')]));_yielder.hasBeenTypeChecked=true;if(fn.node.nextGuard){fn.node.nextGuardCount++;path.replaceWith(t.callExpression(fn.node.nextGuardName,[_yielder]));}else {path.replaceWith(_yielder);}}else if(fn.node.nextGuard){fn.node.nextGuardCount++;path.replaceWith(t.callExpression(fn.node.nextGuardName,[yielder]));}},ReturnStatement:function ReturnStatement(path,context){var fn=path.getFunctionParent();if(!fn){return;}fn.node.returnCount++;if(maybeSkip(path)){return;}var node=path.node;var parent=path.parent;var scope=path.scope;var _fn$node=fn.node;var returnType=_fn$node.returnType;var returnGuardName=_fn$node.returnGuardName;if(!returnType||!returnGuardName){return;}if(!node.argument){if(maybeNullableAnnotation(returnType)===false){throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'\"'+fn.node.id.name+'\" ':'')+'did not return a value.',returnType));}return;}var annotation=returnType;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(isGeneratorAnnotation(annotation)){annotation=annotation.typeParameters&&annotation.typeParameters.params.length>1?annotation.typeParameters.params[1]:t.anyTypeAnnotation();}else if(node.async&&annotation.type==='GenericTypeAnnotation'&&annotation.id.name==='Promise'){annotation=annotation.typeParameters&&annotation.typeParameters[0]||t.anyTypeAnnotation();}var ok=staticCheckAnnotation(path.get(\"argument\"),annotation);if(ok===true){return;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'\"'+fn.node.id.name+'\" ':'')+'returned an invalid type.',annotation,getAnnotation(path.get('argument'))));}fn.node.returnGuardCount++;var returner=t.returnStatement(t.callExpression(fn.node.returnGuardName,[node.argument]));returner.hasBeenTypeChecked=true;path.replaceWith(returner);},VariableDeclaration:function VariableDeclaration(path,context){if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;var collected=[];var declarations=path.get(\"declarations\");for(var i=0;i<node.declarations.length;i++){var declaration=node.declarations[i];var _id2=declaration.id;var init=declaration.init;if(!_id2.typeAnnotation||_id2.hasBeenTypeChecked){continue;}_id2.savedTypeAnnotation=_id2.typeAnnotation;_id2.hasBeenTypeChecked=true;var ok=staticCheckAnnotation(declarations[i],_id2.typeAnnotation);if(ok===true){continue;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid assignment value for \"'+_id2.name+'\".',_id2.typeAnnotation,getAnnotation(declarations[i])));}var check=checkAnnotation(_id2,_id2.typeAnnotation,scope);if(check){collected.push(guard({check:check,message:varTypeErrorMessage(_id2,context)}));}}if(collected.length>0){var _check=collected.reduce(function(check,branch){branch.alternate=check;return branch;});if(path.parent.type==='Program'||path.parent.type==='BlockStatement'){path.insertAfter(_check);}else if(path.parentPath.isForXStatement()||path.parentPath.isForStatement()||path.parentPath.isForInStatement()){var body=path.parentPath.get('body');if(body.type!=='BlockStatement'){var block=t.blockStatement([body.node]);body.replaceWith(block);body=path.parentPath.get('body');}var children=body.get('body');if(children.length===0){body.replaceWith(_check);}else {children[0].insertBefore(_check);}}else if(path.parent.type==='ExportNamedDeclaration'||path.parent.type==='ExportDefaultDeclaration'||path.parent.type==='ExportAllDeclaration'){path.parentPath.insertAfter(_check);}else {path.replaceWith(t.blockStatement([node,_check]));}}},AssignmentExpression:function AssignmentExpression(path,context){if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;var left=path.get('left');var annotation=void 0;if(node.hasBeenTypeChecked||node.left.hasBeenTypeChecked){return;}else if(left.isMemberExpression()){annotation=getAnnotation(left);}else if(t.isIdentifier(node.left)){var binding=scope.getBinding(node.left.name);if(!binding){return;}else if(binding.path.type!=='VariableDeclarator'){return;}annotation=left.getTypeAnnotation();if(annotation.type==='AnyTypeAnnotation'){var item=binding.path.get('id');annotation=item.node.savedTypeAnnotation||item.getTypeAnnotation();}}else {return;}node.hasBeenTypeChecked=true;node.left.hasBeenTypeChecked=true;var id=node.left;var right=path.get('right');if(annotation.type==='AnyTypeAnnotation'){return;}var ok=staticCheckAnnotation(right,annotation);if(ok===true){return;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid assignment value for \"'+humanReadableType(id)+'\".',annotation,getAnnotation(right)));}var check=checkAnnotation(id,annotation,scope);if(!id.typeAnnotation){id.typeAnnotation=annotation;}id.hasBeenTypeChecked=true;if(check){var parent=path.getStatementParent();parent.insertAfter(guard({check:check,message:varTypeErrorMessage(id,context)}));}},TypeCastExpression:function TypeCastExpression(path){var node=path.node;var target=void 0;switch(node.expression.type){case 'Identifier':target=node.expression;break;case 'AssignmentExpression':target=node.expression.left;break;default: // unsupported.\nreturn;}var id=path.scope.getBindingIdentifier(target.name);if(!id){return;}id.savedTypeAnnotation=path.getTypeAnnotation();},ForOfStatement:function ForOfStatement(path,context){if(maybeSkip(path)){return;}var left=path.get('left');var right=path.get('right');var rightAnnotation=getAnnotation(right);var leftAnnotation=left.isVariableDeclaration()?getAnnotation(left.get('declarations')[0].get('id')):getAnnotation(left);if(rightAnnotation.type!=='VoidTypeAnnotation'&&rightAnnotation.type!=='NullLiteralTypeAnnotation'){var ok=maybeIterableAnnotation(rightAnnotation);if(ok===false){throw path.buildCodeFrameError('Cannot iterate '+humanReadableType(rightAnnotation)+'.');}}var id=void 0;if(right.isIdentifier()){id=right.node;}else {id=path.scope.generateUidIdentifierBasedOnNode(right.node);path.scope.push({id:id});var replacement=t.expressionStatement(t.assignmentExpression('=',id,right.node));path.insertBefore(replacement);right.replaceWith(id);}path.insertBefore(guard({check:checks.iterable({input:id}),message:t.binaryExpression('+',t.stringLiteral('Expected '+humanReadableType(right.node)+' to be iterable, got '),readableName({inspect:context.inspect,input:id}))}));if(rightAnnotation.type!=='GenericTypeAnnotation'||rightAnnotation.id.name!=='Iterable'||!rightAnnotation.typeParameters||!rightAnnotation.typeParameters.params.length){return;}var annotation=rightAnnotation.typeParameters.params[0];if(compareAnnotations(annotation,leftAnnotation)===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid iterator type.',annotation,leftAnnotation));}},ClassDeclaration:function ClassDeclaration(path,context){ // Convert React props to propTypes\nif(!path.node.superClass){return;}var props=void 0;var hasRenderMethod=false;var _iteratorNormalCompletion2=true;var _didIteratorError2=false;var _iteratorError2=undefined;try{for(var _iterator2=path.get('body.body')[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=true){var memberPath=_step2.value;var classMember=memberPath.node;if(t.isClassProperty(classMember)){if(classMember.key.name==='propTypes'&&classMember.static){return;}else if(classMember.key.name==='props'&&!classMember.static){props=memberPath;}}if(t.isClassMethod(classMember)&&classMember.key.name==='render'){hasRenderMethod=true;}}}catch(err){_didIteratorError2=true;_iteratorError2=err;}finally {try{if(!_iteratorNormalCompletion2&&_iterator2.return){_iterator2.return();}}finally {if(_didIteratorError2){throw _iteratorError2;}}}var type=void 0;if(path.node.superTypeParameters){if(path.node.superTypeParameters.params.length!==3){return;}type=path.node.superTypeParameters.params[1];}if(props){type=props.node.typeAnnotation.typeAnnotation;}if(!type||!hasRenderMethod){return;}if(t.isGenericTypeAnnotation(type)){var binding=path.scope.getBinding(type.id.name);type=getAnnotation(binding.path);}if(!t.isObjectTypeAnnotation(type)){return;} // Now we have a class that has a superclass, an instance method called 'render'\n// and some property type annotations. We can be reasonably sure it's a React component.\nvar propTypes=t.objectExpression(type.properties.map(function(prop){return t.objectProperty(t.identifier(prop.key.name),generatePropType(prop.value,path.scope,context));}));if(path.node.decorators){var property=t.classProperty(t.identifier('propTypes'),propTypes);property.static=true;props.insertAfter(property);}else {var root=path.parentPath.isExportDeclaration()?path.parentPath:path;root.insertAfter(t.expressionStatement(t.assignmentExpression(\"=\",t.memberExpression(path.node.id,t.identifier(\"propTypes\")),propTypes)));}}}; /**\n   * Collect all the type declarations in the given path and add references to them for retreival later.\n   */function collectTypes(path){path.traverse({InterfaceDeclaration:function InterfaceDeclaration(path){path.scope.setData('typechecker:'+path.node.id.name,path);},TypeAlias:function TypeAlias(path){path.scope.setData('typechecker:'+path.node.id.name,path);},ImportDeclaration:function ImportDeclaration(path){if(path.node.importKind!=='type'){return;}path.get('specifiers').forEach(function(specifier){var local=specifier.get('local');if(local.isIdentifier()){path.scope.setData('typechecker:'+local.node.name,specifier);}else {path.scope.setData('typechecker:'+local.node.id.name,specifier);}});},\"Function|Class\":function FunctionClass(path){var node=path.node;if(node.typeParameters&&node.typeParameters.params){path.get('typeParameters').get('params').forEach(function(typeParam){path.get('body').scope.setData('typeparam:'+typeParam.node.name,typeParam);});}}});}return {visitor:{Program:function Program(path,_ref6){var opts=_ref6.opts;if(opts&&opts.disable&&opts.disable[process.env.NODE_ENV]){return;}var checkFile=false;var _iteratorNormalCompletion3=true;var _didIteratorError3=false;var _iteratorError3=undefined;try{for(var _iterator3=path.get('body')[Symbol.iterator](),_step3;!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=true){var _child=_step3.value;if(mustCheckFile(_child,opts)){checkFile=true;break;}}}catch(err){_didIteratorError3=true;_iteratorError3=err;}finally {try{if(!_iteratorNormalCompletion3&&_iterator3.return){_iterator3.return();}}finally {if(_didIteratorError3){throw _iteratorError3;}}}if(!checkFile){var _iteratorNormalCompletion4=true;var _didIteratorError4=false;var _iteratorError4=undefined;try{for(var _iterator4=path.get('body')[Symbol.iterator](),_step4;!(_iteratorNormalCompletion4=(_step4=_iterator4.next()).done);_iteratorNormalCompletion4=true){var child=_step4.value;if(maybeSkipFile(child,opts)){return;}}}catch(err){_didIteratorError4=true;_iteratorError4=err;}finally {try{if(!_iteratorNormalCompletion4&&_iterator4.return){_iterator4.return();}}finally {if(_didIteratorError4){throw _iteratorError4;}}}}collectTypes(path);var inspect=path.scope.generateUidIdentifier('inspect');var requiresHelpers={inspect:false};var context={get inspect(){requiresHelpers.inspect=true;return inspect;}};path.traverse(visitors,context);if(requiresHelpers.inspect){var body=path.get('body');body[body.length-1].insertAfter(template('\\n            function id (input, depth) {\\n              const maxDepth = 4;\\n              const maxKeys = 15;\\n              if (depth === undefined) {\\n                depth = 0;\\n              }\\n              depth += 1;\\n              if (input === null) {\\n                return \\'null\\';\\n              }\\n              else if (input === undefined) {\\n                return \\'void\\';\\n              }\\n              else if (typeof input === \\'string\\' || typeof input === \\'number\\' || typeof input === \\'boolean\\') {\\n                return typeof input;\\n              }\\n              else if (Array.isArray(input)) {\\n                if (input.length > 0) {\\n                  if (depth > maxDepth) return \\'[...]\\';\\n                  const first = id(input[0], depth);\\n                  if (input.every(item => id(item, depth) === first)) {\\n                    return first.trim() + \\'[]\\';\\n                  }\\n                  else {\\n                    return \\'[\\' + input.slice(0, maxKeys).map(item => id(item, depth)).join(\\', \\') + (input.length >= maxKeys ? \\', ...\\' : \\'\\') + \\']\\';\\n                  }\\n                }\\n                else {\\n                  return \\'Array\\';\\n                }\\n              }\\n              else {\\n                const keys = Object.keys(input);\\n                if (!keys.length) {\\n                  if (input.constructor && input.constructor.name && input.constructor.name !== \\'Object\\') {\\n                    return input.constructor.name;\\n                  }\\n                  else {\\n                    return \\'Object\\';\\n                  }\\n                }\\n                if (depth > maxDepth) return \\'{...}\\';\\n                const indent = \\'  \\'.repeat(depth - 1);\\n                let entries = keys.slice(0, maxKeys).map(key => {\\n                  return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key) ? key : JSON.stringify(key)) + \\': \\' + id(input[key], depth) + \\';\\';\\n                }).join(\\'\\\\n  \\' + indent);\\n                if (keys.length >= maxKeys) {\\n                  entries += \\'\\\\n  \\' + indent + \\'...\\';\\n                }\\n                if (input.constructor && input.constructor.name && input.constructor.name !== \\'Object\\') {\\n                  return input.constructor.name + \\' {\\\\n  \\' + indent + entries + \\'\\\\n\\' + indent + \\'}\\';\\n                }\\n                else {\\n                  return \\'{\\\\n  \\' + indent + entries + \\'\\\\n\\' + indent + \\'}\\';\\n                }\\n              }\\n            }\\n          ')({id:inspect}));}}}}; /**\n   * Create a function which can verify the return type for a function.\n   */function createFunctionReturnGuard(path,context){var node=path.node;var scope=path.scope;var annotation=node.returnType;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(isGeneratorAnnotation(annotation)){annotation=annotation.typeParameters&&annotation.typeParameters.params.length>1?annotation.typeParameters.params[1]:t.anyTypeAnnotation();}else if(node.async&&annotation.type==='GenericTypeAnnotation'&&annotation.id.name==='Promise'){annotation=annotation.typeParameters&&annotation.typeParameters[0]||t.anyTypeAnnotation();}var name=scope.generateUidIdentifierBasedOnNode(node);var id=scope.generateUidIdentifier('id');var check=checkAnnotation(id,annotation,scope);if(check){node.returnGuard=guardFn({id:id,name:name,check:check,message:returnTypeErrorMessage(path,path.node,id,context)});node.returnGuard.hasBeenTypeChecked=true;node.returnGuardName=name;node.returnGuardCount=0;}}function createFunctionYieldGuards(path,context){var node=path.node;var scope=path.scope;var annotation=node.returnType;if(annotation.type==='NullableTypeAnnotation'||annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(!annotation.typeParameters||annotation.typeParameters.params.length===0){return;}if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(!isGeneratorAnnotation(annotation)){return;}var yieldType=annotation.typeParameters.params[0];var nextType=annotation.typeParameters.params[2];if(yieldType){var _name=scope.generateUidIdentifier('check'+(node.id?node.id.name.slice(0,1).toUpperCase()+node.id.name.slice(1):'')+'Yield');var _id3=scope.generateUidIdentifier('id');var check=checkAnnotation(_id3,yieldType,scope);if(check){node.yieldGuard=guardFn({id:_id3,name:_name,check:check,message:yieldTypeErrorMessage(node,yieldType,_id3,context)});node.yieldGuardName=_name;node.yieldGuardCount=0;}}if(nextType){var _name2=scope.generateUidIdentifier('check'+(node.id?node.id.name.slice(0,1).toUpperCase()+node.id.name.slice(1):'')+'Next');var _id4=scope.generateUidIdentifier('id');var _check2=checkAnnotation(_id4,nextType,scope);if(_check2){node.nextGuard=guardFn({id:_id4,name:_name2,check:_check2,message:yieldNextTypeErrorMessage(node,nextType,_id4,context)});node.nextGuardName=_name2;node.nextGuardCount=0;}}}function isThisMemberExpression(path){var node=path.node;if(node.type==='ThisExpression'){return true;}else if(node.type==='MemberExpression'){return isThisMemberExpression(path.get('object'));}else {return false;}}function isGeneratorAnnotation(annotation){if(!annotation){return false;}if(annotation.type==='TypeAnnotation'||annotation.type==='NullableTypeAnnotation'){annotation=annotation.typeAnnotation;}return annotation.type==='GenericTypeAnnotation'&&annotation.id.name==='Generator';}function buildErrorMessage(message,expected,got){if(got){return message+'\\n\\nExpected:\\n'+humanReadableType(expected)+'\\n\\nGot:\\n'+humanReadableType(got);}else {return message+'\\n\\nExpected:\\n'+humanReadableType(expected);}}function createChecks(){return {number:expression('typeof input === \\'number\\''),numericLiteral:checkNumericLiteral,boolean:expression('typeof input === \\'boolean\\''),booleanLiteral:checkBooleanLiteral,class:checkClass,function:expression('typeof input === \\'function\\''),string:expression('typeof input === \\'string\\''),stringLiteral:checkStringLiteral,symbol:expression('typeof input === \\'symbol\\''),undefined:expression('input === undefined'),null:expression('input === null'),void:expression('input == null'),instanceof:expression('input instanceof type'),type:expression('type(input)'),mixed:function mixed(){return null;},any:function any(){return null;},union:checkUnion,intersection:checkIntersection,array:checkArray,map:checkMap,set:checkSet,generator:checkGenerator,iterable:checkIterable,tuple:checkTuple,object:checkObject,nullable:checkNullable,typeof:checkTypeof,int8:expression('typeof input === \\'number\\' && !isNaN(input) && input >= -128 && input <= 127 && input === Math.floor(input)'),uint8:expression('typeof input === \\'number\\' && !isNaN(input) && input >= 0 && input <= 255 && input === Math.floor(input)'),int16:expression('typeof input === \\'number\\' && !isNaN(input) && input >= -32768 && input <= 32767 && input === Math.floor(input)'),uint16:expression('typeof input === \\'number\\' && !isNaN(input) && input >= 0 && input <= 65535 && input === Math.floor(input)'),int32:expression('typeof input === \\'number\\' && !isNaN(input) && input >= -2147483648 && input <= 2147483647 && input === Math.floor(input)'),uint32:expression('typeof input === \\'number\\' && !isNaN(input) && input >= 0 && input <= 4294967295 && input === Math.floor(input)'),float32:expression('typeof input === \\'number\\' && !isNaN(input) && input >= -3.40282347e+38 && input <= 3.40282347e+38'),float64:expression('typeof input === \\'number\\' && !isNaN(input)'),double:expression('typeof input === \\'number\\' && !isNaN(input)')};}function createStaticChecks(){return {symbol:function symbol(path){return maybeSymbolAnnotation(getAnnotation(path));},instanceof:function _instanceof(_ref7){var path=_ref7.path;var annotation=_ref7.annotation;var type=createTypeExpression(annotation.id);var node=path.node;var scope=path.scope;if(type.name==='Object'&&node.type==='ObjectExpression'&&!scope.getBinding('Object')){return true;}else if(type.name==='Map'&&!scope.getBinding('Map')){return null;}else if(type.name==='Set'&&!scope.getBinding('Set')){return null;}else if(type.name==='Class'&&!scope.hasBinding('Class')){return null;}else if(type.name==='int8'&&!scope.hasBinding('int8')){return null;}else if(type.name==='uint8'&&!scope.hasBinding('uint8')){return null;}else if(type.name==='int16'&&!scope.hasBinding('int16')){return null;}else if(type.name==='uint16'&&!scope.hasBinding('uint16')){return null;}else if(type.name==='int32'&&!scope.hasBinding('int32')){return null;}else if(type.name==='uint32'&&!scope.hasBinding('uint32')){return null;}else if(type.name==='float32'&&!scope.hasBinding('float32')){return null;}else if(type.name==='float64'&&!scope.hasBinding('float64')){return null;}else if(type.name==='double'&&!scope.hasBinding('double')){return null;}return maybeInstanceOfAnnotation(getAnnotation(path),type,annotation.typeParameters?annotation.typeParameters.params:[]);},type:function(_type){function type(_x){return _type.apply(this,arguments);}type.toString=function(){return _type.toString();};return type;}(function(_ref8){var path=_ref8.path;var type=_ref8.type;return null;})};}function compareAnnotations(a,b){if(a.type==='TypeAnnotation'){a=a.typeAnnotation;}if(b.type==='TypeAnnotation'){b=b.typeAnnotation;}switch(a.type){case 'StringTypeAnnotation':return maybeStringAnnotation(b);case 'StringLiteral':case 'StringLiteralTypeAnnotation':return compareStringLiteralAnnotations(a,b);case 'NumberTypeAnnotation':return maybeNumberAnnotation(b);case 'NumericLiteral':case 'NumericLiteralTypeAnnotation':return compareNumericLiteralAnnotations(a,b);case 'BooleanTypeAnnotation':return maybeBooleanAnnotation(b);case 'BooleanLiteral':case 'BooleanLiteralTypeAnnotation':return compareBooleanLiteralAnnotations(a,b);case 'FunctionTypeAnnotation':return maybeFunctionAnnotation(b);case 'AnyTypeAnnotation':return null;case 'MixedTypeAnnotation':return null;case 'ObjectTypeAnnotation':return compareObjectAnnotation(a,b);case 'ArrayTypeAnnotation':return compareArrayAnnotation(a,b);case 'GenericTypeAnnotation':return compareGenericAnnotation(a,b);case 'TupleTypeAnnotation':return compareTupleAnnotation(a,b);case 'UnionTypeAnnotation':return compareUnionAnnotation(a,b);case 'IntersectionTypeAnnotation':return compareIntersectionAnnotation(a,b);case 'NullableTypeAnnotation':return compareNullableAnnotation(a,b);default:return null;}}function compareStringLiteralAnnotations(a,b){if(b.type==='StringLiteralTypeAnnotation'||b.type==='StringLiteral'){return a.value===b.value;}else {return maybeStringAnnotation(b)===false?false:null;}}function compareBooleanLiteralAnnotations(a,b){if(b.type==='BooleanLiteralTypeAnnotation'||b.type==='BooleanLiteral'){return a.value===b.value;}else {return maybeBooleanAnnotation(b)===false?false:null;}}function compareNumericLiteralAnnotations(a,b){if(b.type==='NumericLiteralTypeAnnotation'||b.type==='NumericLiteral'){return a.value===b.value;}else {return maybeNumberAnnotation(b)===false?false:null;}}function unionComparer(a,b,comparator){if(!a.types||a.types.length===0){return null;}var falseCount=0;var trueCount=0;if(!a.types){return null;}var _iteratorNormalCompletion5=true;var _didIteratorError5=false;var _iteratorError5=undefined;try{for(var _iterator5=a.types[Symbol.iterator](),_step5;!(_iteratorNormalCompletion5=(_step5=_iterator5.next()).done);_iteratorNormalCompletion5=true){var _type2=_step5.value;var result=comparator(_type2,b);if(result===true){if(b.type!=='UnionTypeAnnotation'){return true;}trueCount++;}else if(result===false){if(b.type==='UnionTypeAnnotation'){return false;}falseCount++;}}}catch(err){_didIteratorError5=true;_iteratorError5=err;}finally {try{if(!_iteratorNormalCompletion5&&_iterator5.return){_iterator5.return();}}finally {if(_didIteratorError5){throw _iteratorError5;}}}if(falseCount===a.types.length){return false;}else if(trueCount===a.types.length){return true;}else {return null;}}function intersectionComparer(a,b,comparator){var falseCount=0;var trueCount=0;if(!a.types){return null;}var _iteratorNormalCompletion6=true;var _didIteratorError6=false;var _iteratorError6=undefined;try{for(var _iterator6=a.types[Symbol.iterator](),_step6;!(_iteratorNormalCompletion6=(_step6=_iterator6.next()).done);_iteratorNormalCompletion6=true){var _type3=_step6.value;var result=comparator(_type3,b);if(result===true){trueCount++;}else if(result===false){return false;}}}catch(err){_didIteratorError6=true;_iteratorError6=err;}finally {try{if(!_iteratorNormalCompletion6&&_iterator6.return){_iterator6.return();}}finally {if(_didIteratorError6){throw _iteratorError6;}}}if(trueCount===a.types.length){return true;}else {return null;}}function compareObjectAnnotation(a,b){switch(b.type){case 'ObjectTypeAnnotation':break;case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return compareObjectAnnotation(a,b.typeAnnotation);case 'UnionTypeAnnotation':return unionComparer(a,b,compareObjectAnnotation);case 'IntersectionTypeAnnotation':return intersectionComparer(a,b,compareObjectAnnotation);case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':return false;default:return null;} // We're comparing two object annotations.\nvar allTrue=true;var _iteratorNormalCompletion7=true;var _didIteratorError7=false;var _iteratorError7=undefined;try{for(var _iterator7=a.properties[Symbol.iterator](),_step7;!(_iteratorNormalCompletion7=(_step7=_iterator7.next()).done);_iteratorNormalCompletion7=true){var aprop=_step7.value;var found=false;var _iteratorNormalCompletion8=true;var _didIteratorError8=false;var _iteratorError8=undefined;try{for(var _iterator8=b.properties[Symbol.iterator](),_step8;!(_iteratorNormalCompletion8=(_step8=_iterator8.next()).done);_iteratorNormalCompletion8=true){var bprop=_step8.value;if(bprop.key.name===aprop.key.name){var result=compareAnnotations(aprop.value,bprop.value);if(result===false&&!(aprop.optional&&(bprop.optional||maybeNullableAnnotation(bprop.value)===true))){return false;}else {found=result;}break;}}}catch(err){_didIteratorError8=true;_iteratorError8=err;}finally {try{if(!_iteratorNormalCompletion8&&_iterator8.return){_iterator8.return();}}finally {if(_didIteratorError8){throw _iteratorError8;}}}if(found===false&&!aprop.optional){return false;}allTrue=allTrue&&found===true;}}catch(err){_didIteratorError7=true;_iteratorError7=err;}finally {try{if(!_iteratorNormalCompletion7&&_iterator7.return){_iterator7.return();}}finally {if(_didIteratorError7){throw _iteratorError7;}}}return allTrue?true:null;}function compareArrayAnnotation(a,b){switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return compareArrayAnnotation(a,b.typeAnnotation);case 'UnionTypeAnnotation':return unionComparer(a,b,compareArrayAnnotation);case 'IntersectionTypeAnnotation':return intersectionComparer(a,b,compareArrayAnnotation);case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':return false;default:return null;}}function compareGenericAnnotation(a,b){switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return compareGenericAnnotation(a,b.typeAnnotation);case 'GenericTypeAnnotation':if(b.id.name===a.id.name){return true;}else {return null;}case 'UnionTypeAnnotation':return unionComparer(a,b,compareGenericAnnotation);case 'IntersectionTypeAnnotation':return intersectionComparer(a,b,compareGenericAnnotation);default:return null;}}function compareTupleAnnotation(a,b){if(b.type==='TupleTypeAnnotation'){if(b.types.length===0){return null;}else if(b.types.length<a.types.length){return false;}return a.types.every(function(type,index){return compareAnnotations(type,b.types[index]);});}switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return compareTupleAnnotation(a,b.typeAnnotation);case 'UnionTypeAnnotation':return unionComparer(a,b,compareTupleAnnotation);case 'IntersectionTypeAnnotation':return intersectionComparer(a,b,compareTupleAnnotation);case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':return false;default:return null;}}function compareUnionAnnotation(a,b){switch(b.type){case 'NullableTypeAnnotation':return compareUnionAnnotation(a,b.typeAnnotation);case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':return null;default:return unionComparer(a,b,compareAnnotations);}}function compareNullableAnnotation(a,b){switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':return compareNullableAnnotation(a,b.typeAnnotation);case 'NullableTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':return null;}if(compareAnnotations(a.typeAnnotation,b)===true){return true;}else {return null;}}function arrayExpressionToTupleAnnotation(path){var elements=path.get('elements');return t.tupleTypeAnnotation(elements.map(function(element){return getAnnotation(element);}));}function checkNullable(_ref9){var input=_ref9.input;var type=_ref9.type;var scope=_ref9.scope;var check=checkAnnotation(input,type,scope);if(!check){return;}return t.logicalExpression(\"||\",checks.void({input:input}),check);}function checkTypeof(_ref10){var input=_ref10.input;var annotation=_ref10.annotation;var scope=_ref10.scope;switch(annotation.type){case 'GenericTypeAnnotation':var id=annotation.id;var path=Object.assign({},input,{type:id.type,node:id,scope:scope});return checkAnnotation(input,getAnnotation(path),scope);default:return checkAnnotation(input,annotation,scope);}}function checkStringLiteral(_ref11){var input=_ref11.input;var annotation=_ref11.annotation;return checkEquals({input:input,expected:t.stringLiteral(annotation.value)});}function checkNumericLiteral(_ref12){var input=_ref12.input;var annotation=_ref12.annotation;return checkEquals({input:input,expected:t.numericLiteral(annotation.value)});}function checkBooleanLiteral(_ref13){var input=_ref13.input;var annotation=_ref13.annotation;return checkEquals({input:input,expected:t.booleanLiteral(annotation.value)});}function checkUnion(_ref14){var input=_ref14.input;var types=_ref14.types;var scope=_ref14.scope;var checks=types.map(function(type){return checkAnnotation(input,type,scope);}).filter(identity);return checks.reduce(function(last,check,index){if(last==null){return check;}return t.logicalExpression(\"||\",last,check);},null);}function checkIntersection(_ref15){var input=_ref15.input;var types=_ref15.types;var scope=_ref15.scope;var checks=types.map(function(type){return checkAnnotation(input,type,scope);}).filter(identity);return checks.reduce(function(last,check,index){if(last==null){return check;}return t.logicalExpression(\"&&\",last,check);},null);}function checkMap(_ref16){var input=_ref16.input;var types=_ref16.types;var scope=_ref16.scope;var _types=_slicedToArray(types,2);var keyType=_types[0];var valueType=_types[1];var key=t.identifier('key');var value=t.identifier('value');var keyCheck=keyType?checkAnnotation(key,keyType,scope):null;var valueCheck=valueType?checkAnnotation(value,valueType,scope):null;if(!keyCheck){if(!valueCheck){return checkIsMap({input:input});}else {return checkMapValues({input:input,value:value,valueCheck:valueCheck});}}else {if(!valueCheck){return checkMapKeys({input:input,key:key,keyCheck:keyCheck});}else {return checkMapEntries({input:input,key:key,value:value,keyCheck:keyCheck,valueCheck:valueCheck});}}}function checkSet(_ref17){var input=_ref17.input;var types=_ref17.types;var scope=_ref17.scope;var _types2=_slicedToArray(types,1);var valueType=_types2[0];var value=t.identifier('value');var valueCheck=valueType?checkAnnotation(value,valueType,scope):null;if(!valueCheck){return checkIsSet({input:input});}else {return checkSetEntries({input:input,value:value,valueCheck:valueCheck});}}function checkGenerator(_ref18){var input=_ref18.input;var types=_ref18.types;var scope=_ref18.scope;return checkIsGenerator({input:input});}function checkIterable(_ref19){var input=_ref19.input;var types=_ref19.types;var scope=_ref19.scope;return checkIsIterable({input:input});}function checkClass(_ref20){var input=_ref20.input;var types=_ref20.types;var scope=_ref20.scope;return checkIsClass({input:input});}function checkArray(_ref21){var input=_ref21.input;var types=_ref21.types;var scope=_ref21.scope;if(!types||types.length===0){return checkIsArray({input:input});}else if(types.length===1){var item=t.identifier('item');var _type4=types[0];var check=checkAnnotation(item,_type4,scope);if(!check){return checkIsArray({input:input});}return t.logicalExpression('&&',checkIsArray({input:input}),t.callExpression(t.memberExpression(input,t.identifier('every')),[t.functionExpression(null,[item],t.blockStatement([t.returnStatement(check)]))]));}else { // This is a tuple\nvar _checks=types.map(function(type,index){return checkAnnotation(t.memberExpression(input,t.numericLiteral(index),true),type,scope);}).filter(identity);var checkLength=t.binaryExpression('>=',t.memberExpression(input,t.identifier('length')),t.numericLiteral(types.length));return _checks.reduce(function(last,check,index){return t.logicalExpression(\"&&\",last,check);},t.logicalExpression('&&',checkIsArray({input:input}),checkLength));}}function checkTuple(_ref22){var input=_ref22.input;var types=_ref22.types;var scope=_ref22.scope;if(types.length===0){return checkIsArray({input:input});} // This is a tuple\nvar checks=types.map(function(type,index){return checkAnnotation(t.memberExpression(input,t.numericLiteral(index),true),type,scope);}).filter(identity);var checkLength=t.binaryExpression('>=',t.memberExpression(input,t.identifier('length')),t.numericLiteral(types.length));return checks.reduce(function(last,check,index){return t.logicalExpression(\"&&\",last,check);},t.logicalExpression('&&',checkIsArray({input:input}),checkLength));}function checkObject(_ref23){var input=_ref23.input;var properties=_ref23.properties;var indexers=_ref23.indexers;var scope=_ref23.scope;if(input.type==='ObjectPattern'){return checkObjectPattern({input:input,properties:properties,scope:scope});}var propNames=[];var check=properties.length===0?checkIsObject({input:input}):properties.reduce(function(expr,prop,index){var target=prop.key.type==='Identifier'?t.memberExpression(input,prop.key):t.memberExpression(input,prop.key,true);propNames.push(prop.key.type==='Identifier'?t.stringLiteral(prop.key.name):prop.key);var check=checkAnnotation(target,prop.value,scope);if(check){if(prop.optional){check=t.logicalExpression('||',checks.undefined({input:target}),check);}return t.logicalExpression(\"&&\",expr,check);}else {return expr;}},checkNotNull({input:input}));if(indexers.length){return indexers.reduceRight(function(expr,indexer){if(indexer.value.type==='AnyTypeAnnotation'){return expr;}var value=scope.generateUidIdentifier(indexer.id.name);var check=checkAnnotation(value,indexer.value,scope);var fixedKeys=t.arrayExpression(propNames);if(check){if(propNames.length){return t.logicalExpression('&&',expr,checkObjectIndexers({input:input,value:value,check:check,fixedKeys:fixedKeys}));}else {return t.logicalExpression('&&',expr,checkObjectIndexersNoFixed({input:input,value:value,check:check,fixedKeys:fixedKeys}));}}else {return expr;}},check);}return check;}function checkObjectPattern(_ref24){var input=_ref24.input;var properties=_ref24.properties;var scope=_ref24.scope;var propNames=properties.reduce(function(names,prop){names[prop.key.name]=prop;return names;},{});var propChecks={};var _iteratorNormalCompletion9=true;var _didIteratorError9=false;var _iteratorError9=undefined;try{for(var _iterator9=input.properties[Symbol.iterator](),_step9;!(_iteratorNormalCompletion9=(_step9=_iterator9.next()).done);_iteratorNormalCompletion9=true){var item=_step9.value;var key=item.key;var _id5=item.value;var prop=propNames[key.name];if(!prop){continue;}var check=checkAnnotation(_id5,prop.value,scope);if(check){propChecks[key.name]=check;}}}catch(err){_didIteratorError9=true;_iteratorError9=err;}finally {try{if(!_iteratorNormalCompletion9&&_iterator9.return){_iterator9.return();}}finally {if(_didIteratorError9){throw _iteratorError9;}}}return Object.keys(propChecks).reduce(function(last,name){var check=propChecks[name];if(last===null){return check;}else {return t.logicalExpression('&&',last,check);}},null);}function createTypeAliasChecks(path){var node=path.node;var scope=path.scope;var id=node.id;var annotation=node.right;var input=t.identifier('input');var check=checkAnnotation(input,annotation,scope)||t.booleanLiteral(true);var declaration=declareTypeChecker({id:id,check:check});declaration.isTypeChecker=true;declaration.savedTypeAnnotation=annotation;declaration.declarations[0].savedTypeAnnotation=annotation;return declaration;}function createInterfaceChecks(path){var node=path.node;var scope=path.scope;var id=node.id;var annotation=node.body;var input=t.identifier('input');var check=node.extends.reduce(function(check,extender){return t.logicalExpression('&&',check,checkAnnotation(input,t.genericTypeAnnotation(extender.id),path.scope));return check;},checkAnnotation(input,annotation,scope)||t.booleanLiteral(true));var declaration=declareTypeChecker({id:id,check:check});declaration.isTypeChecker=true;return declaration;}function checkAnnotation(input,annotation,scope){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':return checkAnnotation(input,annotation.typeAnnotation,scope);case 'TypeofTypeAnnotation':return checks.typeof({input:input,annotation:annotation.argument,scope:scope});case 'GenericTypeAnnotation':if(annotation.id.name==='Array'){return checks.array({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}else if(annotation.id.name==='Generator'&&!scope.hasBinding('Generator')){return checks.generator({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}else if(annotation.id.name==='Iterable'&&!scope.hasBinding('Iterable')){return checks.iterable({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}else if(annotation.id.name==='Map'&&!scope.getBinding('Map')){return checks.map({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}else if(annotation.id.name==='Set'&&!scope.getBinding('Set')){return checks.set({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}else if(annotation.id.name==='Function'){return checks.function({input:input});}else if(annotation.id.name==='Class'&&!scope.hasBinding('Class')){return checks.class({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}else if(annotation.id.name==='int8'&&!scope.hasBinding('int8')){return checks.int8({input:input});}else if(annotation.id.name==='uint8'&&!scope.hasBinding('uint8')){return checks.uint8({input:input});}else if(annotation.id.name==='int16'&&!scope.hasBinding('int16')){return checks.int16({input:input});}else if(annotation.id.name==='uint16'&&!scope.hasBinding('uint16')){return checks.uint16({input:input});}else if(annotation.id.name==='int32'&&!scope.hasBinding('int32')){return checks.int32({input:input});}else if(annotation.id.name==='uint32'&&!scope.hasBinding('uint32')){return checks.uint32({input:input});}else if(annotation.id.name==='float32'&&!scope.hasBinding('float32')){return checks.float32({input:input});}else if(annotation.id.name==='float64'&&!scope.hasBinding('float64')){return checks.float64({input:input});}else if(annotation.id.name==='double'&&!scope.hasBinding('double')){return checks.double({input:input});}else if(annotation.id.name==='Symbol'&&!scope.getBinding('Symbol')){return checks.symbol({input:input});}else if(isTypeChecker(annotation.id,scope)){return checks.type({input:input,type:annotation.id});}else if(isPolymorphicType(annotation.id,scope)){return;}else {return checks.instanceof({input:input,type:createTypeExpression(annotation.id)});}case 'TupleTypeAnnotation':return checks.tuple({input:input,types:annotation.types,scope:scope});case 'NumberTypeAnnotation':return checks.number({input:input});case 'NumericLiteralTypeAnnotation':return checks.numericLiteral({input:input,annotation:annotation});case 'BooleanTypeAnnotation':return checks.boolean({input:input});case 'BooleanLiteralTypeAnnotation':return checks.booleanLiteral({input:input,annotation:annotation});case 'StringTypeAnnotation':return checks.string({input:input});case 'StringLiteralTypeAnnotation':return checks.stringLiteral({input:input,annotation:annotation});case 'UnionTypeAnnotation':return checks.union({input:input,types:annotation.types,scope:scope});case 'IntersectionTypeAnnotation':return checks.intersection({input:input,types:annotation.types,scope:scope});case 'ObjectTypeAnnotation':return checks.object({input:input,properties:annotation.properties||[],indexers:annotation.indexers,scope:scope});case 'ArrayTypeAnnotation':return checks.array({input:input,types:[annotation.elementType||t.anyTypeAnnotation()],scope:scope});case 'FunctionTypeAnnotation':return checks.function({input:input,params:annotation.params,returnType:annotation.returnType});case 'MixedTypeAnnotation':return checks.mixed({input:input});case 'AnyTypeAnnotation':case 'ExistentialTypeParam':return checks.any({input:input});case 'NullableTypeAnnotation':return checks.nullable({input:input,type:annotation.typeAnnotation,scope:scope});case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':return checks.void({input:input});}}function staticCheckAnnotation(path,annotation){var other=getAnnotation(path);switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':return staticCheckAnnotation(path,annotation.typeAnnotation);case 'GenericTypeAnnotation':if(isTypeChecker(annotation.id,path.scope)){return staticChecks.type({path:path,type:annotation.id});}else if(isPolymorphicType(annotation.id,path.scope)){return;}else if(annotation.id.name==='Symbol'){return staticChecks.symbol(path);}else {return staticChecks.instanceof({path:path,annotation:annotation});}}return compareAnnotations(annotation,other);} /**\n   * Get the type annotation for a given node.\n   */function getAnnotation(path){var annotation=void 0;try{annotation=getAnnotationShallow(path);}catch(e){if(e instanceof SyntaxError){throw e;}if(process.env.TYPECHECK_DEBUG){console.error(e.stack);}}while(annotation&&annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}return annotation||t.anyTypeAnnotation();}function getAnnotationShallow(path){if(!path||!path.node){return t.voidTypeAnnotation();}var node=path.node;var scope=path.scope;if(node.type==='TypeAlias'){return node.right;}else if(node.type==='ClassProperty'&&node.typeAnnotation){return getClassPropertyAnnotation(path);}else if(node.type==='ClassMethod'&&node.returnType){return getClassMethodAnnotation(path);}else if(node.type==='ObjectProperty'&&node.typeAnnotation){return getObjectPropertyAnnotation(path);}else if(node.type==='SpreadProperty'&&node.typeAnnotation){return getSpreadPropertyAnnotation(path);}else if(node.type==='ObjectMethod'&&node.returnType){return getObjectMethodAnnotation(path);}else if(!node.typeAnnotation&&!node.savedTypeAnnotation&&!node.returnType){switch(path.type){case 'Identifier':var binding=scope.getBinding(node.name);if(!binding||!binding.identifier){return path.getTypeAnnotation();}var id=binding.identifier;if(binding.path.type==='ObjectPattern'){return getObjectPatternAnnotation(binding.path,node.name);}if(id.savedTypeAnnotation){return id.savedTypeAnnotation;}else if(id.returnType){return id.returnType;}else if(id.typeAnnotation){return id.typeAnnotation;}else if(isPolymorphicType(id,scope)){return t.anyTypeAnnotation();}return binding.constant?binding.path.getTypeAnnotation():path.getTypeAnnotation();case 'StringLiteral':case 'NumericLiteral':case 'BooleanLiteral':return createLiteralTypeAnnotation(path);case 'CallExpression':var callee=path.get('callee');if(callee.type==='Identifier'){if(callee.name==='Symbol'){return t.genericTypeAnnotation('Symbol');}var fn=getFunctionForIdentifier(callee);if(fn){return getAnnotation(fn);}}break;case 'ThisExpression':return getThisExpressionAnnotation(path);case 'AssignmentExpression':return getAssignmentExpressionAnnotation(path);case 'MemberExpression':return getMemberExpressionAnnotation(path);case 'ArrayExpression':return getArrayExpressionAnnotation(path);case 'ObjectExpression':return getObjectExpressionAnnotation(path);case 'BinaryExpression':return getBinaryExpressionAnnotation(path);case 'LogicalExpression':return getLogicalExpressionAnnotation(path);case 'ConditionalExpression':return getConditionalExpressionAnnotation(path);case 'ObjectMethod':return getObjectMethodAnnotation(path);case 'SpreadProperty':return getSpreadPropertyAnnotation(path);case 'ObjectProperty':return getObjectPropertyAnnotation(path);case 'ClassDeclaration':return getClassDeclarationAnnotation(path);case 'ClassMethod':return getClassMethodAnnotation(path);case 'ClassProperty':return getClassPropertyAnnotation(path);default:return path.getTypeAnnotation();}}return node.savedTypeAnnotation||node.returnType||node.typeAnnotation||path.getTypeAnnotation();}function createLiteralTypeAnnotation(path){var annotation=void 0;if(path.isStringLiteral()){annotation=t.stringLiteralTypeAnnotation();}else if(path.isNumericLiteral()){annotation=t.numericLiteralTypeAnnotation();}else if(path.isBooleanLiteral()){annotation=t.booleanLiteralTypeAnnotation();}else {return path.getTypeAnnotation();}annotation.value=path.node.value;return annotation;}function getObjectPatternAnnotation(path,name){var annotation=keyByName(getAnnotation(path),name);var found=void 0;if(!path.node.properties){return;}var _iteratorNormalCompletion10=true;var _didIteratorError10=false;var _iteratorError10=undefined;try{for(var _iterator10=path.get('properties')[Symbol.iterator](),_step10;!(_iteratorNormalCompletion10=(_step10=_iterator10.next()).done);_iteratorNormalCompletion10=true){var prop=_step10.value;if(prop.node.value&&prop.node.value.name===name){found=prop.get('key');break;}else if(prop.node.key.type==='Identifier'&&prop.node.key.name===name){found=prop.get('key');break;}}}catch(err){_didIteratorError10=true;_iteratorError10=err;}finally {try{if(!_iteratorNormalCompletion10&&_iterator10.return){_iterator10.return();}}finally {if(_didIteratorError10){throw _iteratorError10;}}}if(!annotation||!found){return;}if(found.type==='Identifier'){annotation.value.authoritative=false;return annotation.value;}}function keyByName(node,name){if(!node.properties){return;}var _iteratorNormalCompletion11=true;var _didIteratorError11=false;var _iteratorError11=undefined;try{for(var _iterator11=node.properties[Symbol.iterator](),_step11;!(_iteratorNormalCompletion11=(_step11=_iterator11.next()).done);_iteratorNormalCompletion11=true){var prop=_step11.value;if(prop.key&&prop.key.name===name){return prop;}}}catch(err){_didIteratorError11=true;_iteratorError11=err;}finally {try{if(!_iteratorNormalCompletion11&&_iterator11.return){_iterator11.return();}}finally {if(_didIteratorError11){throw _iteratorError11;}}}}function valueByName(node,name){if(!node.properties){return;}var _iteratorNormalCompletion12=true;var _didIteratorError12=false;var _iteratorError12=undefined;try{for(var _iterator12=node.properties[Symbol.iterator](),_step12;!(_iteratorNormalCompletion12=(_step12=_iterator12.next()).done);_iteratorNormalCompletion12=true){var prop=_step12.value;if(prop.value&&prop.value.name===name){return prop;}}}catch(err){_didIteratorError12=true;_iteratorError12=err;}finally {try{if(!_iteratorNormalCompletion12&&_iterator12.return){_iterator12.return();}}finally {if(_didIteratorError12){throw _iteratorError12;}}}}function getSpreadPropertyAnnotation(path){var node=path.node;var annotation=node.typeAnnotation||node.savedTypeAnnotation;if(!annotation){annotation=getAnnotation(path.get('argument'));}return annotation;}function getObjectPropertyAnnotation(path){var node=path.node;var annotation=node.typeAnnotation||node.savedTypeAnnotation;if(!annotation){if(node.value){if(node.value.typeAnnotation||node.value.savedTypeAnnotation){annotation=node.value.typeAnnotation||node.value.savedTypeAnnotation;}else if(node.value.type==='BooleanLiteral'||node.value.type==='NumericLiteral'||node.value.type==='StringLiteral'){annotation=t[node.value.type](node.value.value);}else {annotation=t.anyTypeAnnotation();}}else {annotation=t.anyTypeAnnotation();}}return t.objectTypeProperty(node.key,annotation);}function getObjectMethodAnnotation(path){var node=path.node;return t.objectTypeProperty(t.identifier(node.key.name),t.functionTypeAnnotation(null,node.params.map(function(param){return param.savedTypeAnnotation||param.typeAnnotation;}),null,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation()));}function getThisExpressionAnnotation(path){var parent=path.parentPath;loop: while(parent){switch(parent.type){case 'ClassDeclaration':return getAnnotation(parent);case 'ClassBody':return getAnnotation(parent.parentPath);case 'ClassMethod':case 'ClassProperty':return getAnnotation(parent.parentPath.parentPath);case 'ObjectProperty':return getAnnotation(parent.parentPath);case 'ObjectMethod':return getAnnotation(parent.parentPath);case 'FunctionExpression':if(parent.parentPath.type==='ObjectProperty'){return getAnnotation(parent.parentPath.parentPath);}break loop;case 'ArrowFunctionExpression':parent=parent.parentPath;continue;}if(parent.isFunction()){break;}parent=parent.parentPath;}return t.objectTypeAnnotation([]);}function getClassDeclarationAnnotation(path){var body=path.get('body').get('body').map(getAnnotation).filter(function(annotation){return annotation&&annotation.type!=='AnyTypeAnnotation';});return t.objectTypeAnnotation(body);}function getAssignmentExpressionAnnotation(path){if(path.node.operator==='='){return getAnnotation(path.get('right'));}}function getClassPropertyAnnotation(path){var node=path.node;if(node.computed){return;}var annotation=node.typeAnnotation||(node.value?node.value.savedTypeAnnotation||node.value.typeAnnotation:t.anyTypeAnnotation());return t.objectTypeProperty(node.key,annotation||t.anyTypeAnnotation());}function getClassMethodAnnotation(path){var node=path.node;if(node.computed){return;}if(node.kind==='get'){return t.objectTypeProperty(node.key,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation());}else if(node.kind==='set'){return t.objectTypeProperty(node.key,node.params.map(function(param){return param.savedTypeAnnotation||param.typeAnnotation;}).shift()||t.anyTypeAnnotation());}else {return t.objectTypeProperty(node.key,t.functionTypeAnnotation(null,node.params.map(function(param){return param.savedTypeAnnotation||param.typeAnnotation||t.anyTypeAnnotation();}),null,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation()));}}function getBinaryExpressionAnnotation(path){var node=path.node;if(isBooleanExpression(node)){return t.booleanTypeAnnotation();}else {return t.anyTypeAnnotation();}}function getLogicalExpressionAnnotation(path){var node=path.node;if(isBooleanExpression(node)){return t.booleanTypeAnnotation();}else {var left=path.get('left');var right=path.get('right');switch(node.operator){case '&&':case '||':var _ref25=[getAnnotation(left),getAnnotation(right)];left=_ref25[0];right=_ref25[1];if(t.isUnionTypeAnnotation(left)){if(t.isUnionTypeAnnotation(right)){return t.unionTypeAnnotation(left.types.concat(right.types));}else {return t.unionTypeAnnotation(left.types.concat(right));}}else {return t.unionTypeAnnotation([left,right]);}}return t.anyTypeAnnotation();}}function getConditionalExpressionAnnotation(path){var node=path.node;var consequent=getAnnotation(path.get('consequent'));var alternate=getAnnotation(path.get('alternate'));if(t.isUnionTypeAnnotation(consequent)){if(t.isUnionTypeAnnotation(alternate)){return t.unionTypeAnnotation(consequent.types.concat(alternate.types));}else {return t.unionTypeAnnotation(consequent.types.concat(alternate));}}else {return t.unionTypeAnnotation([consequent,alternate]);}}function getArrayExpressionAnnotation(path){return t.genericTypeAnnotation(t.identifier('Array'),t.typeParameterDeclaration(path.get('elements').map(getAnnotation)));}function getObjectExpressionAnnotation(path){var annotation=t.objectTypeAnnotation(path.get('properties').filter(function(prop){return !prop.node.computed;}).map(getAnnotation).reduce(function(properties,prop){if(t.isObjectTypeProperty(prop)){properties.push(prop);}else if(t.isObjectTypeAnnotation(prop)){properties.push.apply(properties,_toConsumableArray(prop.properties));}return properties;},[]).filter(function(annotation){return !t.isAnyTypeAnnotation(annotation.value);}));return annotation;}function getMemberExpressionAnnotation(path){if(path.node.computed){return getComputedMemberExpressionAnnotation(path);}var stack=[];var target=path;while(target.isMemberExpression()){stack.push(target);if(target.node.computed){break;}target=target.get('object');}var objectAnnotation=stack.reduceRight(function(last,target){var annotation=last;if(annotation==null){if(stack.length===1){annotation=getAnnotation(target.get('object'));}else {return getAnnotation(target);}}switch(annotation.type){case 'AnyTypeAnnotation':return annotation;case 'NullableTypeAnnotation':case 'TypeAnnotation':annotation=annotation.typeAnnotation;}if(annotation.type==='GenericTypeAnnotation'){var typeChecker=getTypeChecker(annotation.id,path.scope);if(typeChecker){annotation=getAnnotation(typeChecker);}else if(isPolymorphicType(annotation.id,path.scope)){annotation=t.anyTypeAnnotation();}else {var binding=path.scope.getBinding(annotation.id.name);if(binding){annotation=getAnnotation(binding.path);}}}switch(annotation.type){case 'AnyTypeAnnotation':return annotation;case 'ObjectTypeAnnotation':var id=target.get('property').node;var _iteratorNormalCompletion13=true;var _didIteratorError13=false;var _iteratorError13=undefined;try{for(var _iterator13=(annotation.properties||[])[Symbol.iterator](),_step13;!(_iteratorNormalCompletion13=(_step13=_iterator13.next()).done);_iteratorNormalCompletion13=true){var _step13$value=_step13.value;var key=_step13$value.key;var value=_step13$value.value;if(key.name===id.name){return value.type==='VoidTypeAnnotation'||value.type==='NullLiteralTypeAnnotation'?t.anyTypeAnnotation():value;}}}catch(err){_didIteratorError13=true;_iteratorError13=err;}finally {try{if(!_iteratorNormalCompletion13&&_iterator13.return){_iterator13.return();}}finally {if(_didIteratorError13){throw _iteratorError13;}}}}return t.anyTypeAnnotation();},null);return objectAnnotation||path.getTypeAnnotation();}function getComputedMemberExpressionAnnotation(path){var object=path.get('object');var property=path.get('property');var objectAnnotation=getAnnotation(object);if(objectAnnotation.type==='TypeAnnotation'||objectAnnotation.type==='NullableTypeAnnotation'){objectAnnotation=objectAnnotation.typeAnnotation;}var propertyAnnotation=getAnnotation(property);if(propertyAnnotation.type==='TypeAnnotation'||propertyAnnotation.type==='NullableTypeAnnotation'){propertyAnnotation=propertyAnnotation.typeAnnotation;}var _property$evaluate=property.evaluate();var confident=_property$evaluate.confident;var value=_property$evaluate.value;if(!confident){return path.getTypeAnnotation();}switch(objectAnnotation.type){case 'TupleTypeAnnotation':if(objectAnnotation.types.length===0){break;}else if(typeof value==='number'){if(!objectAnnotation.types[value]){throw path.buildCodeFrameError('Invalid computed member expression for tuple: '+humanReadableType(objectAnnotation));}return objectAnnotation.types[value];}else {throw path.buildCodeFrameError('Invalid computed member expression for tuple: '+humanReadableType(objectAnnotation));}break;}return path.getTypeAnnotation();}function getFunctionForIdentifier(path){if(path.type!=='Identifier'){return false;}else if(isTypeChecker(path.node,path.scope)||isPolymorphicType(path.node,path.scope)){return false;}var ref=path.scope.getBinding(path.node.name);if(!ref){return false;}return t.isFunction(ref.path.parent)&&ref.path.parentPath;} /**\n   * Determine whether the given annotation is for an array.\n   */function isStrictlyArrayAnnotation(annotation){switch(annotation.type){case 'ArrayTypeAnnotation':case 'TupleTypeAnnotation':return true;case 'TypeAnnotation':case 'FunctionTypeParam':return isStrictlyArrayAnnotation(annotation.typeAnnotation);case 'GenericTypeAnnotation':return annotation.id.name==='Array'?true:null;case 'UnionTypeAnnotation':return annotation.types.every(isStrictlyArrayAnnotation);default:return false;}}function compareMaybeUnion(annotation,comparator){var falseCount=0;var _iteratorNormalCompletion14=true;var _didIteratorError14=false;var _iteratorError14=undefined;try{for(var _iterator14=annotation.types[Symbol.iterator](),_step14;!(_iteratorNormalCompletion14=(_step14=_iterator14.next()).done);_iteratorNormalCompletion14=true){var _type5=_step14.value;var result=comparator(_type5);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError14=true;_iteratorError14=err;}finally {try{if(!_iteratorNormalCompletion14&&_iterator14.return){_iterator14.return();}}finally {if(_didIteratorError14){throw _iteratorError14;}}}if(falseCount===annotation.types.length){return false;}else {return null;}} /**\n   * Returns `true` if the annotation is compatible with a number,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeNumberAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeNumberAnnotation(annotation.typeAnnotation);case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'NumericLiteral':return true;case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':return false;default:return null;}case 'UnionTypeAnnotation':return compareMaybeUnion(annotation,maybeNumberAnnotation);case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}} /**\n   * Returns `true` if the annotation is compatible with a string,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeStringAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeStringAnnotation(annotation.typeAnnotation);case 'StringTypeAnnotation':case 'StringLiteral':return true;case 'StringLiteralTypeAnnotation':return null;case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'Number':case 'Boolean':case 'Date':case 'RegExp':return false;default:return null;}case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion15=true;var _didIteratorError15=false;var _iteratorError15=undefined;try{for(var _iterator15=annotation.types[Symbol.iterator](),_step15;!(_iteratorNormalCompletion15=(_step15=_iterator15.next()).done);_iteratorNormalCompletion15=true){var _type6=_step15.value;var result=maybeStringAnnotation(_type6);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError15=true;_iteratorError15=err;}finally {try{if(!_iteratorNormalCompletion15&&_iterator15.return){_iterator15.return();}}finally {if(_didIteratorError15){throw _iteratorError15;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}} /**\n   * Returns `true` if the annotation is compatible with a symbol,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeSymbolAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeSymbolAnnotation(annotation.typeAnnotation);case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'Number':case 'Boolean':case 'Date':case 'RegExp':return false;case 'Symbol':return true;default:return null;}case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion16=true;var _didIteratorError16=false;var _iteratorError16=undefined;try{for(var _iterator16=annotation.types[Symbol.iterator](),_step16;!(_iteratorNormalCompletion16=(_step16=_iterator16.next()).done);_iteratorNormalCompletion16=true){var _type7=_step16.value;var result=maybeSymbolAnnotation(_type7);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError16=true;_iteratorError16=err;}finally {try{if(!_iteratorNormalCompletion16&&_iterator16.return){_iterator16.return();}}finally {if(_didIteratorError16){throw _iteratorError16;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}} /**\n   * Returns `true` if the annotation is compatible with a boolean,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeBooleanAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeBooleanAnnotation(annotation.typeAnnotation);case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'BooleanLiteral':return true;case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'String':case 'Number':case 'Date':case 'RegExp':return false;default:return null;}case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion17=true;var _didIteratorError17=false;var _iteratorError17=undefined;try{for(var _iterator17=annotation.types[Symbol.iterator](),_step17;!(_iteratorNormalCompletion17=(_step17=_iterator17.next()).done);_iteratorNormalCompletion17=true){var _type8=_step17.value;var result=maybeBooleanAnnotation(_type8);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError17=true;_iteratorError17=err;}finally {try{if(!_iteratorNormalCompletion17&&_iterator17.return){_iterator17.return();}}finally {if(_didIteratorError17){throw _iteratorError17;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}} /**\n   * Returns `true` if the annotation is compatible with a function,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeFunctionAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeFunctionAnnotation(annotation.typeAnnotation);case 'FunctionTypeAnnotation':return true;case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Number':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':return false;default:return null;}case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion18=true;var _didIteratorError18=false;var _iteratorError18=undefined;try{for(var _iterator18=annotation.types[Symbol.iterator](),_step18;!(_iteratorNormalCompletion18=(_step18=_iterator18.next()).done);_iteratorNormalCompletion18=true){var _type9=_step18.value;var result=maybeFunctionAnnotation(_type9);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError18=true;_iteratorError18=err;}finally {try{if(!_iteratorNormalCompletion18&&_iterator18.return){_iterator18.return();}}finally {if(_didIteratorError18){throw _iteratorError18;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}} /**\n   * Returns `true` if the annotation is compatible with an undefined or null type,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeNullableAnnotation(annotation){switch(annotation.type){case 'NullableTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'MixedTypeAnnotation':return true;case 'TypeAnnotation':case 'FunctionTypeParam':return maybeNullableAnnotation(annotation.typeAnnotation);case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Number':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':return false;case 'Generator':if(annotation.typeParameters&&annotation.typeParameters.params.length>1){return maybeNullableAnnotation(annotation.typeParameters.params[1]);}else {return null;}default:return null;}case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion19=true;var _didIteratorError19=false;var _iteratorError19=undefined;try{for(var _iterator19=annotation.types[Symbol.iterator](),_step19;!(_iteratorNormalCompletion19=(_step19=_iterator19.next()).done);_iteratorNormalCompletion19=true){var _type10=_step19.value;var result=maybeNullableAnnotation(_type10);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError19=true;_iteratorError19=err;}finally {try{if(!_iteratorNormalCompletion19&&_iterator19.return){_iterator19.return();}}finally {if(_didIteratorError19){throw _iteratorError19;}}}if(falseCount===annotation.types.length){return false;}else {return null;}default:return false;}} /**\n   * Returns `true` if the annotation is compatible with an object type,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeInstanceOfAnnotation(annotation,expected,typeParameters){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeInstanceOfAnnotation(annotation.typeAnnotation,expected,typeParameters);case 'GenericTypeAnnotation':if(annotation.id.name===expected.name){if(typeParameters.length===0){return true;}if(annotation.typeParameters&&annotation.typeParameters.params.length){var trueCount=0;var nullCount=0;for(var i=0;i<typeParameters.length&&i<annotation.typeParameters.params.length;i++){var result=compareAnnotations(typeParameters[i],annotation.typeParameters.params[i]);if(result===false){return false;}else if(result===true){trueCount++;}else {nullCount++;}}return trueCount>0&&nullCount===0?true:null;}}return null;case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion20=true;var _didIteratorError20=false;var _iteratorError20=undefined;try{for(var _iterator20=annotation.types[Symbol.iterator](),_step20;!(_iteratorNormalCompletion20=(_step20=_iterator20.next()).done);_iteratorNormalCompletion20=true){var _type11=_step20.value;var _result=maybeInstanceOfAnnotation(_type11,expected,typeParameters);if(_result===true){return true;}else if(_result===false){falseCount++;}}}catch(err){_didIteratorError20=true;_iteratorError20=err;}finally {try{if(!_iteratorNormalCompletion20&&_iterator20.return){_iterator20.return();}}finally {if(_didIteratorError20){throw _iteratorError20;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':if(expected.name==='Array'||expected.name==='RegExp'||expected.name==='Error'||expected.name==='Function'||expected.name==='String'||expected.name==='Object'){return false;}else {return null;}case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':if(expected.name==='Array'||expected.name==='RegExp'||expected.name==='Error'||expected.name==='Function'){return false;}else {return null;}case 'FunctionTypeAnnotation':if(expected.name==='Function'){return true;}else {return null;}default:return null;}} /**\n   * Returns `true` if the annotation is compatible with an array,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeArrayAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeArrayAnnotation(annotation.typeAnnotation);case 'TupleTypeAnnotation':case 'ArrayTypeAnnotation':return true;case 'GenericTypeAnnotation':return annotation.id.name==='Array'?true:null;case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion21=true;var _didIteratorError21=false;var _iteratorError21=undefined;try{for(var _iterator21=annotation.types[Symbol.iterator](),_step21;!(_iteratorNormalCompletion21=(_step21=_iterator21.next()).done);_iteratorNormalCompletion21=true){var _type12=_step21.value;var result=maybeArrayAnnotation(_type12);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError21=true;_iteratorError21=err;}finally {try{if(!_iteratorNormalCompletion21&&_iterator21.return){_iterator21.return();}}finally {if(_didIteratorError21){throw _iteratorError21;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}} /**\n   * Returns `true` if the annotation is compatible with an iterable,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeIterableAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeIterableAnnotation(annotation.typeAnnotation);case 'TupleTypeAnnotation':case 'ArrayTypeAnnotation':return true;case 'GenericTypeAnnotation':return annotation.id.name==='Iterable'?true:null;case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion22=true;var _didIteratorError22=false;var _iteratorError22=undefined;try{for(var _iterator22=annotation.types[Symbol.iterator](),_step22;!(_iteratorNormalCompletion22=(_step22=_iterator22.next()).done);_iteratorNormalCompletion22=true){var _type13=_step22.value;var result=maybeIterableAnnotation(_type13);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError22=true;_iteratorError22=err;}finally {try{if(!_iteratorNormalCompletion22&&_iterator22.return){_iterator22.return();}}finally {if(_didIteratorError22){throw _iteratorError22;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':return false;default:return null;}} /**\n   * Returns `true` if the annotation is compatible with a tuple,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeTupleAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeTupleAnnotation(annotation.typeAnnotation);case 'TupleTypeAnnotation':return true;case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion23=true;var _didIteratorError23=false;var _iteratorError23=undefined;try{for(var _iterator23=annotation.types[Symbol.iterator](),_step23;!(_iteratorNormalCompletion23=(_step23=_iterator23.next()).done);_iteratorNormalCompletion23=true){var _type14=_step23.value;var result=maybeTupleAnnotation(_type14);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError23=true;_iteratorError23=err;}finally {try{if(!_iteratorNormalCompletion23&&_iterator23.return){_iterator23.return();}}finally {if(_didIteratorError23){throw _iteratorError23;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'GenericTypeAnnotation':case 'AnyTypeAnnotation':case 'ArrayTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}}function humanReadableType(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':return humanReadableType(annotation.typeAnnotation);case 'FunctionTypeAnnotation': // @fixme babel doesn't seem to like generating FunctionTypeAnnotations yet\nreturn '('+annotation.params.map(humanReadableType).join(', ')+') => '+humanReadableType(annotation.returnType);case 'GenericTypeAnnotation':var path=getNodePath(annotation);var checker=path&&getTypeChecker(annotation.id,path.scope);if(checker&&checker.node.savedTypeAnnotation){return humanReadableType(checker.node.savedTypeAnnotation);}else {return (0,_babelGenerator2.default)(annotation).code;}default:return (0,_babelGenerator2.default)(annotation).code;}} /**\n   * Get the path directly from a node.\n   */function getNodePath(node){if(node._paths&&node._paths.length){return node._paths[0];}else {return null;}}function getTypeChecker(id,scope){var checker=scope.getData('typechecker:'+id.name);if(checker){return checker;}return false;}function isTypeChecker(id,scope){return scope.getData('typechecker:'+id.name)!==undefined;}function isPolymorphicType(id,scope){return scope.getData('typeparam:'+id.name)!==undefined;}function getPolymorphicType(id,scope){var path=scope.getData('typeparam:'+id.name);if(path){return path.node;}}function collectParamChecks(path,context){return path.get('params').map(function(param){var node=param.node;if(node.type==='AssignmentPattern'){if(node.left.typeAnnotation){return createDefaultParamGuard(param,context);}}else if(node.type==='RestElement'){if(node.typeAnnotation){return createRestParamGuard(param,context);}}else if(node.typeAnnotation){return createParamGuard(param,context);}}).filter(identity);}function createParamGuard(path,context){var node=path.node;var scope=path.scope;node.hasBeenTypeChecked=true;node.savedTypeAnnotation=node.typeAnnotation;var checkable=void 0;if(node.type==='ObjectPattern'){node.name=path.key;checkable=t.memberExpression(t.identifier('arguments'),t.numericLiteral(path.key),true);}else {checkable=node;}var check=checkAnnotation(checkable,node.typeAnnotation,scope);if(!check){return;}if(node.optional){check=t.logicalExpression('||',checks.undefined({input:checkable}),check);}var message=paramTypeErrorMessage(checkable,context,node.typeAnnotation);return guard({check:check,message:message});}function createDefaultParamGuard(path,context){var node=path.node;var scope=path.scope;var id=node.left;var value=node.right;var ok=staticCheckAnnotation(path.get('right'),id.typeAnnotation);if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid default value for argument \"'+id.name+'\".',id.typeAnnotation,getAnnotation(path.get('right'))));}return createParamGuard(path.get('left'),context);}function createRestParamGuard(path,context){var node=path.node;var scope=path.scope;var id=node.argument;id.hasBeenTypeChecked=true;node.savedTypeAnnotation=node.typeAnnotation;if(isStrictlyArrayAnnotation(node.typeAnnotation)===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid type annotation for rest argument \"'+id.name+'\".',t.genericTypeAnnotation(t.identifier('Array')),node.typeAnnotation));}var check=checkAnnotation(id,node.typeAnnotation,scope);if(!check){return;}if(node.optional){check=t.logicalExpression('||',checks.undefined({input:id}),check);}var message=paramTypeErrorMessage(id,context,node.typeAnnotation);return guard({check:check,message:message});}function returnTypeErrorMessage(path,fn,id,context){var node=path.node;var scope=path.scope;var name=fn.id?fn.id.name:'';var annotation=fn.returnType;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(fn.generator&&isGeneratorAnnotation(annotation)&&annotation.typeParameters&&annotation.typeParameters.params.length>1){annotation=annotation.typeParameters.params[1];}var message='Function '+(name?'\"'+name+'\" ':'')+'return value violates contract.\\n\\nExpected:\\n'+humanReadableType(annotation)+'\\n\\nGot:\\n';return t.binaryExpression('+',t.stringLiteral(message),id?readableName({inspect:context.inspect,input:id}):node.argument?readableName({inspect:context.inspect,input:node.argument}):t.stringLiteral('undefined'));}function yieldTypeErrorMessage(fn,annotation,id,context){var name=fn.id?fn.id.name:'';var message='Function '+(name?'\"'+name+'\" ':'')+'yielded an invalid value.\\n\\nExpected:\\n'+humanReadableType(annotation)+'\\n\\nGot:\\n';return t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:id}));}function yieldNextTypeErrorMessage(fn,annotation,id,context){var name=fn.id?fn.id.name:'';var message='Generator '+(name?'\"'+name+'\" ':'')+'received an invalid next value.\\n\\nExpected:\\n'+humanReadableType(annotation)+'\\n\\nGot:\\n';return t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:id}));}function paramTypeErrorMessage(node,context){var typeAnnotation=arguments.length<=2||arguments[2]===undefined?node.typeAnnotation:arguments[2];var name=node.name;if(node.type==='MemberExpression'&&node.object.name==='arguments'){name=node.property.value;}var message='Value of '+(node.optional?'optional ':'')+'argument '+JSON.stringify(name)+' violates contract.\\n\\nExpected:\\n'+humanReadableType(typeAnnotation)+'\\n\\nGot:\\n';return t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:node}));}function varTypeErrorMessage(node,context){var annotation=node.typeAnnotation;if(node.type==='Identifier'){var _name3=node.name;var message='Value of variable \"'+_name3+'\" violates contract.\\n\\nExpected:\\n'+humanReadableType(annotation)+'\\n\\nGot:\\n';return t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:node}));}else {var _message='Value of \"'+humanReadableType(node)+'\" violates contract.\\n\\nExpected:\\n'+humanReadableType(annotation)+'\\n\\nGot:\\n';return t.binaryExpression('+',t.stringLiteral(_message),readableName({inspect:context.inspect,input:node}));}} /**\n   * Create a React property validator\n   */function generatePropType(annotation,scope,context){var prop=t.identifier('prop');var check=checkAnnotation(prop,annotation,scope);if(check){return propType({check:check,prop:prop,expected:t.stringLiteral(humanReadableType(annotation)),got:readableName({inspect:context.inspect,input:prop})});}else {return t.functionExpression(null,[],t.blockStatement([]));}} /**\n   * Determine whether the given node can produce purely boolean results.\n   */function isBooleanExpression(node){if(node.type==='BinaryExpression'&&BOOLEAN_BINARY_OPERATORS.indexOf(node.operator)>-1){return true;}else if(node.type==='LogicalExpression'){return isBooleanExpression(node.left)&&isBooleanExpression(node.right);}else {return false;}} /**\n   * Convert type specifier to expression.\n   */function createTypeExpression(node){if(node.type=='Identifier'){return node;}else if(node.type=='QualifiedTypeIdentifier'){return t.memberExpression(createTypeExpression(node.qualification),createTypeExpression(node.id));}throw this.errorWithNode('Unsupported type: '+node.type);} /**\n   * Get name of a type as a string.\n   */function getTypeName(node){if(node.type=='Identifier'){return node.name;}else if(node.type=='QualifiedTypeIdentifier'){return getTypeName(node.qualification)+'.'+getTypeName(node.id);}throw this.errorWithNode('Unsupported type: '+node.type);} /**\n   * Union two arrays.\n   */function union(arr1,arr2){for(var i=0;i<arr2.length;i++){var item=arr2[i];if(arr1.indexOf(item)===-1){arr1.push(item);}}return arr1;} /**\n   * Determine whether the given annotation allows any value.\n   */function allowsAny(annotation){if(annotation.type==='TypeAnnotation'||annotation.type==='NullableTypeAnnotation'){return allowsAny(annotation.typeAnnotation);}else if(annotation.type==='AnyTypeAnnotation'||annotation.type==='MixedTypeAnnotation'){return true;}else if(annotation.type==='UnionTypeAnnotation'){return annotation.types.some(allowsAny);}else {return false;}} /**\n   * Determine whether a given node is nully (null or undefined).\n   */function isNodeNully(node){if(node==null){return true;}else if(node.type==='Identifier'&&node.name==='undefined'){return true;}else if(node.type==='Literal'&&node.value===null){return true;}else if(node.type==='UnaryExpression'&&node.operator==='void'){return true;}else {return false;}} /**\n   * Determine whether the file should be checked\n   */function mustCheckFile(path,opts){if(path.node.leadingComments&&path.node.leadingComments.length){return opts.only&&!skipEnvironment(path.node.leadingComments,opts);}return false;} /**\n   * Determine whether the file should be skipped, based on the comments attached to the given node.\n   */function maybeSkipFile(path,opts){if(path.node.leadingComments&&path.node.leadingComments.length){if(skipEnvironment(path.node.leadingComments,opts)){return true;}return path.node.leadingComments.some(function(comment){return PRAGMA_IGNORE_FILE.test(comment.value);});}return false;} /**\n   * Maybe skip the given path if it has a relevant pragma.\n   */function maybeSkip(path){var node=path.node;if(node.hasBeenTypeChecked){return true;}if(node.leadingComments&&node.leadingComments.length){var comment=node.leadingComments[node.leadingComments.length-1];if(PRAGMA_IGNORE_STATEMENT.test(comment.value)){path.skip();return true;}}return false;} /**\n   * A function that returns its first argument, useful when filtering.\n   */function identity(input){return input;}function getExpression(node){return t.isExpressionStatement(node)?node.expression:node;}function expression(input){var fn=template(input);return function(){var node=fn.apply(undefined,arguments);return getExpression(node);};}};var _babelGenerator=require('babel-generator');var _babelGenerator2=_interopRequireDefault(_babelGenerator);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else {return Array.from(arr);}}","/home/travis/build/npmtest/node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib-checked/index.js":"'use strict';Object.defineProperty(exports,\"__esModule\",{value:true});var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally {try{if(!_n&&_i[\"return\"])_i[\"return\"]();}finally {if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else {throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");}};}();var _typeof=typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol?\"symbol\":typeof obj;};exports.default=function(_ref102){var t=_ref102.types;var template=_ref102.template; /**\n   * Binary Operators that can only produce boolean results.\n   */var BOOLEAN_BINARY_OPERATORS=['==','===','>=','<=','>','<','instanceof'];if(!(Array.isArray(BOOLEAN_BINARY_OPERATORS)&&BOOLEAN_BINARY_OPERATORS.every(function(item){return typeof item==='string';}))){throw new TypeError('Value of variable \"BOOLEAN_BINARY_OPERATORS\" violates contract.\\n\\nExpected:\\nstring[]\\n\\nGot:\\n'+_inspect(BOOLEAN_BINARY_OPERATORS));}var checks=createChecks();var staticChecks=createStaticChecks();var checkIsArray=expression('Array.isArray(input)');if(!(typeof checkIsArray==='function')){throw new TypeError('Value of variable \"checkIsArray\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(checkIsArray));}var checkIsMap=expression('input instanceof Map');if(!(typeof checkIsMap==='function')){throw new TypeError('Value of variable \"checkIsMap\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(checkIsMap));}var checkIsSet=expression('input instanceof Set');if(!(typeof checkIsSet==='function')){throw new TypeError('Value of variable \"checkIsSet\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(checkIsSet));}var checkIsClass=expression('typeof input === \\'function\\' && input.prototype && input.prototype.constructor === input');if(!(typeof checkIsClass==='function')){throw new TypeError('Value of variable \"checkIsClass\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(checkIsClass));}var checkIsGenerator=expression('typeof input === \\'function\\' && input.generator');if(!(typeof checkIsGenerator==='function')){throw new TypeError('Value of variable \"checkIsGenerator\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(checkIsGenerator));}var checkIsIterable=expression('input && (typeof input[Symbol.iterator] === \\'function\\' || Array.isArray(input))');if(!(typeof checkIsIterable==='function')){throw new TypeError('Value of variable \"checkIsIterable\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(checkIsIterable));}var checkIsObject=expression('input != null && typeof input === \\'object\\'');if(!(typeof checkIsObject==='function')){throw new TypeError('Value of variable \"checkIsObject\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(checkIsObject));}var checkNotNull=expression('input != null');if(!(typeof checkNotNull==='function')){throw new TypeError('Value of variable \"checkNotNull\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(checkNotNull));}var checkEquals=expression('input === expected');if(!(typeof checkEquals==='function')){throw new TypeError('Value of variable \"checkEquals\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(checkEquals));}var declareTypeChecker=template('\\n    const id = (function () {\\n      function id (input) {\\n        return check;\\n      };\\n      Object.defineProperty(id, Symbol.hasInstance, {\\n        value: function (input) {\\n          return id(input);\\n        }\\n      });\\n      return id;\\n    })();\\n  ');if(!(typeof declareTypeChecker==='function')){throw new TypeError('Value of variable \"declareTypeChecker\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(declareTypeChecker));}var guard=template('\\n    if (!check) {\\n      throw new TypeError(message);\\n    }\\n  ');if(!(typeof guard==='function')){throw new TypeError('Value of variable \"guard\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(guard));}var thrower=template('\\n    if (check) {\\n      ret;\\n    }\\n    else {\\n      throw new TypeError(message);\\n    }\\n  ');if(!(typeof thrower==='function')){throw new TypeError('Value of variable \"thrower\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(thrower));}var guardInline=expression('\\n    (id => {\\n      if (!check) {\\n        throw new TypeError(message);\\n      }\\n      return id;\\n    })(input)\\n  ');if(!(typeof guardInline==='function')){throw new TypeError('Value of variable \"guardInline\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(guardInline));}var guardFn=expression('\\n    function name (id) {\\n      if (!check) {\\n        throw new TypeError(message);\\n      }\\n      return id;\\n    }\\n  ');if(!(typeof guardFn==='function')){throw new TypeError('Value of variable \"guardFn\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(guardFn));}var readableName=expression('\\n    inspect(input)\\n  ');if(!(typeof readableName==='function')){throw new TypeError('Value of variable \"readableName\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(readableName));}var checkMapKeys=expression('\\n    input instanceof Map && Array.from(input.keys()).every(key => keyCheck)\\n  ');if(!(typeof checkMapKeys==='function')){throw new TypeError('Value of variable \"checkMapKeys\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(checkMapKeys));}var checkMapValues=expression('\\n    input instanceof Map && Array.from(input.values()).every(value => valueCheck)\\n  ');if(!(typeof checkMapValues==='function')){throw new TypeError('Value of variable \"checkMapValues\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(checkMapValues));}var checkMapEntries=expression('\\n    input instanceof Map && Array.from(input).every(([key, value]) => keyCheck && valueCheck)\\n  ');if(!(typeof checkMapEntries==='function')){throw new TypeError('Value of variable \"checkMapEntries\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(checkMapEntries));}var checkSetEntries=expression('\\n    input instanceof Set && Array.from(input).every(value => valueCheck)\\n  ');if(!(typeof checkSetEntries==='function')){throw new TypeError('Value of variable \"checkSetEntries\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(checkSetEntries));}var checkObjectIndexers=expression('\\n    Object.keys(input).every(key => {\\n      const value = input[key];\\n      if (~fixedKeys.indexOf(key)) {\\n        return true;\\n      }\\n      else {\\n        return check;\\n      }\\n    });\\n  ');if(!(typeof checkObjectIndexers==='function')){throw new TypeError('Value of variable \"checkObjectIndexers\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(checkObjectIndexers));}var checkObjectIndexersNoFixed=expression('\\n    Object.keys(input).every(key => {\\n      const value = input[key];\\n      return check;\\n    });\\n  ');if(!(typeof checkObjectIndexersNoFixed==='function')){throw new TypeError('Value of variable \"checkObjectIndexersNoFixed\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(checkObjectIndexersNoFixed));}var propType=expression('\\n    (function(props, name, component) {\\n      var prop = props[name];\\n      if(!check) {\\n        return new Error(\\n          \"Invalid prop `\" + name + \"` supplied to `\" + component\\n          + \"`.\\\\n\\\\nExpected:\\\\n\" + expected + \"\\\\n\\\\nGot:\\\\n\" + got + \"\\\\n\\\\n\"\\n        );\\n      }\\n    })\\n  ');if(!(typeof propType==='function')){throw new TypeError('Value of variable \"propType\" violates contract.\\n\\nExpected:\\n() => Node\\n\\nGot:\\n'+_inspect(propType));}var PRAGMA_IGNORE_STATEMENT=/typecheck:\\s*ignore\\s+statement/i;var PRAGMA_IGNORE_FILE=/typecheck:\\s*ignore\\s+file/i;function skipEnvironment(comments,opts){if(!opts.only){return false;}var envs=pragmaEnvironments(comments);return !opts.only.some(function(env){return envs[env];});}function pragmaEnvironments(comments){var pragma=/@typecheck:\\s*(.+)/;var environments={};comments.forEach(function(comment){var m=comment.value.match(pragma);if(m){m[1].split(',').forEach(function(env){return environments[env.trim()]=true;});}});return environments;}var visitors={Statement:function Statement(path){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}maybeSkip(path);},TypeAlias:function TypeAlias(path){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(maybeSkip(path)){return;}path.replaceWith(createTypeAliasChecks(path));},InterfaceDeclaration:function InterfaceDeclaration(path){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(maybeSkip(path)){return;}path.replaceWith(createInterfaceChecks(path));},ExportNamedDeclaration:function ExportNamedDeclaration(path){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;if(node.declaration&&node.declaration.type==='TypeAlias'){var declaration=path.get('declaration');declaration.replaceWith(createTypeAliasChecks(declaration));node.exportKind='value';}},ImportDeclaration:function ImportDeclaration(path){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(maybeSkip(path)){return;}if(path.node.importKind!=='type'){return;}var _path$get$map$reduce=path.get('specifiers').map(function(specifier){var local=specifier.get('local');var tmpId=path.scope.generateUidIdentifierBasedOnNode(local.node);var replacement=t.importSpecifier(tmpId,specifier.node.imported);var id=t.identifier(local.node.name);id.isTypeChecker=true;var declarator=t.variableDeclarator(id,tmpId);declarator.isTypeChecker=true;return [declarator,replacement];}).reduce(function(_ref103,_ref104){var _ref106=_slicedToArray(_ref103,2);var declarators=_ref106[0];var specifiers=_ref106[1];var _ref105=_slicedToArray(_ref104,2);var declarator=_ref105[0];var specifier=_ref105[1];declarators.push(declarator);specifiers.push(specifier);return [declarators,specifiers];},[[],[]]);var _path$get$map$reduce2=_slicedToArray(_path$get$map$reduce,2);var declarators=_path$get$map$reduce2[0];var specifiers=_path$get$map$reduce2[1];var declaration=t.variableDeclaration('var',declarators);declaration.isTypeChecker=true;path.replaceWithMultiple([t.importDeclaration(specifiers,path.node.source),declaration]);},ArrowFunctionExpression:function ArrowFunctionExpression(path){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));} // Look for destructuring args with annotations.\nvar params=path.get('params');if(!(Array.isArray(params)&&params.every(function(item){return NodePath(item);}))){throw new TypeError('Value of variable \"params\" violates contract.\\n\\nExpected:\\nNodePath[]\\n\\nGot:\\n'+_inspect(params));}if(!(params&&(typeof params[Symbol.iterator]==='function'||Array.isArray(params)))){throw new TypeError('Expected params to be iterable, got '+_inspect(params));}var _iteratorNormalCompletion=true;var _didIteratorError=false;var _iteratorError=undefined;try{for(var _iterator=params[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){var param=_step.value;if(param.isObjectPattern()&&param.node.typeAnnotation){var _path$get5=path.get('body');var _scope=_path$get5.scope;var _id117=_scope.generateUidIdentifier('arg'+param.key);var pattern=param.node;param.replaceWith(_id117);if(path.node.expression){var block=t.blockStatement([t.variableDeclaration('var',[t.variableDeclarator(pattern,_id117)]),t.returnStatement(path.get('body').node)]);path.node.body=block;path.node.expression=false;}else {path.get('body.body')[0].insertBefore(t.variableDeclaration('var',[t.variableDeclarator(pattern,_id117)]));}}}}catch(err){_didIteratorError=true;_iteratorError=err;}finally {try{if(!_iteratorNormalCompletion&&_iterator.return){_iterator.return();}}finally {if(_didIteratorError){throw _iteratorError;}}}},Function:{enter:function enter(path,context){var _node$body$body;if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument \"context\" violates contract.\\n\\nExpected:\\nVisitorContext\\n\\nGot:\\n'+_inspect(context));}if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;var paramChecks=collectParamChecks(path,context);if(node.type===\"ArrowFunctionExpression\"&&node.expression){node.expression=false;node.body=t.blockStatement([t.returnStatement(node.body)]);}if(node.returnType){createFunctionReturnGuard(path,context);createFunctionYieldGuards(path,context);}(_node$body$body=node.body.body).unshift.apply(_node$body$body,_toConsumableArray(paramChecks));node.savedTypeAnnotation=node.returnType;node.returnCount=0;node.yieldCount=0;},exit:function exit(path){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var node=path.node;var scope=path.scope;var isVoid=node.savedTypeAnnotation?maybeNullableAnnotation(node.savedTypeAnnotation):null;if(!node.returnCount&&isVoid===false){var annotation=node.savedTypeAnnotation;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(node.generator&&isGeneratorAnnotation(annotation)&&annotation.typeParameters&&annotation.typeParameters.params.length>1){annotation=annotation.typeParameters.params[1];}throw path.buildCodeFrameError(buildErrorMessage('Function '+(node.id?'\"'+node.id.name+'\" ':'')+'did not return a value.',annotation));}if(node.nextGuardCount){path.get('body').get('body')[0].insertBefore(node.nextGuard);}if(node.yieldGuardCount){path.get('body').get('body')[0].insertBefore(node.yieldGuard);}if(node.returnGuardCount){path.get('body').get('body')[0].insertBefore(node.returnGuard);}}},YieldExpression:function YieldExpression(path,context){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument \"context\" violates contract.\\n\\nExpected:\\nVisitorContext\\n\\nGot:\\n'+_inspect(context));}var fn=path.getFunctionParent();if(!fn){return;}fn.node.yieldCount++;if(!isGeneratorAnnotation(fn.node.returnType)||maybeSkip(path)){return;}var node=path.node;var parent=path.parent;var scope=path.scope;var annotation=fn.node.returnType;if(annotation.type==='NullableTypeAnnotation'||annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(!annotation.typeParameters||annotation.typeParameters.params.length===0){return;}var yieldType=annotation.typeParameters.params[0];var nextType=annotation.typeParameters.params[2];var ok=staticCheckAnnotation(path.get(\"argument\"),yieldType);if(ok===true&&!nextType){return;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'\"'+fn.node.id.name+'\" ':'')+'yielded an invalid type.',yieldType,getAnnotation(path.get('argument'))));}fn.node.yieldGuardCount++;if(fn.node.yieldGuard){var _yielder=t.yieldExpression(t.callExpression(fn.node.yieldGuardName,[node.argument||t.identifier('undefined')]));_yielder.hasBeenTypeChecked=true;if(fn.node.nextGuard){fn.node.nextGuardCount++;path.replaceWith(t.callExpression(fn.node.nextGuardName,[_yielder]));}else {path.replaceWith(_yielder);}}else if(fn.node.nextGuard){fn.node.nextGuardCount++;path.replaceWith(t.callExpression(fn.node.nextGuardName,[yielder]));}},ReturnStatement:function ReturnStatement(path,context){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument \"context\" violates contract.\\n\\nExpected:\\nVisitorContext\\n\\nGot:\\n'+_inspect(context));}var fn=path.getFunctionParent();if(!fn){return;}fn.node.returnCount++;if(maybeSkip(path)){return;}var node=path.node;var parent=path.parent;var scope=path.scope;var _fn$node=fn.node;var returnType=_fn$node.returnType;var returnGuardName=_fn$node.returnGuardName;if(!returnType||!returnGuardName){return;}if(!node.argument){if(maybeNullableAnnotation(returnType)===false){throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'\"'+fn.node.id.name+'\" ':'')+'did not return a value.',returnType));}return;}var annotation=returnType;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(isGeneratorAnnotation(annotation)){annotation=annotation.typeParameters&&annotation.typeParameters.params.length>1?annotation.typeParameters.params[1]:t.anyTypeAnnotation();}else if(node.async&&annotation.type==='GenericTypeAnnotation'&&annotation.id.name==='Promise'){annotation=annotation.typeParameters&&annotation.typeParameters[0]||t.anyTypeAnnotation();}var ok=staticCheckAnnotation(path.get(\"argument\"),annotation);if(ok===true){return;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'\"'+fn.node.id.name+'\" ':'')+'returned an invalid type.',annotation,getAnnotation(path.get('argument'))));}fn.node.returnGuardCount++;var returner=t.returnStatement(t.callExpression(fn.node.returnGuardName,[node.argument]));returner.hasBeenTypeChecked=true;path.replaceWith(returner);},VariableDeclaration:function VariableDeclaration(path,context){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument \"context\" violates contract.\\n\\nExpected:\\nVisitorContext\\n\\nGot:\\n'+_inspect(context));}if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;var collected=[];var declarations=path.get(\"declarations\");for(var i=0;i<node.declarations.length;i++){var declaration=node.declarations[i];var _id118=declaration.id;var init=declaration.init;if(!_id118.typeAnnotation||_id118.hasBeenTypeChecked){continue;}_id118.savedTypeAnnotation=_id118.typeAnnotation;_id118.hasBeenTypeChecked=true;var ok=staticCheckAnnotation(declarations[i],_id118.typeAnnotation);if(ok===true){continue;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid assignment value for \"'+_id118.name+'\".',_id118.typeAnnotation,getAnnotation(declarations[i])));}var check=checkAnnotation(_id118,_id118.typeAnnotation,scope);if(check){collected.push(guard({check:check,message:varTypeErrorMessage(_id118,context)}));}}if(collected.length>0){var _check=collected.reduce(function(check,branch){branch.alternate=check;return branch;});if(path.parent.type==='Program'||path.parent.type==='BlockStatement'){path.insertAfter(_check);}else if(path.parentPath.isForXStatement()||path.parentPath.isForStatement()||path.parentPath.isForInStatement()){var body=path.parentPath.get('body');if(body.type!=='BlockStatement'){var block=t.blockStatement([body.node]);body.replaceWith(block);body=path.parentPath.get('body');}var children=body.get('body');if(children.length===0){body.replaceWith(_check);}else {children[0].insertBefore(_check);}}else if(path.parent.type==='ExportNamedDeclaration'||path.parent.type==='ExportDefaultDeclaration'||path.parent.type==='ExportAllDeclaration'){path.parentPath.insertAfter(_check);}else {path.replaceWith(t.blockStatement([node,_check]));}}},AssignmentExpression:function AssignmentExpression(path,context){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument \"context\" violates contract.\\n\\nExpected:\\nVisitorContext\\n\\nGot:\\n'+_inspect(context));}if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;var left=path.get('left');var annotation=void 0;if(node.hasBeenTypeChecked||node.left.hasBeenTypeChecked){return;}else if(left.isMemberExpression()){annotation=getAnnotation(left);}else if(t.isIdentifier(node.left)){var binding=scope.getBinding(node.left.name);if(!binding){return;}else if(binding.path.type!=='VariableDeclarator'){return;}annotation=left.getTypeAnnotation();if(annotation.type==='AnyTypeAnnotation'){var item=binding.path.get('id');annotation=item.node.savedTypeAnnotation||item.getTypeAnnotation();}}else {return;}node.hasBeenTypeChecked=true;node.left.hasBeenTypeChecked=true;var id=node.left;var right=path.get('right');if(annotation.type==='AnyTypeAnnotation'){return;}var ok=staticCheckAnnotation(right,annotation);if(ok===true){return;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid assignment value for \"'+humanReadableType(id)+'\".',annotation,getAnnotation(right)));}var check=checkAnnotation(id,annotation,scope);if(!id.typeAnnotation){id.typeAnnotation=annotation;}id.hasBeenTypeChecked=true;if(check){var parent=path.getStatementParent();parent.insertAfter(guard({check:check,message:varTypeErrorMessage(id,context)}));}},TypeCastExpression:function TypeCastExpression(path){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var node=path.node;var target=void 0;switch(node.expression.type){case 'Identifier':target=node.expression;break;case 'AssignmentExpression':target=node.expression.left;break;default: // unsupported.\nreturn;}var id=path.scope.getBindingIdentifier(target.name);if(!id){return;}id.savedTypeAnnotation=path.getTypeAnnotation();},ForOfStatement:function ForOfStatement(path,context){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument \"context\" violates contract.\\n\\nExpected:\\nVisitorContext\\n\\nGot:\\n'+_inspect(context));}if(maybeSkip(path)){return;}var left=path.get('left');if(!NodePath(left)){throw new TypeError('Value of variable \"left\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(left));}var right=path.get('right');if(!NodePath(right)){throw new TypeError('Value of variable \"right\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(right));}var rightAnnotation=getAnnotation(right);if(!TypeAnnotation(rightAnnotation)){throw new TypeError('Value of variable \"rightAnnotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(rightAnnotation));}var leftAnnotation=left.isVariableDeclaration()?getAnnotation(left.get('declarations')[0].get('id')):getAnnotation(left);if(!TypeAnnotation(leftAnnotation)){throw new TypeError('Value of variable \"leftAnnotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(leftAnnotation));}if(rightAnnotation.type!=='VoidTypeAnnotation'&&rightAnnotation.type!=='NullLiteralTypeAnnotation'){var ok=maybeIterableAnnotation(rightAnnotation);if(!(ok==null||typeof ok==='boolean')){throw new TypeError('Value of variable \"ok\" violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(ok));}if(ok===false){throw path.buildCodeFrameError('Cannot iterate '+humanReadableType(rightAnnotation)+'.');}}var id=void 0;if(!(id==null||Identifier(id))){throw new TypeError('Value of variable \"id\" violates contract.\\n\\nExpected:\\n?Identifier\\n\\nGot:\\n'+_inspect(id));}if(right.isIdentifier()){id=right.node;if(!(id==null||Identifier(id))){throw new TypeError('Value of variable \"id\" violates contract.\\n\\nExpected:\\n?Identifier\\n\\nGot:\\n'+_inspect(id));}}else {id=path.scope.generateUidIdentifierBasedOnNode(right.node);if(!(id==null||Identifier(id))){throw new TypeError('Value of variable \"id\" violates contract.\\n\\nExpected:\\n?Identifier\\n\\nGot:\\n'+_inspect(id));}path.scope.push({id:id});var replacement=t.expressionStatement(t.assignmentExpression('=',id,right.node));if(!Node(replacement)){throw new TypeError('Value of variable \"replacement\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(replacement));}path.insertBefore(replacement);right.replaceWith(id);}path.insertBefore(guard({check:checks.iterable({input:id}),message:t.binaryExpression('+',t.stringLiteral('Expected '+humanReadableType(right.node)+' to be iterable, got '),readableName({inspect:context.inspect,input:id}))}));if(rightAnnotation.type!=='GenericTypeAnnotation'||rightAnnotation.id.name!=='Iterable'||!rightAnnotation.typeParameters||!rightAnnotation.typeParameters.params.length){return;}var annotation=rightAnnotation.typeParameters.params[0];if(!TypeAnnotation(annotation)){throw new TypeError('Value of variable \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}if(compareAnnotations(annotation,leftAnnotation)===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid iterator type.',annotation,leftAnnotation));}},ClassDeclaration:function ClassDeclaration(path,context){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument \"context\" violates contract.\\n\\nExpected:\\nVisitorContext\\n\\nGot:\\n'+_inspect(context));} // Convert React props to propTypes\nif(!path.node.superClass){return;}var props=void 0;if(!(props==null||NodePath(props))){throw new TypeError('Value of variable \"props\" violates contract.\\n\\nExpected:\\n?NodePath\\n\\nGot:\\n'+_inspect(props));}var hasRenderMethod=false;_path$get=path.get('body.body');if(!(_path$get&&(typeof _path$get[Symbol.iterator]==='function'||Array.isArray(_path$get)))){throw new TypeError('Expected _path$get to be iterable, got '+_inspect(_path$get));}var _iteratorNormalCompletion2=true;var _didIteratorError2=false;var _iteratorError2=undefined;try{for(var _iterator2=_path$get[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=true){var _path$get;var memberPath=_step2.value;var classMember=memberPath.node;if(t.isClassProperty(classMember)){if(classMember.key.name==='propTypes'&&classMember.static){return;}else if(classMember.key.name==='props'&&!classMember.static){props=memberPath;if(!(props==null||NodePath(props))){throw new TypeError('Value of variable \"props\" violates contract.\\n\\nExpected:\\n?NodePath\\n\\nGot:\\n'+_inspect(props));}}}if(t.isClassMethod(classMember)&&classMember.key.name==='render'){hasRenderMethod=true;}}}catch(err){_didIteratorError2=true;_iteratorError2=err;}finally {try{if(!_iteratorNormalCompletion2&&_iterator2.return){_iterator2.return();}}finally {if(_didIteratorError2){throw _iteratorError2;}}}var type=void 0;if(!(type==null||Node(type))){throw new TypeError('Value of variable \"type\" violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(type));}if(path.node.superTypeParameters){if(path.node.superTypeParameters.params.length!==3){return;}type=path.node.superTypeParameters.params[1];if(!(type==null||Node(type))){throw new TypeError('Value of variable \"type\" violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(type));}}if(props){type=props.node.typeAnnotation.typeAnnotation;if(!(type==null||Node(type))){throw new TypeError('Value of variable \"type\" violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(type));}}if(!type||!hasRenderMethod){return;}if(t.isGenericTypeAnnotation(type)){var binding=path.scope.getBinding(type.id.name);type=getAnnotation(binding.path);if(!(type==null||Node(type))){throw new TypeError('Value of variable \"type\" violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(type));}}if(!t.isObjectTypeAnnotation(type)){return;} // Now we have a class that has a superclass, an instance method called 'render'\n// and some property type annotations. We can be reasonably sure it's a React component.\nvar propTypes=t.objectExpression(type.properties.map(function(prop){return t.objectProperty(t.identifier(prop.key.name),generatePropType(prop.value,path.scope,context));}));if(path.node.decorators){var property=t.classProperty(t.identifier('propTypes'),propTypes);property.static=true;props.insertAfter(property);}else {var root=path.parentPath.isExportDeclaration()?path.parentPath:path;if(!NodePath(root)){throw new TypeError('Value of variable \"root\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(root));}root.insertAfter(t.expressionStatement(t.assignmentExpression(\"=\",t.memberExpression(path.node.id,t.identifier(\"propTypes\")),propTypes)));}}}; /**\n   * Collect all the type declarations in the given path and add references to them for retreival later.\n   */function collectTypes(path){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}path.traverse({InterfaceDeclaration:function InterfaceDeclaration(path){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}path.scope.setData('typechecker:'+path.node.id.name,path);},TypeAlias:function TypeAlias(path){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}path.scope.setData('typechecker:'+path.node.id.name,path);},ImportDeclaration:function ImportDeclaration(path){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(path.node.importKind!=='type'){return;}path.get('specifiers').forEach(function(specifier){var local=specifier.get('local');if(local.isIdentifier()){path.scope.setData('typechecker:'+local.node.name,specifier);}else {path.scope.setData('typechecker:'+local.node.id.name,specifier);}});},\"Function|Class\":function FunctionClass(path){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var node=path.node;if(node.typeParameters&&node.typeParameters.params){path.get('typeParameters').get('params').forEach(function(typeParam){path.get('body').scope.setData('typeparam:'+typeParam.node.name,typeParam);});}}});}return {visitor:{Program:function Program(path,_ref107){var opts=_ref107.opts;if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(opts&&opts.disable&&opts.disable[process.env.NODE_ENV]){return;}var checkFile=false;_path$get2=path.get('body');if(!(_path$get2&&(typeof _path$get2[Symbol.iterator]==='function'||Array.isArray(_path$get2)))){throw new TypeError('Expected _path$get2 to be iterable, got '+_inspect(_path$get2));}var _iteratorNormalCompletion3=true;var _didIteratorError3=false;var _iteratorError3=undefined;try{for(var _iterator3=_path$get2[Symbol.iterator](),_step3;!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=true){var _path$get2;var _child=_step3.value;if(mustCheckFile(_child,opts)){checkFile=true;break;}}}catch(err){_didIteratorError3=true;_iteratorError3=err;}finally {try{if(!_iteratorNormalCompletion3&&_iterator3.return){_iterator3.return();}}finally {if(_didIteratorError3){throw _iteratorError3;}}}if(!checkFile){_path$get3=path.get('body');if(!(_path$get3&&(typeof _path$get3[Symbol.iterator]==='function'||Array.isArray(_path$get3)))){throw new TypeError('Expected _path$get3 to be iterable, got '+_inspect(_path$get3));}var _iteratorNormalCompletion4=true;var _didIteratorError4=false;var _iteratorError4=undefined;try{for(var _iterator4=_path$get3[Symbol.iterator](),_step4;!(_iteratorNormalCompletion4=(_step4=_iterator4.next()).done);_iteratorNormalCompletion4=true){var _path$get3;var child=_step4.value;if(maybeSkipFile(child,opts)){return;}}}catch(err){_didIteratorError4=true;_iteratorError4=err;}finally {try{if(!_iteratorNormalCompletion4&&_iterator4.return){_iterator4.return();}}finally {if(_didIteratorError4){throw _iteratorError4;}}}}collectTypes(path);var inspect=path.scope.generateUidIdentifier('inspect');var requiresHelpers={inspect:false};var context={get inspect(){requiresHelpers.inspect=true;return inspect;}};path.traverse(visitors,context);if(requiresHelpers.inspect){var body=path.get('body');body[body.length-1].insertAfter(template('\\n            function id (input, depth) {\\n              const maxDepth = 4;\\n              const maxKeys = 15;\\n              if (depth === undefined) {\\n                depth = 0;\\n              }\\n              depth += 1;\\n              if (input === null) {\\n                return \\'null\\';\\n              }\\n              else if (input === undefined) {\\n                return \\'void\\';\\n              }\\n              else if (typeof input === \\'string\\' || typeof input === \\'number\\' || typeof input === \\'boolean\\') {\\n                return typeof input;\\n              }\\n              else if (Array.isArray(input)) {\\n                if (input.length > 0) {\\n                  if (depth > maxDepth) return \\'[...]\\';\\n                  const first = id(input[0], depth);\\n                  if (input.every(item => id(item, depth) === first)) {\\n                    return first.trim() + \\'[]\\';\\n                  }\\n                  else {\\n                    return \\'[\\' + input.slice(0, maxKeys).map(item => id(item, depth)).join(\\', \\') + (input.length >= maxKeys ? \\', ...\\' : \\'\\') + \\']\\';\\n                  }\\n                }\\n                else {\\n                  return \\'Array\\';\\n                }\\n              }\\n              else {\\n                const keys = Object.keys(input);\\n                if (!keys.length) {\\n                  if (input.constructor && input.constructor.name && input.constructor.name !== \\'Object\\') {\\n                    return input.constructor.name;\\n                  }\\n                  else {\\n                    return \\'Object\\';\\n                  }\\n                }\\n                if (depth > maxDepth) return \\'{...}\\';\\n                const indent = \\'  \\'.repeat(depth - 1);\\n                let entries = keys.slice(0, maxKeys).map(key => {\\n                  return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key) ? key : JSON.stringify(key)) + \\': \\' + id(input[key], depth) + \\';\\';\\n                }).join(\\'\\\\n  \\' + indent);\\n                if (keys.length >= maxKeys) {\\n                  entries += \\'\\\\n  \\' + indent + \\'...\\';\\n                }\\n                if (input.constructor && input.constructor.name && input.constructor.name !== \\'Object\\') {\\n                  return input.constructor.name + \\' {\\\\n  \\' + indent + entries + \\'\\\\n\\' + indent + \\'}\\';\\n                }\\n                else {\\n                  return \\'{\\\\n  \\' + indent + entries + \\'\\\\n\\' + indent + \\'}\\';\\n                }\\n              }\\n            }\\n          ')({id:inspect}));}}}}; /**\n   * Create a function which can verify the return type for a function.\n   */function createFunctionReturnGuard(path,context){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument \"context\" violates contract.\\n\\nExpected:\\nVisitorContext\\n\\nGot:\\n'+_inspect(context));}var node=path.node;var scope=path.scope;var annotation=node.returnType;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(isGeneratorAnnotation(annotation)){annotation=annotation.typeParameters&&annotation.typeParameters.params.length>1?annotation.typeParameters.params[1]:t.anyTypeAnnotation();}else if(node.async&&annotation.type==='GenericTypeAnnotation'&&annotation.id.name==='Promise'){annotation=annotation.typeParameters&&annotation.typeParameters[0]||t.anyTypeAnnotation();}var name=scope.generateUidIdentifierBasedOnNode(node);var id=scope.generateUidIdentifier('id');var check=checkAnnotation(id,annotation,scope);if(check){node.returnGuard=guardFn({id:id,name:name,check:check,message:returnTypeErrorMessage(path,path.node,id,context)});node.returnGuard.hasBeenTypeChecked=true;node.returnGuardName=name;node.returnGuardCount=0;}}function createFunctionYieldGuards(path,context){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument \"context\" violates contract.\\n\\nExpected:\\nVisitorContext\\n\\nGot:\\n'+_inspect(context));}var node=path.node;var scope=path.scope;var annotation=node.returnType;if(annotation.type==='NullableTypeAnnotation'||annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(!annotation.typeParameters||annotation.typeParameters.params.length===0){return;}if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(!isGeneratorAnnotation(annotation)){return;}var yieldType=annotation.typeParameters.params[0];var nextType=annotation.typeParameters.params[2];if(yieldType){var _name=scope.generateUidIdentifier('check'+(node.id?node.id.name.slice(0,1).toUpperCase()+node.id.name.slice(1):'')+'Yield');var _id119=scope.generateUidIdentifier('id');var check=checkAnnotation(_id119,yieldType,scope);if(check){node.yieldGuard=guardFn({id:_id119,name:_name,check:check,message:yieldTypeErrorMessage(node,yieldType,_id119,context)});node.yieldGuardName=_name;node.yieldGuardCount=0;}}if(nextType){var _name2=scope.generateUidIdentifier('check'+(node.id?node.id.name.slice(0,1).toUpperCase()+node.id.name.slice(1):'')+'Next');var _id120=scope.generateUidIdentifier('id');var _check2=checkAnnotation(_id120,nextType,scope);if(_check2){node.nextGuard=guardFn({id:_id120,name:_name2,check:_check2,message:yieldNextTypeErrorMessage(node,nextType,_id120,context)});node.nextGuardName=_name2;node.nextGuardCount=0;}}}function isThisMemberExpression(path){function _ref4(_id17){if(!(typeof _id17==='boolean')){throw new TypeError('Function \"isThisMemberExpression\" return value violates contract.\\n\\nExpected:\\nbool\\n\\nGot:\\n'+_inspect(_id17));}return _id17;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var node=path.node;if(node.type==='ThisExpression'){return true;}else if(node.type==='MemberExpression'){return _ref4(isThisMemberExpression(path.get('object')));}else {return false;}}function isGeneratorAnnotation(annotation){if(!(annotation==null||TypeAnnotation(annotation))){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\n?TypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}if(!annotation){return false;}if(annotation.type==='TypeAnnotation'||annotation.type==='NullableTypeAnnotation'){annotation=annotation.typeAnnotation;}return annotation.type==='GenericTypeAnnotation'&&annotation.id.name==='Generator';}function buildErrorMessage(message,expected,got){if(!(typeof message==='string')){throw new TypeError('Value of argument \"message\" violates contract.\\n\\nExpected:\\nstring\\n\\nGot:\\n'+_inspect(message));}if(!TypeAnnotation(expected)){throw new TypeError('Value of argument \"expected\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(expected));}if(!(got==null||Node(got))){throw new TypeError('Value of argument \"got\" violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(got));}if(got){return message+'\\n\\nExpected:\\n'+humanReadableType(expected)+'\\n\\nGot:\\n'+humanReadableType(got);}else {return message+'\\n\\nExpected:\\n'+humanReadableType(expected);}}function createChecks(){return {number:expression('typeof input === \\'number\\''),numericLiteral:checkNumericLiteral,boolean:expression('typeof input === \\'boolean\\''),booleanLiteral:checkBooleanLiteral,class:checkClass,function:expression('typeof input === \\'function\\''),string:expression('typeof input === \\'string\\''),stringLiteral:checkStringLiteral,symbol:expression('typeof input === \\'symbol\\''),undefined:expression('input === undefined'),null:expression('input === null'),void:expression('input == null'),instanceof:expression('input instanceof type'),type:expression('type(input)'),mixed:function mixed(){return null;},any:function any(){return null;},union:checkUnion,intersection:checkIntersection,array:checkArray,map:checkMap,set:checkSet,generator:checkGenerator,iterable:checkIterable,tuple:checkTuple,object:checkObject,nullable:checkNullable,typeof:checkTypeof,int8:expression('typeof input === \\'number\\' && !isNaN(input) && input >= -128 && input <= 127 && input === Math.floor(input)'),uint8:expression('typeof input === \\'number\\' && !isNaN(input) && input >= 0 && input <= 255 && input === Math.floor(input)'),int16:expression('typeof input === \\'number\\' && !isNaN(input) && input >= -32768 && input <= 32767 && input === Math.floor(input)'),uint16:expression('typeof input === \\'number\\' && !isNaN(input) && input >= 0 && input <= 65535 && input === Math.floor(input)'),int32:expression('typeof input === \\'number\\' && !isNaN(input) && input >= -2147483648 && input <= 2147483647 && input === Math.floor(input)'),uint32:expression('typeof input === \\'number\\' && !isNaN(input) && input >= 0 && input <= 4294967295 && input === Math.floor(input)'),float32:expression('typeof input === \\'number\\' && !isNaN(input) && input >= -3.40282347e+38 && input <= 3.40282347e+38'),float64:expression('typeof input === \\'number\\' && !isNaN(input)'),double:expression('typeof input === \\'number\\' && !isNaN(input)')};}function createStaticChecks(){return {symbol:function symbol(path){function _symbol(_id21){if(!(_id21==null||typeof _id21==='boolean')){throw new TypeError('Function return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id21));}return _id21;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}return _symbol(maybeSymbolAnnotation(getAnnotation(path)));},instanceof:function _instanceof(_ref108){var path=_ref108.path;var annotation=_ref108.annotation;function _instanceof(_id22){if(!(_id22==null||typeof _id22==='boolean')){throw new TypeError('Function return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id22));}return _id22;}var type=createTypeExpression(annotation.id);var node=path.node;var scope=path.scope;if(type.name==='Object'&&node.type==='ObjectExpression'&&!scope.getBinding('Object')){return true;}else if(type.name==='Map'&&!scope.getBinding('Map')){return _instanceof(null);}else if(type.name==='Set'&&!scope.getBinding('Set')){return _instanceof(null);}else if(type.name==='Class'&&!scope.hasBinding('Class')){return _instanceof(null);}else if(type.name==='int8'&&!scope.hasBinding('int8')){return _instanceof(null);}else if(type.name==='uint8'&&!scope.hasBinding('uint8')){return _instanceof(null);}else if(type.name==='int16'&&!scope.hasBinding('int16')){return _instanceof(null);}else if(type.name==='uint16'&&!scope.hasBinding('uint16')){return _instanceof(null);}else if(type.name==='int32'&&!scope.hasBinding('int32')){return _instanceof(null);}else if(type.name==='uint32'&&!scope.hasBinding('uint32')){return _instanceof(null);}else if(type.name==='float32'&&!scope.hasBinding('float32')){return _instanceof(null);}else if(type.name==='float64'&&!scope.hasBinding('float64')){return _instanceof(null);}else if(type.name==='double'&&!scope.hasBinding('double')){return _instanceof(null);}return _instanceof(maybeInstanceOfAnnotation(getAnnotation(path),type,annotation.typeParameters?annotation.typeParameters.params:[]));},type:function(_type2){function type(_x){return _type2.apply(this,arguments);}type.toString=function(){return _type2.toString();};return type;}(function(_ref109){var path=_ref109.path;var type=_ref109.type;function _type(_id23){if(!(_id23==null||typeof _id23==='boolean')){throw new TypeError('Function return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id23));}return _id23;}return _type(null);})};}function compareAnnotations(a,b){function _ref8(_id24){if(!(_id24==null||typeof _id24==='boolean')){throw new TypeError('Function \"compareAnnotations\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id24));}return _id24;}if(!TypeAnnotation(a)){throw new TypeError('Value of argument \"a\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(a));}if(!TypeAnnotation(b)){throw new TypeError('Value of argument \"b\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(b));}if(a.type==='TypeAnnotation'){a=a.typeAnnotation;}if(b.type==='TypeAnnotation'){b=b.typeAnnotation;}switch(a.type){case 'StringTypeAnnotation':return _ref8(maybeStringAnnotation(b));case 'StringLiteral':case 'StringLiteralTypeAnnotation':return _ref8(compareStringLiteralAnnotations(a,b));case 'NumberTypeAnnotation':return _ref8(maybeNumberAnnotation(b));case 'NumericLiteral':case 'NumericLiteralTypeAnnotation':return _ref8(compareNumericLiteralAnnotations(a,b));case 'BooleanTypeAnnotation':return _ref8(maybeBooleanAnnotation(b));case 'BooleanLiteral':case 'BooleanLiteralTypeAnnotation':return _ref8(compareBooleanLiteralAnnotations(a,b));case 'FunctionTypeAnnotation':return _ref8(maybeFunctionAnnotation(b));case 'AnyTypeAnnotation':return _ref8(null);case 'MixedTypeAnnotation':return _ref8(null);case 'ObjectTypeAnnotation':return _ref8(compareObjectAnnotation(a,b));case 'ArrayTypeAnnotation':return _ref8(compareArrayAnnotation(a,b));case 'GenericTypeAnnotation':return _ref8(compareGenericAnnotation(a,b));case 'TupleTypeAnnotation':return _ref8(compareTupleAnnotation(a,b));case 'UnionTypeAnnotation':return _ref8(compareUnionAnnotation(a,b));case 'IntersectionTypeAnnotation':return _ref8(compareIntersectionAnnotation(a,b));case 'NullableTypeAnnotation':return _ref8(compareNullableAnnotation(a,b));default:return _ref8(null);}}function compareStringLiteralAnnotations(a,b){if(!StringLiteralTypeAnnotation(a)){throw new TypeError('Value of argument \"a\" violates contract.\\n\\nExpected:\\nStringLiteralTypeAnnotation\\n\\nGot:\\n'+_inspect(a));}if(!TypeAnnotation(b)){throw new TypeError('Value of argument \"b\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(b));}if(b.type==='StringLiteralTypeAnnotation'||b.type==='StringLiteral'){return a.value===b.value;}else {return maybeStringAnnotation(b)===false?false:null;}}function compareBooleanLiteralAnnotations(a,b){if(!BooleanLiteralTypeAnnotation(a)){throw new TypeError('Value of argument \"a\" violates contract.\\n\\nExpected:\\nBooleanLiteralTypeAnnotation\\n\\nGot:\\n'+_inspect(a));}if(!TypeAnnotation(b)){throw new TypeError('Value of argument \"b\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(b));}if(b.type==='BooleanLiteralTypeAnnotation'||b.type==='BooleanLiteral'){return a.value===b.value;}else {return maybeBooleanAnnotation(b)===false?false:null;}}function compareNumericLiteralAnnotations(a,b){if(!NumericLiteralTypeAnnotation(a)){throw new TypeError('Value of argument \"a\" violates contract.\\n\\nExpected:\\nNumericLiteralTypeAnnotation\\n\\nGot:\\n'+_inspect(a));}if(!TypeAnnotation(b)){throw new TypeError('Value of argument \"b\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(b));}if(b.type==='NumericLiteralTypeAnnotation'||b.type==='NumericLiteral'){return a.value===b.value;}else {return maybeNumberAnnotation(b)===false?false:null;}}function unionComparer(a,b,comparator){function _ref12(_id28){if(!(_id28==null||typeof _id28==='boolean')){throw new TypeError('Function \"unionComparer\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id28));}return _id28;}if(!TypeAnnotation(a)){throw new TypeError('Value of argument \"a\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(a));}if(!TypeAnnotation(b)){throw new TypeError('Value of argument \"b\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(b));}if(!(typeof comparator==='function')){throw new TypeError('Value of argument \"comparator\" violates contract.\\n\\nExpected:\\n(TypeAnnotation, TypeAnnotation) => ?bool\\n\\nGot:\\n'+_inspect(comparator));}if(!a.types||a.types.length===0){return _ref12(null);}var falseCount=0;var trueCount=0;if(!a.types){return _ref12(null);}_a$types=a.types;if(!(_a$types&&(typeof _a$types[Symbol.iterator]==='function'||Array.isArray(_a$types)))){throw new TypeError('Expected _a$types to be iterable, got '+_inspect(_a$types));}var _iteratorNormalCompletion5=true;var _didIteratorError5=false;var _iteratorError5=undefined;try{for(var _iterator5=_a$types[Symbol.iterator](),_step5;!(_iteratorNormalCompletion5=(_step5=_iterator5.next()).done);_iteratorNormalCompletion5=true){var _a$types;var _type3=_step5.value;var result=comparator(_type3,b);if(result===true){if(b.type!=='UnionTypeAnnotation'){return true;}trueCount++;}else if(result===false){if(b.type==='UnionTypeAnnotation'){return false;}falseCount++;}}}catch(err){_didIteratorError5=true;_iteratorError5=err;}finally {try{if(!_iteratorNormalCompletion5&&_iterator5.return){_iterator5.return();}}finally {if(_didIteratorError5){throw _iteratorError5;}}}if(falseCount===a.types.length){return false;}else if(trueCount===a.types.length){return true;}else {return _ref12(null);}}function intersectionComparer(a,b,comparator){function _ref13(_id29){if(!(_id29==null||typeof _id29==='boolean')){throw new TypeError('Function \"intersectionComparer\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id29));}return _id29;}if(!TypeAnnotation(a)){throw new TypeError('Value of argument \"a\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(a));}if(!TypeAnnotation(b)){throw new TypeError('Value of argument \"b\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(b));}if(!(typeof comparator==='function')){throw new TypeError('Value of argument \"comparator\" violates contract.\\n\\nExpected:\\n(TypeAnnotation, TypeAnnotation) => ?bool\\n\\nGot:\\n'+_inspect(comparator));}var falseCount=0;var trueCount=0;if(!a.types){return _ref13(null);}_a$types2=a.types;if(!(_a$types2&&(typeof _a$types2[Symbol.iterator]==='function'||Array.isArray(_a$types2)))){throw new TypeError('Expected _a$types2 to be iterable, got '+_inspect(_a$types2));}var _iteratorNormalCompletion6=true;var _didIteratorError6=false;var _iteratorError6=undefined;try{for(var _iterator6=_a$types2[Symbol.iterator](),_step6;!(_iteratorNormalCompletion6=(_step6=_iterator6.next()).done);_iteratorNormalCompletion6=true){var _a$types2;var _type4=_step6.value;var result=comparator(_type4,b);if(result===true){trueCount++;}else if(result===false){return false;}}}catch(err){_didIteratorError6=true;_iteratorError6=err;}finally {try{if(!_iteratorNormalCompletion6&&_iterator6.return){_iterator6.return();}}finally {if(_didIteratorError6){throw _iteratorError6;}}}if(trueCount===a.types.length){return true;}else {return _ref13(null);}}function compareObjectAnnotation(a,b){function _ref14(_id30){if(!(_id30==null||typeof _id30==='boolean')){throw new TypeError('Function \"compareObjectAnnotation\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id30));}return _id30;}if(!Node(a)){throw new TypeError('Value of argument \"a\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(a));}if(!Node(b)){throw new TypeError('Value of argument \"b\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(b));}switch(b.type){case 'ObjectTypeAnnotation':break;case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref14(compareObjectAnnotation(a,b.typeAnnotation));case 'UnionTypeAnnotation':return _ref14(unionComparer(a,b,compareObjectAnnotation));case 'IntersectionTypeAnnotation':return _ref14(intersectionComparer(a,b,compareObjectAnnotation));case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':return false;default:return _ref14(null);} // We're comparing two object annotations.\nvar allTrue=true;_a$properties=a.properties;if(!(_a$properties&&(typeof _a$properties[Symbol.iterator]==='function'||Array.isArray(_a$properties)))){throw new TypeError('Expected _a$properties to be iterable, got '+_inspect(_a$properties));}var _iteratorNormalCompletion7=true;var _didIteratorError7=false;var _iteratorError7=undefined;try{for(var _iterator7=_a$properties[Symbol.iterator](),_step7;!(_iteratorNormalCompletion7=(_step7=_iterator7.next()).done);_iteratorNormalCompletion7=true){var _a$properties;var aprop=_step7.value;var found=false;_b$properties=b.properties;if(!(_b$properties&&(typeof _b$properties[Symbol.iterator]==='function'||Array.isArray(_b$properties)))){throw new TypeError('Expected _b$properties to be iterable, got '+_inspect(_b$properties));}var _iteratorNormalCompletion8=true;var _didIteratorError8=false;var _iteratorError8=undefined;try{for(var _iterator8=_b$properties[Symbol.iterator](),_step8;!(_iteratorNormalCompletion8=(_step8=_iterator8.next()).done);_iteratorNormalCompletion8=true){var _b$properties;var bprop=_step8.value;if(bprop.key.name===aprop.key.name){var result=compareAnnotations(aprop.value,bprop.value);if(result===false&&!(aprop.optional&&(bprop.optional||maybeNullableAnnotation(bprop.value)===true))){return false;}else {found=result;}break;}}}catch(err){_didIteratorError8=true;_iteratorError8=err;}finally {try{if(!_iteratorNormalCompletion8&&_iterator8.return){_iterator8.return();}}finally {if(_didIteratorError8){throw _iteratorError8;}}}if(found===false&&!aprop.optional){return false;}allTrue=allTrue&&found===true;}}catch(err){_didIteratorError7=true;_iteratorError7=err;}finally {try{if(!_iteratorNormalCompletion7&&_iterator7.return){_iterator7.return();}}finally {if(_didIteratorError7){throw _iteratorError7;}}}return allTrue?true:null;}function compareArrayAnnotation(a,b){function _ref15(_id31){if(!(_id31==null||typeof _id31==='boolean')){throw new TypeError('Function \"compareArrayAnnotation\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id31));}return _id31;}if(!Node(a)){throw new TypeError('Value of argument \"a\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(a));}if(!Node(b)){throw new TypeError('Value of argument \"b\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(b));}switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref15(compareArrayAnnotation(a,b.typeAnnotation));case 'UnionTypeAnnotation':return _ref15(unionComparer(a,b,compareArrayAnnotation));case 'IntersectionTypeAnnotation':return _ref15(intersectionComparer(a,b,compareArrayAnnotation));case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':return false;default:return _ref15(null);}}function compareGenericAnnotation(a,b){function _ref16(_id32){if(!(_id32==null||typeof _id32==='boolean')){throw new TypeError('Function \"compareGenericAnnotation\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id32));}return _id32;}if(!Node(a)){throw new TypeError('Value of argument \"a\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(a));}if(!Node(b)){throw new TypeError('Value of argument \"b\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(b));}switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref16(compareGenericAnnotation(a,b.typeAnnotation));case 'GenericTypeAnnotation':if(b.id.name===a.id.name){return true;}else {return _ref16(null);}case 'UnionTypeAnnotation':return _ref16(unionComparer(a,b,compareGenericAnnotation));case 'IntersectionTypeAnnotation':return _ref16(intersectionComparer(a,b,compareGenericAnnotation));default:return _ref16(null);}}function compareTupleAnnotation(a,b){function _ref17(_id33){if(!(_id33==null||typeof _id33==='boolean')){throw new TypeError('Function \"compareTupleAnnotation\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id33));}return _id33;}if(!Node(a)){throw new TypeError('Value of argument \"a\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(a));}if(!Node(b)){throw new TypeError('Value of argument \"b\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(b));}if(b.type==='TupleTypeAnnotation'){if(b.types.length===0){return _ref17(null);}else if(b.types.length<a.types.length){return false;}return _ref17(a.types.every(function(type,index){return compareAnnotations(type,b.types[index]);}));}switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref17(compareTupleAnnotation(a,b.typeAnnotation));case 'UnionTypeAnnotation':return _ref17(unionComparer(a,b,compareTupleAnnotation));case 'IntersectionTypeAnnotation':return _ref17(intersectionComparer(a,b,compareTupleAnnotation));case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':return false;default:return _ref17(null);}}function compareUnionAnnotation(a,b){function _ref18(_id34){if(!(_id34==null||typeof _id34==='boolean')){throw new TypeError('Function \"compareUnionAnnotation\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id34));}return _id34;}if(!Node(a)){throw new TypeError('Value of argument \"a\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(a));}if(!Node(b)){throw new TypeError('Value of argument \"b\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(b));}switch(b.type){case 'NullableTypeAnnotation':return _ref18(compareUnionAnnotation(a,b.typeAnnotation));case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':return _ref18(null);default:return _ref18(unionComparer(a,b,compareAnnotations));}}function compareNullableAnnotation(a,b){function _ref19(_id35){if(!(_id35==null||typeof _id35==='boolean')){throw new TypeError('Function \"compareNullableAnnotation\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id35));}return _id35;}if(!Node(a)){throw new TypeError('Value of argument \"a\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(a));}if(!Node(b)){throw new TypeError('Value of argument \"b\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(b));}switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':return _ref19(compareNullableAnnotation(a,b.typeAnnotation));case 'NullableTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':return _ref19(null);}if(compareAnnotations(a.typeAnnotation,b)===true){return true;}else {return _ref19(null);}}function arrayExpressionToTupleAnnotation(path){function _ref20(_id36){if(!TypeAnnotation(_id36)){throw new TypeError('Function \"arrayExpressionToTupleAnnotation\" return value violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(_id36));}return _id36;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var elements=path.get('elements');return _ref20(t.tupleTypeAnnotation(elements.map(function(element){return getAnnotation(element);})));}function checkNullable(_ref110){var input=_ref110.input;var type=_ref110.type;var scope=_ref110.scope;function _ref21(_id37){if(!(_id37==null||Node(_id37))){throw new TypeError('Function \"checkNullable\" return value violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(_id37));}return _id37;}var check=checkAnnotation(input,type,scope);if(!check){return;}return _ref21(t.logicalExpression(\"||\",checks.void({input:input}),check));}function checkTypeof(_ref111){var input=_ref111.input;var annotation=_ref111.annotation;var scope=_ref111.scope;function _ref22(_id38){if(!(_id38==null||Node(_id38))){throw new TypeError('Function \"checkTypeof\" return value violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(_id38));}return _id38;}switch(annotation.type){case 'GenericTypeAnnotation':var id=annotation.id;var path=Object.assign({},input,{type:id.type,node:id,scope:scope});return _ref22(checkAnnotation(input,getAnnotation(path),scope));default:return _ref22(checkAnnotation(input,annotation,scope));}}function checkStringLiteral(_ref112){var input=_ref112.input;var annotation=_ref112.annotation;function _ref23(_id39){if(!(_id39==null||Node(_id39))){throw new TypeError('Function \"checkStringLiteral\" return value violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(_id39));}return _id39;}return _ref23(checkEquals({input:input,expected:t.stringLiteral(annotation.value)}));}function checkNumericLiteral(_ref113){var input=_ref113.input;var annotation=_ref113.annotation;function _ref24(_id40){if(!(_id40==null||Node(_id40))){throw new TypeError('Function \"checkNumericLiteral\" return value violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(_id40));}return _id40;}return _ref24(checkEquals({input:input,expected:t.numericLiteral(annotation.value)}));}function checkBooleanLiteral(_ref114){var input=_ref114.input;var annotation=_ref114.annotation;function _ref25(_id41){if(!(_id41==null||Node(_id41))){throw new TypeError('Function \"checkBooleanLiteral\" return value violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(_id41));}return _id41;}return _ref25(checkEquals({input:input,expected:t.booleanLiteral(annotation.value)}));}function checkUnion(_ref115){var input=_ref115.input;var types=_ref115.types;var scope=_ref115.scope;function _ref26(_id42){if(!(_id42==null||Node(_id42))){throw new TypeError('Function \"checkUnion\" return value violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(_id42));}return _id42;}var checks=types.map(function(type){return checkAnnotation(input,type,scope);}).filter(identity);return _ref26(checks.reduce(function(last,check,index){if(last==null){return check;}return t.logicalExpression(\"||\",last,check);},null));}function checkIntersection(_ref116){var input=_ref116.input;var types=_ref116.types;var scope=_ref116.scope;function _ref27(_id43){if(!(_id43==null||Node(_id43))){throw new TypeError('Function \"checkIntersection\" return value violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(_id43));}return _id43;}var checks=types.map(function(type){return checkAnnotation(input,type,scope);}).filter(identity);return _ref27(checks.reduce(function(last,check,index){if(last==null){return check;}return t.logicalExpression(\"&&\",last,check);},null));}function checkMap(_ref117){var input=_ref117.input;var types=_ref117.types;var scope=_ref117.scope;function _ref28(_id44){if(!Node(_id44)){throw new TypeError('Function \"checkMap\" return value violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(_id44));}return _id44;}var _types=_slicedToArray(types,2);var keyType=_types[0];var valueType=_types[1];var key=t.identifier('key');var value=t.identifier('value');var keyCheck=keyType?checkAnnotation(key,keyType,scope):null;var valueCheck=valueType?checkAnnotation(value,valueType,scope):null;if(!keyCheck){if(!valueCheck){return _ref28(checkIsMap({input:input}));}else {return _ref28(checkMapValues({input:input,value:value,valueCheck:valueCheck}));}}else {if(!valueCheck){return _ref28(checkMapKeys({input:input,key:key,keyCheck:keyCheck}));}else {return _ref28(checkMapEntries({input:input,key:key,value:value,keyCheck:keyCheck,valueCheck:valueCheck}));}}}function checkSet(_ref118){var input=_ref118.input;var types=_ref118.types;var scope=_ref118.scope;function _ref29(_id45){if(!Node(_id45)){throw new TypeError('Function \"checkSet\" return value violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(_id45));}return _id45;}var _types2=_slicedToArray(types,1);var valueType=_types2[0];var value=t.identifier('value');var valueCheck=valueType?checkAnnotation(value,valueType,scope):null;if(!valueCheck){return _ref29(checkIsSet({input:input}));}else {return _ref29(checkSetEntries({input:input,value:value,valueCheck:valueCheck}));}}function checkGenerator(_ref119){var input=_ref119.input;var types=_ref119.types;var scope=_ref119.scope;function _ref30(_id46){if(!Node(_id46)){throw new TypeError('Function \"checkGenerator\" return value violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(_id46));}return _id46;}return _ref30(checkIsGenerator({input:input}));}function checkIterable(_ref120){var input=_ref120.input;var types=_ref120.types;var scope=_ref120.scope;function _ref31(_id47){if(!Node(_id47)){throw new TypeError('Function \"checkIterable\" return value violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(_id47));}return _id47;}return _ref31(checkIsIterable({input:input}));}function checkClass(_ref121){var input=_ref121.input;var types=_ref121.types;var scope=_ref121.scope;function _ref32(_id48){if(!Node(_id48)){throw new TypeError('Function \"checkClass\" return value violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(_id48));}return _id48;}return _ref32(checkIsClass({input:input}));}function checkArray(_ref122){var input=_ref122.input;var types=_ref122.types;var scope=_ref122.scope;function _ref33(_id49){if(!Node(_id49)){throw new TypeError('Function \"checkArray\" return value violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(_id49));}return _id49;}if(!types||types.length===0){return _ref33(checkIsArray({input:input}));}else if(types.length===1){var item=t.identifier('item');var _type5=types[0];var check=checkAnnotation(item,_type5,scope);if(!check){return _ref33(checkIsArray({input:input}));}return _ref33(t.logicalExpression('&&',checkIsArray({input:input}),t.callExpression(t.memberExpression(input,t.identifier('every')),[t.functionExpression(null,[item],t.blockStatement([t.returnStatement(check)]))])));}else { // This is a tuple\nvar _checks=types.map(function(type,index){return checkAnnotation(t.memberExpression(input,t.numericLiteral(index),true),type,scope);}).filter(identity);var checkLength=t.binaryExpression('>=',t.memberExpression(input,t.identifier('length')),t.numericLiteral(types.length));return _ref33(_checks.reduce(function(last,check,index){return t.logicalExpression(\"&&\",last,check);},t.logicalExpression('&&',checkIsArray({input:input}),checkLength)));}}function checkTuple(_ref123){var input=_ref123.input;var types=_ref123.types;var scope=_ref123.scope;function _ref34(_id50){if(!Node(_id50)){throw new TypeError('Function \"checkTuple\" return value violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(_id50));}return _id50;}if(types.length===0){return _ref34(checkIsArray({input:input}));} // This is a tuple\nvar checks=types.map(function(type,index){return checkAnnotation(t.memberExpression(input,t.numericLiteral(index),true),type,scope);}).filter(identity);var checkLength=t.binaryExpression('>=',t.memberExpression(input,t.identifier('length')),t.numericLiteral(types.length));return _ref34(checks.reduce(function(last,check,index){return t.logicalExpression(\"&&\",last,check);},t.logicalExpression('&&',checkIsArray({input:input}),checkLength)));}function checkObject(_ref124){var input=_ref124.input;var properties=_ref124.properties;var indexers=_ref124.indexers;var scope=_ref124.scope;function _ref35(_id51){if(!Node(_id51)){throw new TypeError('Function \"checkObject\" return value violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(_id51));}return _id51;}if(input.type==='ObjectPattern'){return _ref35(checkObjectPattern({input:input,properties:properties,scope:scope}));}var propNames=[];var check=properties.length===0?checkIsObject({input:input}):properties.reduce(function(expr,prop,index){var target=prop.key.type==='Identifier'?t.memberExpression(input,prop.key):t.memberExpression(input,prop.key,true);propNames.push(prop.key.type==='Identifier'?t.stringLiteral(prop.key.name):prop.key);var check=checkAnnotation(target,prop.value,scope);if(check){if(prop.optional){check=t.logicalExpression('||',checks.undefined({input:target}),check);}return t.logicalExpression(\"&&\",expr,check);}else {return expr;}},checkNotNull({input:input}));if(indexers.length){return _ref35(indexers.reduceRight(function(expr,indexer){if(indexer.value.type==='AnyTypeAnnotation'){return expr;}var value=scope.generateUidIdentifier(indexer.id.name);var check=checkAnnotation(value,indexer.value,scope);var fixedKeys=t.arrayExpression(propNames);if(check){if(propNames.length){return t.logicalExpression('&&',expr,checkObjectIndexers({input:input,value:value,check:check,fixedKeys:fixedKeys}));}else {return t.logicalExpression('&&',expr,checkObjectIndexersNoFixed({input:input,value:value,check:check,fixedKeys:fixedKeys}));}}else {return expr;}},check));}return _ref35(check);}function checkObjectPattern(_ref125){var input=_ref125.input;var properties=_ref125.properties;var scope=_ref125.scope;function _ref36(_id52){if(!(_id52==null||Node(_id52))){throw new TypeError('Function \"checkObjectPattern\" return value violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(_id52));}return _id52;}var propNames=properties.reduce(function(names,prop){names[prop.key.name]=prop;return names;},{});var propChecks={};_input$properties=input.properties;if(!(_input$properties&&(typeof _input$properties[Symbol.iterator]==='function'||Array.isArray(_input$properties)))){throw new TypeError('Expected _input$properties to be iterable, got '+_inspect(_input$properties));}var _iteratorNormalCompletion9=true;var _didIteratorError9=false;var _iteratorError9=undefined;try{for(var _iterator9=_input$properties[Symbol.iterator](),_step9;!(_iteratorNormalCompletion9=(_step9=_iterator9.next()).done);_iteratorNormalCompletion9=true){var _input$properties;var item=_step9.value;var key=item.key;var _id121=item.value;var prop=propNames[key.name];if(!prop){continue;}var check=checkAnnotation(_id121,prop.value,scope);if(check){propChecks[key.name]=check;}}}catch(err){_didIteratorError9=true;_iteratorError9=err;}finally {try{if(!_iteratorNormalCompletion9&&_iterator9.return){_iterator9.return();}}finally {if(_didIteratorError9){throw _iteratorError9;}}}return _ref36(Object.keys(propChecks).reduce(function(last,name){var check=propChecks[name];if(last===null){return check;}else {return t.logicalExpression('&&',last,check);}},null));}function createTypeAliasChecks(path){function _ref37(_id53){if(!Node(_id53)){throw new TypeError('Function \"createTypeAliasChecks\" return value violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(_id53));}return _id53;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var node=path.node;var scope=path.scope;var id=node.id;var annotation=node.right;var input=t.identifier('input');var check=checkAnnotation(input,annotation,scope)||t.booleanLiteral(true);var declaration=declareTypeChecker({id:id,check:check});declaration.isTypeChecker=true;declaration.savedTypeAnnotation=annotation;declaration.declarations[0].savedTypeAnnotation=annotation;return _ref37(declaration);}function createInterfaceChecks(path){function _ref38(_id54){if(!Node(_id54)){throw new TypeError('Function \"createInterfaceChecks\" return value violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(_id54));}return _id54;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var node=path.node;var scope=path.scope;var id=node.id;var annotation=node.body;var input=t.identifier('input');var check=node.extends.reduce(function(check,extender){return t.logicalExpression('&&',check,checkAnnotation(input,t.genericTypeAnnotation(extender.id),path.scope));return check;},checkAnnotation(input,annotation,scope)||t.booleanLiteral(true));var declaration=declareTypeChecker({id:id,check:check});declaration.isTypeChecker=true;return _ref38(declaration);}function checkAnnotation(input,annotation,scope){function _ref39(_id55){if(!(_id55==null||Node(_id55))){throw new TypeError('Function \"checkAnnotation\" return value violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(_id55));}return _id55;}if(!Node(input)){throw new TypeError('Value of argument \"input\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(input));}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}if(!Scope(scope)){throw new TypeError('Value of argument \"scope\" violates contract.\\n\\nExpected:\\nScope\\n\\nGot:\\n'+_inspect(scope));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':return _ref39(checkAnnotation(input,annotation.typeAnnotation,scope));case 'TypeofTypeAnnotation':return _ref39(checks.typeof({input:input,annotation:annotation.argument,scope:scope}));case 'GenericTypeAnnotation':if(annotation.id.name==='Array'){return _ref39(checks.array({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope}));}else if(annotation.id.name==='Generator'&&!scope.hasBinding('Generator')){return _ref39(checks.generator({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope}));}else if(annotation.id.name==='Iterable'&&!scope.hasBinding('Iterable')){return _ref39(checks.iterable({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope}));}else if(annotation.id.name==='Map'&&!scope.getBinding('Map')){return _ref39(checks.map({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope}));}else if(annotation.id.name==='Set'&&!scope.getBinding('Set')){return _ref39(checks.set({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope}));}else if(annotation.id.name==='Function'){return _ref39(checks.function({input:input}));}else if(annotation.id.name==='Class'&&!scope.hasBinding('Class')){return _ref39(checks.class({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope}));}else if(annotation.id.name==='int8'&&!scope.hasBinding('int8')){return _ref39(checks.int8({input:input}));}else if(annotation.id.name==='uint8'&&!scope.hasBinding('uint8')){return _ref39(checks.uint8({input:input}));}else if(annotation.id.name==='int16'&&!scope.hasBinding('int16')){return _ref39(checks.int16({input:input}));}else if(annotation.id.name==='uint16'&&!scope.hasBinding('uint16')){return _ref39(checks.uint16({input:input}));}else if(annotation.id.name==='int32'&&!scope.hasBinding('int32')){return _ref39(checks.int32({input:input}));}else if(annotation.id.name==='uint32'&&!scope.hasBinding('uint32')){return _ref39(checks.uint32({input:input}));}else if(annotation.id.name==='float32'&&!scope.hasBinding('float32')){return _ref39(checks.float32({input:input}));}else if(annotation.id.name==='float64'&&!scope.hasBinding('float64')){return _ref39(checks.float64({input:input}));}else if(annotation.id.name==='double'&&!scope.hasBinding('double')){return _ref39(checks.double({input:input}));}else if(annotation.id.name==='Symbol'&&!scope.getBinding('Symbol')){return _ref39(checks.symbol({input:input}));}else if(isTypeChecker(annotation.id,scope)){return _ref39(checks.type({input:input,type:annotation.id}));}else if(isPolymorphicType(annotation.id,scope)){return;}else {return _ref39(checks.instanceof({input:input,type:createTypeExpression(annotation.id)}));}case 'TupleTypeAnnotation':return _ref39(checks.tuple({input:input,types:annotation.types,scope:scope}));case 'NumberTypeAnnotation':return _ref39(checks.number({input:input}));case 'NumericLiteralTypeAnnotation':return _ref39(checks.numericLiteral({input:input,annotation:annotation}));case 'BooleanTypeAnnotation':return _ref39(checks.boolean({input:input}));case 'BooleanLiteralTypeAnnotation':return _ref39(checks.booleanLiteral({input:input,annotation:annotation}));case 'StringTypeAnnotation':return _ref39(checks.string({input:input}));case 'StringLiteralTypeAnnotation':return _ref39(checks.stringLiteral({input:input,annotation:annotation}));case 'UnionTypeAnnotation':return _ref39(checks.union({input:input,types:annotation.types,scope:scope}));case 'IntersectionTypeAnnotation':return _ref39(checks.intersection({input:input,types:annotation.types,scope:scope}));case 'ObjectTypeAnnotation':return _ref39(checks.object({input:input,properties:annotation.properties||[],indexers:annotation.indexers,scope:scope}));case 'ArrayTypeAnnotation':return _ref39(checks.array({input:input,types:[annotation.elementType||t.anyTypeAnnotation()],scope:scope}));case 'FunctionTypeAnnotation':return _ref39(checks.function({input:input,params:annotation.params,returnType:annotation.returnType}));case 'MixedTypeAnnotation':return _ref39(checks.mixed({input:input}));case 'AnyTypeAnnotation':case 'ExistentialTypeParam':return _ref39(checks.any({input:input}));case 'NullableTypeAnnotation':return _ref39(checks.nullable({input:input,type:annotation.typeAnnotation,scope:scope}));case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':return _ref39(checks.void({input:input}));}}function staticCheckAnnotation(path,annotation){function _ref40(_id56){if(!(_id56==null||typeof _id56==='boolean')){throw new TypeError('Function \"staticCheckAnnotation\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id56));}return _id56;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}var other=getAnnotation(path);switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':return _ref40(staticCheckAnnotation(path,annotation.typeAnnotation));case 'GenericTypeAnnotation':if(isTypeChecker(annotation.id,path.scope)){return _ref40(staticChecks.type({path:path,type:annotation.id}));}else if(isPolymorphicType(annotation.id,path.scope)){return;}else if(annotation.id.name==='Symbol'){return _ref40(staticChecks.symbol(path));}else {return _ref40(staticChecks.instanceof({path:path,annotation:annotation}));}}return _ref40(compareAnnotations(annotation,other));} /**\n   * Get the type annotation for a given node.\n   */function getAnnotation(path){function _ref41(_id57){if(!TypeAnnotation(_id57)){throw new TypeError('Function \"getAnnotation\" return value violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(_id57));}return _id57;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var annotation=void 0;try{annotation=getAnnotationShallow(path);}catch(e){if(e instanceof SyntaxError){throw e;}if(process.env.TYPECHECK_DEBUG){console.error(e.stack);}}while(annotation&&annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}return _ref41(annotation||t.anyTypeAnnotation());}function getAnnotationShallow(path){function _ref42(_id58){if(!(_id58==null||TypeAnnotation(_id58))){throw new TypeError('Function \"getAnnotationShallow\" return value violates contract.\\n\\nExpected:\\n?TypeAnnotation\\n\\nGot:\\n'+_inspect(_id58));}return _id58;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(!path||!path.node){return _ref42(t.voidTypeAnnotation());}var node=path.node;var scope=path.scope;if(node.type==='TypeAlias'){return _ref42(node.right);}else if(node.type==='ClassProperty'&&node.typeAnnotation){return _ref42(getClassPropertyAnnotation(path));}else if(node.type==='ClassMethod'&&node.returnType){return _ref42(getClassMethodAnnotation(path));}else if(node.type==='ObjectProperty'&&node.typeAnnotation){return _ref42(getObjectPropertyAnnotation(path));}else if(node.type==='SpreadProperty'&&node.typeAnnotation){return _ref42(getSpreadPropertyAnnotation(path));}else if(node.type==='ObjectMethod'&&node.returnType){return _ref42(getObjectMethodAnnotation(path));}else if(!node.typeAnnotation&&!node.savedTypeAnnotation&&!node.returnType){switch(path.type){case 'Identifier':var binding=scope.getBinding(node.name);if(!binding||!binding.identifier){return _ref42(path.getTypeAnnotation());}var id=binding.identifier;if(binding.path.type==='ObjectPattern'){return _ref42(getObjectPatternAnnotation(binding.path,node.name));}if(id.savedTypeAnnotation){return _ref42(id.savedTypeAnnotation);}else if(id.returnType){return _ref42(id.returnType);}else if(id.typeAnnotation){return _ref42(id.typeAnnotation);}else if(isPolymorphicType(id,scope)){return _ref42(t.anyTypeAnnotation());}return _ref42(binding.constant?binding.path.getTypeAnnotation():path.getTypeAnnotation());case 'StringLiteral':case 'NumericLiteral':case 'BooleanLiteral':return _ref42(createLiteralTypeAnnotation(path));case 'CallExpression':var callee=path.get('callee');if(callee.type==='Identifier'){if(callee.name==='Symbol'){return _ref42(t.genericTypeAnnotation('Symbol'));}var fn=getFunctionForIdentifier(callee);if(fn){return getAnnotation(fn);}}break;case 'ThisExpression':return _ref42(getThisExpressionAnnotation(path));case 'AssignmentExpression':return _ref42(getAssignmentExpressionAnnotation(path));case 'MemberExpression':return getMemberExpressionAnnotation(path);case 'ArrayExpression':return getArrayExpressionAnnotation(path);case 'ObjectExpression':return getObjectExpressionAnnotation(path);case 'BinaryExpression':return getBinaryExpressionAnnotation(path);case 'LogicalExpression':return getLogicalExpressionAnnotation(path);case 'ConditionalExpression':return getConditionalExpressionAnnotation(path);case 'ObjectMethod':return _ref42(getObjectMethodAnnotation(path));case 'SpreadProperty':return _ref42(getSpreadPropertyAnnotation(path));case 'ObjectProperty':return _ref42(getObjectPropertyAnnotation(path));case 'ClassDeclaration':return _ref42(getClassDeclarationAnnotation(path));case 'ClassMethod':return _ref42(getClassMethodAnnotation(path));case 'ClassProperty':return _ref42(getClassPropertyAnnotation(path));default:return _ref42(path.getTypeAnnotation());}}return _ref42(node.savedTypeAnnotation||node.returnType||node.typeAnnotation||path.getTypeAnnotation());}function createLiteralTypeAnnotation(path){function _ref43(_id59){if(!(_id59==null||TypeAnnotation(_id59))){throw new TypeError('Function \"createLiteralTypeAnnotation\" return value violates contract.\\n\\nExpected:\\n?TypeAnnotation\\n\\nGot:\\n'+_inspect(_id59));}return _id59;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var annotation=void 0;if(path.isStringLiteral()){annotation=t.stringLiteralTypeAnnotation();}else if(path.isNumericLiteral()){annotation=t.numericLiteralTypeAnnotation();}else if(path.isBooleanLiteral()){annotation=t.booleanLiteralTypeAnnotation();}else {return _ref43(path.getTypeAnnotation());}annotation.value=path.node.value;return _ref43(annotation);}function getObjectPatternAnnotation(path,name){function _ref44(_id60){if(!(_id60==null||TypeAnnotation(_id60))){throw new TypeError('Function \"getObjectPatternAnnotation\" return value violates contract.\\n\\nExpected:\\n?TypeAnnotation\\n\\nGot:\\n'+_inspect(_id60));}return _id60;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(!(typeof name==='string')){throw new TypeError('Value of argument \"name\" violates contract.\\n\\nExpected:\\nstring\\n\\nGot:\\n'+_inspect(name));}var annotation=keyByName(getAnnotation(path),name);var found=void 0;if(!path.node.properties){return;}_path$get4=path.get('properties');if(!(_path$get4&&(typeof _path$get4[Symbol.iterator]==='function'||Array.isArray(_path$get4)))){throw new TypeError('Expected _path$get4 to be iterable, got '+_inspect(_path$get4));}var _iteratorNormalCompletion10=true;var _didIteratorError10=false;var _iteratorError10=undefined;try{for(var _iterator10=_path$get4[Symbol.iterator](),_step10;!(_iteratorNormalCompletion10=(_step10=_iterator10.next()).done);_iteratorNormalCompletion10=true){var _path$get4;var prop=_step10.value;if(prop.node.value&&prop.node.value.name===name){found=prop.get('key');break;}else if(prop.node.key.type==='Identifier'&&prop.node.key.name===name){found=prop.get('key');break;}}}catch(err){_didIteratorError10=true;_iteratorError10=err;}finally {try{if(!_iteratorNormalCompletion10&&_iterator10.return){_iterator10.return();}}finally {if(_didIteratorError10){throw _iteratorError10;}}}if(!annotation||!found){return;}if(found.type==='Identifier'){annotation.value.authoritative=false;return _ref44(annotation.value);}}function keyByName(node,name){function _ref45(_id61){if(!(_id61==null||Node(_id61))){throw new TypeError('Function \"keyByName\" return value violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(_id61));}return _id61;}if(!Node(node)){throw new TypeError('Value of argument \"node\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(node));}if(!(typeof name==='string')){throw new TypeError('Value of argument \"name\" violates contract.\\n\\nExpected:\\nstring\\n\\nGot:\\n'+_inspect(name));}if(!node.properties){return;}_node$properties=node.properties;if(!(_node$properties&&(typeof _node$properties[Symbol.iterator]==='function'||Array.isArray(_node$properties)))){throw new TypeError('Expected _node$properties to be iterable, got '+_inspect(_node$properties));}var _iteratorNormalCompletion11=true;var _didIteratorError11=false;var _iteratorError11=undefined;try{for(var _iterator11=_node$properties[Symbol.iterator](),_step11;!(_iteratorNormalCompletion11=(_step11=_iterator11.next()).done);_iteratorNormalCompletion11=true){var _node$properties;var prop=_step11.value;if(prop.key&&prop.key.name===name){return _ref45(prop);}}}catch(err){_didIteratorError11=true;_iteratorError11=err;}finally {try{if(!_iteratorNormalCompletion11&&_iterator11.return){_iterator11.return();}}finally {if(_didIteratorError11){throw _iteratorError11;}}}}function valueByName(node,name){function _ref46(_id62){if(!(_id62==null||Node(_id62))){throw new TypeError('Function \"valueByName\" return value violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(_id62));}return _id62;}if(!Node(node)){throw new TypeError('Value of argument \"node\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(node));}if(!(typeof name==='string')){throw new TypeError('Value of argument \"name\" violates contract.\\n\\nExpected:\\nstring\\n\\nGot:\\n'+_inspect(name));}if(!node.properties){return;}_node$properties2=node.properties;if(!(_node$properties2&&(typeof _node$properties2[Symbol.iterator]==='function'||Array.isArray(_node$properties2)))){throw new TypeError('Expected _node$properties2 to be iterable, got '+_inspect(_node$properties2));}var _iteratorNormalCompletion12=true;var _didIteratorError12=false;var _iteratorError12=undefined;try{for(var _iterator12=_node$properties2[Symbol.iterator](),_step12;!(_iteratorNormalCompletion12=(_step12=_iterator12.next()).done);_iteratorNormalCompletion12=true){var _node$properties2;var prop=_step12.value;if(prop.value&&prop.value.name===name){return _ref46(prop);}}}catch(err){_didIteratorError12=true;_iteratorError12=err;}finally {try{if(!_iteratorNormalCompletion12&&_iterator12.return){_iterator12.return();}}finally {if(_didIteratorError12){throw _iteratorError12;}}}}function getSpreadPropertyAnnotation(path){function _ref47(_id63){if(!(_id63==null||TypeAnnotation(_id63))){throw new TypeError('Function \"getSpreadPropertyAnnotation\" return value violates contract.\\n\\nExpected:\\n?TypeAnnotation\\n\\nGot:\\n'+_inspect(_id63));}return _id63;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var node=path.node;var annotation=node.typeAnnotation||node.savedTypeAnnotation;if(!annotation){annotation=getAnnotation(path.get('argument'));}return _ref47(annotation);}function getObjectPropertyAnnotation(path){function _ref48(_id64){if(!(_id64==null||TypeAnnotation(_id64))){throw new TypeError('Function \"getObjectPropertyAnnotation\" return value violates contract.\\n\\nExpected:\\n?TypeAnnotation\\n\\nGot:\\n'+_inspect(_id64));}return _id64;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var node=path.node;var annotation=node.typeAnnotation||node.savedTypeAnnotation;if(!annotation){if(node.value){if(node.value.typeAnnotation||node.value.savedTypeAnnotation){annotation=node.value.typeAnnotation||node.value.savedTypeAnnotation;}else if(node.value.type==='BooleanLiteral'||node.value.type==='NumericLiteral'||node.value.type==='StringLiteral'){annotation=t[node.value.type](node.value.value);}else {annotation=t.anyTypeAnnotation();}}else {annotation=t.anyTypeAnnotation();}}return _ref48(t.objectTypeProperty(node.key,annotation));}function getObjectMethodAnnotation(path){function _ref49(_id65){if(!(_id65==null||TypeAnnotation(_id65))){throw new TypeError('Function \"getObjectMethodAnnotation\" return value violates contract.\\n\\nExpected:\\n?TypeAnnotation\\n\\nGot:\\n'+_inspect(_id65));}return _id65;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var node=path.node;return _ref49(t.objectTypeProperty(t.identifier(node.key.name),t.functionTypeAnnotation(null,node.params.map(function(param){return param.savedTypeAnnotation||param.typeAnnotation;}),null,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation())));}function getThisExpressionAnnotation(path){function _ref50(_id66){if(!(_id66==null||TypeAnnotation(_id66))){throw new TypeError('Function \"getThisExpressionAnnotation\" return value violates contract.\\n\\nExpected:\\n?TypeAnnotation\\n\\nGot:\\n'+_inspect(_id66));}return _id66;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var parent=path.parentPath;loop: while(parent){switch(parent.type){case 'ClassDeclaration':return getAnnotation(parent);case 'ClassBody':return getAnnotation(parent.parentPath);case 'ClassMethod':case 'ClassProperty':return getAnnotation(parent.parentPath.parentPath);case 'ObjectProperty':return getAnnotation(parent.parentPath);case 'ObjectMethod':return getAnnotation(parent.parentPath);case 'FunctionExpression':if(parent.parentPath.type==='ObjectProperty'){return getAnnotation(parent.parentPath.parentPath);}break loop;case 'ArrowFunctionExpression':parent=parent.parentPath;continue;}if(parent.isFunction()){break;}parent=parent.parentPath;}return _ref50(t.objectTypeAnnotation([]));}function getClassDeclarationAnnotation(path){function _ref51(_id67){if(!(_id67==null||TypeAnnotation(_id67))){throw new TypeError('Function \"getClassDeclarationAnnotation\" return value violates contract.\\n\\nExpected:\\n?TypeAnnotation\\n\\nGot:\\n'+_inspect(_id67));}return _id67;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var body=path.get('body').get('body').map(getAnnotation).filter(function(annotation){return annotation&&annotation.type!=='AnyTypeAnnotation';});return _ref51(t.objectTypeAnnotation(body));}function getAssignmentExpressionAnnotation(path){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(path.node.operator==='='){return getAnnotation(path.get('right'));}}function getClassPropertyAnnotation(path){function _ref53(_id69){if(!(_id69==null||TypeAnnotation(_id69))){throw new TypeError('Function \"getClassPropertyAnnotation\" return value violates contract.\\n\\nExpected:\\n?TypeAnnotation\\n\\nGot:\\n'+_inspect(_id69));}return _id69;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var node=path.node;if(node.computed){return;}var annotation=node.typeAnnotation||(node.value?node.value.savedTypeAnnotation||node.value.typeAnnotation:t.anyTypeAnnotation());return _ref53(t.objectTypeProperty(node.key,annotation||t.anyTypeAnnotation()));}function getClassMethodAnnotation(path){function _ref54(_id70){if(!(_id70==null||TypeAnnotation(_id70))){throw new TypeError('Function \"getClassMethodAnnotation\" return value violates contract.\\n\\nExpected:\\n?TypeAnnotation\\n\\nGot:\\n'+_inspect(_id70));}return _id70;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var node=path.node;if(node.computed){return;}if(node.kind==='get'){return _ref54(t.objectTypeProperty(node.key,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation()));}else if(node.kind==='set'){return _ref54(t.objectTypeProperty(node.key,node.params.map(function(param){return param.savedTypeAnnotation||param.typeAnnotation;}).shift()||t.anyTypeAnnotation()));}else {return _ref54(t.objectTypeProperty(node.key,t.functionTypeAnnotation(null,node.params.map(function(param){return param.savedTypeAnnotation||param.typeAnnotation||t.anyTypeAnnotation();}),null,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation())));}}function getBinaryExpressionAnnotation(path){function _ref55(_id71){if(!TypeAnnotation(_id71)){throw new TypeError('Function \"getBinaryExpressionAnnotation\" return value violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(_id71));}return _id71;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var node=path.node;if(isBooleanExpression(node)){return _ref55(t.booleanTypeAnnotation());}else {return _ref55(t.anyTypeAnnotation());}}function getLogicalExpressionAnnotation(path){function _ref56(_id72){if(!TypeAnnotation(_id72)){throw new TypeError('Function \"getLogicalExpressionAnnotation\" return value violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(_id72));}return _id72;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var node=path.node;if(isBooleanExpression(node)){return _ref56(t.booleanTypeAnnotation());}else {var left=path.get('left');var right=path.get('right');switch(node.operator){case '&&':case '||':var _ref126=[getAnnotation(left),getAnnotation(right)];left=_ref126[0];right=_ref126[1];if(t.isUnionTypeAnnotation(left)){if(t.isUnionTypeAnnotation(right)){return _ref56(t.unionTypeAnnotation(left.types.concat(right.types)));}else {return _ref56(t.unionTypeAnnotation(left.types.concat(right)));}}else {return _ref56(t.unionTypeAnnotation([left,right]));}}return _ref56(t.anyTypeAnnotation());}}function getConditionalExpressionAnnotation(path){function _ref57(_id73){if(!TypeAnnotation(_id73)){throw new TypeError('Function \"getConditionalExpressionAnnotation\" return value violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(_id73));}return _id73;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var node=path.node;var consequent=getAnnotation(path.get('consequent'));var alternate=getAnnotation(path.get('alternate'));if(t.isUnionTypeAnnotation(consequent)){if(t.isUnionTypeAnnotation(alternate)){return _ref57(t.unionTypeAnnotation(consequent.types.concat(alternate.types)));}else {return _ref57(t.unionTypeAnnotation(consequent.types.concat(alternate)));}}else {return _ref57(t.unionTypeAnnotation([consequent,alternate]));}}function getArrayExpressionAnnotation(path){function _ref58(_id74){if(!TypeAnnotation(_id74)){throw new TypeError('Function \"getArrayExpressionAnnotation\" return value violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(_id74));}return _id74;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}return _ref58(t.genericTypeAnnotation(t.identifier('Array'),t.typeParameterDeclaration(path.get('elements').map(getAnnotation))));}function getObjectExpressionAnnotation(path){function _ref59(_id75){if(!TypeAnnotation(_id75)){throw new TypeError('Function \"getObjectExpressionAnnotation\" return value violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(_id75));}return _id75;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var annotation=t.objectTypeAnnotation(path.get('properties').filter(function(prop){return !prop.node.computed;}).map(getAnnotation).reduce(function(properties,prop){if(t.isObjectTypeProperty(prop)){properties.push(prop);}else if(t.isObjectTypeAnnotation(prop)){properties.push.apply(properties,_toConsumableArray(prop.properties));}return properties;},[]).filter(function(annotation){return !t.isAnyTypeAnnotation(annotation.value);}));return _ref59(annotation);}function getMemberExpressionAnnotation(path){function _ref60(_id76){if(!TypeAnnotation(_id76)){throw new TypeError('Function \"getMemberExpressionAnnotation\" return value violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(_id76));}return _id76;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(path.node.computed){return _ref60(getComputedMemberExpressionAnnotation(path));}var stack=[];var target=path;while(target.isMemberExpression()){stack.push(target);if(target.node.computed){break;}target=target.get('object');}var objectAnnotation=stack.reduceRight(function(last,target){var annotation=last;if(annotation==null){if(stack.length===1){annotation=getAnnotation(target.get('object'));}else {return getAnnotation(target);}}switch(annotation.type){case 'AnyTypeAnnotation':return annotation;case 'NullableTypeAnnotation':case 'TypeAnnotation':annotation=annotation.typeAnnotation;}if(annotation.type==='GenericTypeAnnotation'){var typeChecker=getTypeChecker(annotation.id,path.scope);if(typeChecker){annotation=getAnnotation(typeChecker);}else if(isPolymorphicType(annotation.id,path.scope)){annotation=t.anyTypeAnnotation();}else {var binding=path.scope.getBinding(annotation.id.name);if(binding){annotation=getAnnotation(binding.path);}}}switch(annotation.type){case 'AnyTypeAnnotation':return annotation;case 'ObjectTypeAnnotation':var id=target.get('property').node;_ref61=annotation.properties||[];if(!(_ref61&&(typeof _ref61[Symbol.iterator]==='function'||Array.isArray(_ref61)))){throw new TypeError('Expected _ref61 to be iterable, got '+_inspect(_ref61));}var _iteratorNormalCompletion13=true;var _didIteratorError13=false;var _iteratorError13=undefined;try{for(var _iterator13=_ref61[Symbol.iterator](),_step13;!(_iteratorNormalCompletion13=(_step13=_iterator13.next()).done);_iteratorNormalCompletion13=true){var _ref61;var _step13$value=_step13.value;var key=_step13$value.key;var value=_step13$value.value;if(key.name===id.name){return value.type==='VoidTypeAnnotation'||value.type==='NullLiteralTypeAnnotation'?t.anyTypeAnnotation():value;}}}catch(err){_didIteratorError13=true;_iteratorError13=err;}finally {try{if(!_iteratorNormalCompletion13&&_iterator13.return){_iterator13.return();}}finally {if(_didIteratorError13){throw _iteratorError13;}}}}return t.anyTypeAnnotation();},null);return _ref60(objectAnnotation||path.getTypeAnnotation());}function getComputedMemberExpressionAnnotation(path){function _ref62(_id77){if(!TypeAnnotation(_id77)){throw new TypeError('Function \"getComputedMemberExpressionAnnotation\" return value violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(_id77));}return _id77;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var object=path.get('object');var property=path.get('property');var objectAnnotation=getAnnotation(object);if(objectAnnotation.type==='TypeAnnotation'||objectAnnotation.type==='NullableTypeAnnotation'){objectAnnotation=objectAnnotation.typeAnnotation;}var propertyAnnotation=getAnnotation(property);if(propertyAnnotation.type==='TypeAnnotation'||propertyAnnotation.type==='NullableTypeAnnotation'){propertyAnnotation=propertyAnnotation.typeAnnotation;}var _property$evaluate=property.evaluate();var confident=_property$evaluate.confident;var value=_property$evaluate.value;if(!confident){return _ref62(path.getTypeAnnotation());}switch(objectAnnotation.type){case 'TupleTypeAnnotation':if(objectAnnotation.types.length===0){break;}else if(typeof value==='number'){if(!objectAnnotation.types[value]){throw path.buildCodeFrameError('Invalid computed member expression for tuple: '+humanReadableType(objectAnnotation));}return _ref62(objectAnnotation.types[value]);}else {throw path.buildCodeFrameError('Invalid computed member expression for tuple: '+humanReadableType(objectAnnotation));}break;}return _ref62(path.getTypeAnnotation());}function getFunctionForIdentifier(path){function _ref63(_id78){if(!(typeof _id78==='boolean'||Node(_id78))){throw new TypeError('Function \"getFunctionForIdentifier\" return value violates contract.\\n\\nExpected:\\nbool | Node\\n\\nGot:\\n'+_inspect(_id78));}return _id78;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(path.type!=='Identifier'){return false;}else if(isTypeChecker(path.node,path.scope)||isPolymorphicType(path.node,path.scope)){return false;}var ref=path.scope.getBinding(path.node.name);if(!ref){return false;}return _ref63(t.isFunction(ref.path.parent)&&ref.path.parentPath);} /**\n   * Determine whether the given annotation is for an array.\n   */function isStrictlyArrayAnnotation(annotation){function _ref64(_id79){if(!(_id79==null||typeof _id79==='boolean')){throw new TypeError('Function \"isStrictlyArrayAnnotation\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id79));}return _id79;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}switch(annotation.type){case 'ArrayTypeAnnotation':case 'TupleTypeAnnotation':return true;case 'TypeAnnotation':case 'FunctionTypeParam':return _ref64(isStrictlyArrayAnnotation(annotation.typeAnnotation));case 'GenericTypeAnnotation':return annotation.id.name==='Array'?true:null;case 'UnionTypeAnnotation':return _ref64(annotation.types.every(isStrictlyArrayAnnotation));default:return false;}}function compareMaybeUnion(annotation,comparator){function _ref65(_id80){if(!(_id80==null||typeof _id80==='boolean')){throw new TypeError('Function \"compareMaybeUnion\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id80));}return _id80;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}if(!(typeof comparator==='function')){throw new TypeError('Value of argument \"comparator\" violates contract.\\n\\nExpected:\\n(TypeAnnotation) => ?bool\\n\\nGot:\\n'+_inspect(comparator));}var falseCount=0;_annotation$types=annotation.types;if(!(_annotation$types&&(typeof _annotation$types[Symbol.iterator]==='function'||Array.isArray(_annotation$types)))){throw new TypeError('Expected _annotation$types to be iterable, got '+_inspect(_annotation$types));}var _iteratorNormalCompletion14=true;var _didIteratorError14=false;var _iteratorError14=undefined;try{for(var _iterator14=_annotation$types[Symbol.iterator](),_step14;!(_iteratorNormalCompletion14=(_step14=_iterator14.next()).done);_iteratorNormalCompletion14=true){var _annotation$types;var _type6=_step14.value;var result=comparator(_type6);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError14=true;_iteratorError14=err;}finally {try{if(!_iteratorNormalCompletion14&&_iterator14.return){_iterator14.return();}}finally {if(_didIteratorError14){throw _iteratorError14;}}}if(falseCount===annotation.types.length){return false;}else {return _ref65(null);}} /**\n   * Returns `true` if the annotation is compatible with a number,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeNumberAnnotation(annotation){function _ref66(_id81){if(!(_id81==null||typeof _id81==='boolean')){throw new TypeError('Function \"maybeNumberAnnotation\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id81));}return _id81;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref66(maybeNumberAnnotation(annotation.typeAnnotation));case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'NumericLiteral':return true;case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':return false;default:return _ref66(null);}case 'UnionTypeAnnotation':return _ref66(compareMaybeUnion(annotation,maybeNumberAnnotation));case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return _ref66(null);default:return false;}} /**\n   * Returns `true` if the annotation is compatible with a string,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeStringAnnotation(annotation){function _ref67(_id82){if(!(_id82==null||typeof _id82==='boolean')){throw new TypeError('Function \"maybeStringAnnotation\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id82));}return _id82;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref67(maybeStringAnnotation(annotation.typeAnnotation));case 'StringTypeAnnotation':case 'StringLiteral':return true;case 'StringLiteralTypeAnnotation':return _ref67(null);case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'Number':case 'Boolean':case 'Date':case 'RegExp':return false;default:return _ref67(null);}case 'UnionTypeAnnotation':var falseCount=0;_annotation$types2=annotation.types;if(!(_annotation$types2&&(typeof _annotation$types2[Symbol.iterator]==='function'||Array.isArray(_annotation$types2)))){throw new TypeError('Expected _annotation$types2 to be iterable, got '+_inspect(_annotation$types2));}var _iteratorNormalCompletion15=true;var _didIteratorError15=false;var _iteratorError15=undefined;try{for(var _iterator15=_annotation$types2[Symbol.iterator](),_step15;!(_iteratorNormalCompletion15=(_step15=_iterator15.next()).done);_iteratorNormalCompletion15=true){var _annotation$types2;var _type7=_step15.value;var result=maybeStringAnnotation(_type7);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError15=true;_iteratorError15=err;}finally {try{if(!_iteratorNormalCompletion15&&_iterator15.return){_iterator15.return();}}finally {if(_didIteratorError15){throw _iteratorError15;}}}if(falseCount===annotation.types.length){return false;}else {return _ref67(null);}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return _ref67(null);default:return false;}} /**\n   * Returns `true` if the annotation is compatible with a symbol,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeSymbolAnnotation(annotation){function _ref68(_id83){if(!(_id83==null||typeof _id83==='boolean')){throw new TypeError('Function \"maybeSymbolAnnotation\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id83));}return _id83;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref68(maybeSymbolAnnotation(annotation.typeAnnotation));case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'Number':case 'Boolean':case 'Date':case 'RegExp':return false;case 'Symbol':return true;default:return _ref68(null);}case 'UnionTypeAnnotation':var falseCount=0;_annotation$types3=annotation.types;if(!(_annotation$types3&&(typeof _annotation$types3[Symbol.iterator]==='function'||Array.isArray(_annotation$types3)))){throw new TypeError('Expected _annotation$types3 to be iterable, got '+_inspect(_annotation$types3));}var _iteratorNormalCompletion16=true;var _didIteratorError16=false;var _iteratorError16=undefined;try{for(var _iterator16=_annotation$types3[Symbol.iterator](),_step16;!(_iteratorNormalCompletion16=(_step16=_iterator16.next()).done);_iteratorNormalCompletion16=true){var _annotation$types3;var _type8=_step16.value;var result=maybeSymbolAnnotation(_type8);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError16=true;_iteratorError16=err;}finally {try{if(!_iteratorNormalCompletion16&&_iterator16.return){_iterator16.return();}}finally {if(_didIteratorError16){throw _iteratorError16;}}}if(falseCount===annotation.types.length){return false;}else {return _ref68(null);}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return _ref68(null);default:return false;}} /**\n   * Returns `true` if the annotation is compatible with a boolean,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeBooleanAnnotation(annotation){function _ref69(_id84){if(!(_id84==null||typeof _id84==='boolean')){throw new TypeError('Function \"maybeBooleanAnnotation\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id84));}return _id84;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref69(maybeBooleanAnnotation(annotation.typeAnnotation));case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'BooleanLiteral':return true;case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'String':case 'Number':case 'Date':case 'RegExp':return false;default:return _ref69(null);}case 'UnionTypeAnnotation':var falseCount=0;_annotation$types4=annotation.types;if(!(_annotation$types4&&(typeof _annotation$types4[Symbol.iterator]==='function'||Array.isArray(_annotation$types4)))){throw new TypeError('Expected _annotation$types4 to be iterable, got '+_inspect(_annotation$types4));}var _iteratorNormalCompletion17=true;var _didIteratorError17=false;var _iteratorError17=undefined;try{for(var _iterator17=_annotation$types4[Symbol.iterator](),_step17;!(_iteratorNormalCompletion17=(_step17=_iterator17.next()).done);_iteratorNormalCompletion17=true){var _annotation$types4;var _type9=_step17.value;var result=maybeBooleanAnnotation(_type9);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError17=true;_iteratorError17=err;}finally {try{if(!_iteratorNormalCompletion17&&_iterator17.return){_iterator17.return();}}finally {if(_didIteratorError17){throw _iteratorError17;}}}if(falseCount===annotation.types.length){return false;}else {return _ref69(null);}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return _ref69(null);default:return false;}} /**\n   * Returns `true` if the annotation is compatible with a function,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeFunctionAnnotation(annotation){function _ref70(_id85){if(!(_id85==null||typeof _id85==='boolean')){throw new TypeError('Function \"maybeFunctionAnnotation\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id85));}return _id85;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref70(maybeFunctionAnnotation(annotation.typeAnnotation));case 'FunctionTypeAnnotation':return true;case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Number':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':return false;default:return _ref70(null);}case 'UnionTypeAnnotation':var falseCount=0;_annotation$types5=annotation.types;if(!(_annotation$types5&&(typeof _annotation$types5[Symbol.iterator]==='function'||Array.isArray(_annotation$types5)))){throw new TypeError('Expected _annotation$types5 to be iterable, got '+_inspect(_annotation$types5));}var _iteratorNormalCompletion18=true;var _didIteratorError18=false;var _iteratorError18=undefined;try{for(var _iterator18=_annotation$types5[Symbol.iterator](),_step18;!(_iteratorNormalCompletion18=(_step18=_iterator18.next()).done);_iteratorNormalCompletion18=true){var _annotation$types5;var _type10=_step18.value;var result=maybeFunctionAnnotation(_type10);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError18=true;_iteratorError18=err;}finally {try{if(!_iteratorNormalCompletion18&&_iterator18.return){_iterator18.return();}}finally {if(_didIteratorError18){throw _iteratorError18;}}}if(falseCount===annotation.types.length){return false;}else {return _ref70(null);}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return _ref70(null);default:return false;}} /**\n   * Returns `true` if the annotation is compatible with an undefined or null type,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeNullableAnnotation(annotation){function _ref71(_id86){if(!(_id86==null||typeof _id86==='boolean')){throw new TypeError('Function \"maybeNullableAnnotation\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id86));}return _id86;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}switch(annotation.type){case 'NullableTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'MixedTypeAnnotation':return true;case 'TypeAnnotation':case 'FunctionTypeParam':return _ref71(maybeNullableAnnotation(annotation.typeAnnotation));case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Number':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':return false;case 'Generator':if(annotation.typeParameters&&annotation.typeParameters.params.length>1){return _ref71(maybeNullableAnnotation(annotation.typeParameters.params[1]));}else {return _ref71(null);}default:return _ref71(null);}case 'UnionTypeAnnotation':var falseCount=0;_annotation$types6=annotation.types;if(!(_annotation$types6&&(typeof _annotation$types6[Symbol.iterator]==='function'||Array.isArray(_annotation$types6)))){throw new TypeError('Expected _annotation$types6 to be iterable, got '+_inspect(_annotation$types6));}var _iteratorNormalCompletion19=true;var _didIteratorError19=false;var _iteratorError19=undefined;try{for(var _iterator19=_annotation$types6[Symbol.iterator](),_step19;!(_iteratorNormalCompletion19=(_step19=_iterator19.next()).done);_iteratorNormalCompletion19=true){var _annotation$types6;var _type11=_step19.value;var result=maybeNullableAnnotation(_type11);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError19=true;_iteratorError19=err;}finally {try{if(!_iteratorNormalCompletion19&&_iterator19.return){_iterator19.return();}}finally {if(_didIteratorError19){throw _iteratorError19;}}}if(falseCount===annotation.types.length){return false;}else {return _ref71(null);}default:return false;}} /**\n   * Returns `true` if the annotation is compatible with an object type,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeInstanceOfAnnotation(annotation,expected,typeParameters){function _ref72(_id87){if(!(_id87==null||typeof _id87==='boolean')){throw new TypeError('Function \"maybeInstanceOfAnnotation\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id87));}return _id87;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}if(!Identifier(expected)){throw new TypeError('Value of argument \"expected\" violates contract.\\n\\nExpected:\\nIdentifier\\n\\nGot:\\n'+_inspect(expected));}if(!(Array.isArray(typeParameters)&&typeParameters.every(function(item){return TypeAnnotation(item);}))){throw new TypeError('Value of argument \"typeParameters\" violates contract.\\n\\nExpected:\\nTypeAnnotation[]\\n\\nGot:\\n'+_inspect(typeParameters));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref72(maybeInstanceOfAnnotation(annotation.typeAnnotation,expected,typeParameters));case 'GenericTypeAnnotation':if(annotation.id.name===expected.name){if(typeParameters.length===0){return true;}if(annotation.typeParameters&&annotation.typeParameters.params.length){var trueCount=0;var nullCount=0;for(var i=0;i<typeParameters.length&&i<annotation.typeParameters.params.length;i++){var result=compareAnnotations(typeParameters[i],annotation.typeParameters.params[i]);if(result===false){return false;}else if(result===true){trueCount++;}else {nullCount++;}}return trueCount>0&&nullCount===0?true:null;}}return _ref72(null);case 'UnionTypeAnnotation':var falseCount=0;_annotation$types7=annotation.types;if(!(_annotation$types7&&(typeof _annotation$types7[Symbol.iterator]==='function'||Array.isArray(_annotation$types7)))){throw new TypeError('Expected _annotation$types7 to be iterable, got '+_inspect(_annotation$types7));}var _iteratorNormalCompletion20=true;var _didIteratorError20=false;var _iteratorError20=undefined;try{for(var _iterator20=_annotation$types7[Symbol.iterator](),_step20;!(_iteratorNormalCompletion20=(_step20=_iterator20.next()).done);_iteratorNormalCompletion20=true){var _annotation$types7;var _type12=_step20.value;var _result=maybeInstanceOfAnnotation(_type12,expected,typeParameters);if(_result===true){return true;}else if(_result===false){falseCount++;}}}catch(err){_didIteratorError20=true;_iteratorError20=err;}finally {try{if(!_iteratorNormalCompletion20&&_iterator20.return){_iterator20.return();}}finally {if(_didIteratorError20){throw _iteratorError20;}}}if(falseCount===annotation.types.length){return false;}else {return _ref72(null);}case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':if(expected.name==='Array'||expected.name==='RegExp'||expected.name==='Error'||expected.name==='Function'||expected.name==='String'||expected.name==='Object'){return false;}else {return _ref72(null);}case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':if(expected.name==='Array'||expected.name==='RegExp'||expected.name==='Error'||expected.name==='Function'){return false;}else {return _ref72(null);}case 'FunctionTypeAnnotation':if(expected.name==='Function'){return true;}else {return _ref72(null);}default:return _ref72(null);}} /**\n   * Returns `true` if the annotation is compatible with an array,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeArrayAnnotation(annotation){function _ref73(_id88){if(!(_id88==null||typeof _id88==='boolean')){throw new TypeError('Function \"maybeArrayAnnotation\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id88));}return _id88;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref73(maybeArrayAnnotation(annotation.typeAnnotation));case 'TupleTypeAnnotation':case 'ArrayTypeAnnotation':return true;case 'GenericTypeAnnotation':return annotation.id.name==='Array'?true:null;case 'UnionTypeAnnotation':var falseCount=0;_annotation$types8=annotation.types;if(!(_annotation$types8&&(typeof _annotation$types8[Symbol.iterator]==='function'||Array.isArray(_annotation$types8)))){throw new TypeError('Expected _annotation$types8 to be iterable, got '+_inspect(_annotation$types8));}var _iteratorNormalCompletion21=true;var _didIteratorError21=false;var _iteratorError21=undefined;try{for(var _iterator21=_annotation$types8[Symbol.iterator](),_step21;!(_iteratorNormalCompletion21=(_step21=_iterator21.next()).done);_iteratorNormalCompletion21=true){var _annotation$types8;var _type13=_step21.value;var result=maybeArrayAnnotation(_type13);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError21=true;_iteratorError21=err;}finally {try{if(!_iteratorNormalCompletion21&&_iterator21.return){_iterator21.return();}}finally {if(_didIteratorError21){throw _iteratorError21;}}}if(falseCount===annotation.types.length){return false;}else {return _ref73(null);}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return _ref73(null);default:return false;}} /**\n   * Returns `true` if the annotation is compatible with an iterable,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeIterableAnnotation(annotation){function _ref74(_id89){if(!(_id89==null||typeof _id89==='boolean')){throw new TypeError('Function \"maybeIterableAnnotation\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id89));}return _id89;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref74(maybeIterableAnnotation(annotation.typeAnnotation));case 'TupleTypeAnnotation':case 'ArrayTypeAnnotation':return true;case 'GenericTypeAnnotation':return annotation.id.name==='Iterable'?true:null;case 'UnionTypeAnnotation':var falseCount=0;_annotation$types9=annotation.types;if(!(_annotation$types9&&(typeof _annotation$types9[Symbol.iterator]==='function'||Array.isArray(_annotation$types9)))){throw new TypeError('Expected _annotation$types9 to be iterable, got '+_inspect(_annotation$types9));}var _iteratorNormalCompletion22=true;var _didIteratorError22=false;var _iteratorError22=undefined;try{for(var _iterator22=_annotation$types9[Symbol.iterator](),_step22;!(_iteratorNormalCompletion22=(_step22=_iterator22.next()).done);_iteratorNormalCompletion22=true){var _annotation$types9;var _type14=_step22.value;var result=maybeIterableAnnotation(_type14);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError22=true;_iteratorError22=err;}finally {try{if(!_iteratorNormalCompletion22&&_iterator22.return){_iterator22.return();}}finally {if(_didIteratorError22){throw _iteratorError22;}}}if(falseCount===annotation.types.length){return false;}else {return _ref74(null);}case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':return false;default:return _ref74(null);}} /**\n   * Returns `true` if the annotation is compatible with a tuple,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeTupleAnnotation(annotation){function _ref75(_id90){if(!(_id90==null||typeof _id90==='boolean')){throw new TypeError('Function \"maybeTupleAnnotation\" return value violates contract.\\n\\nExpected:\\n?bool\\n\\nGot:\\n'+_inspect(_id90));}return _id90;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref75(maybeTupleAnnotation(annotation.typeAnnotation));case 'TupleTypeAnnotation':return true;case 'UnionTypeAnnotation':var falseCount=0;_annotation$types10=annotation.types;if(!(_annotation$types10&&(typeof _annotation$types10[Symbol.iterator]==='function'||Array.isArray(_annotation$types10)))){throw new TypeError('Expected _annotation$types10 to be iterable, got '+_inspect(_annotation$types10));}var _iteratorNormalCompletion23=true;var _didIteratorError23=false;var _iteratorError23=undefined;try{for(var _iterator23=_annotation$types10[Symbol.iterator](),_step23;!(_iteratorNormalCompletion23=(_step23=_iterator23.next()).done);_iteratorNormalCompletion23=true){var _annotation$types10;var _type15=_step23.value;var result=maybeTupleAnnotation(_type15);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError23=true;_iteratorError23=err;}finally {try{if(!_iteratorNormalCompletion23&&_iterator23.return){_iterator23.return();}}finally {if(_didIteratorError23){throw _iteratorError23;}}}if(falseCount===annotation.types.length){return false;}else {return _ref75(null);}case 'GenericTypeAnnotation':case 'AnyTypeAnnotation':case 'ArrayTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return _ref75(null);default:return false;}}function humanReadableType(annotation){function _ref76(_id91){if(!(typeof _id91==='string')){throw new TypeError('Function \"humanReadableType\" return value violates contract.\\n\\nExpected:\\nstring\\n\\nGot:\\n'+_inspect(_id91));}return _id91;}if(!(Node(annotation)||TypeAnnotation(annotation))){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\nNode | TypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':return _ref76(humanReadableType(annotation.typeAnnotation));case 'FunctionTypeAnnotation': // @fixme babel doesn't seem to like generating FunctionTypeAnnotations yet\nreturn '('+annotation.params.map(humanReadableType).join(', ')+') => '+humanReadableType(annotation.returnType);case 'GenericTypeAnnotation':var path=getNodePath(annotation);var checker=path&&getTypeChecker(annotation.id,path.scope);if(checker&&checker.node.savedTypeAnnotation){return _ref76(humanReadableType(checker.node.savedTypeAnnotation));}else {return _ref76((0,_babelGenerator2.default)(annotation).code);}default:return _ref76((0,_babelGenerator2.default)(annotation).code);}} /**\n   * Get the path directly from a node.\n   */function getNodePath(node){function _ref77(_id92){if(!(_id92==null||NodePath(_id92))){throw new TypeError('Function \"getNodePath\" return value violates contract.\\n\\nExpected:\\n?NodePath\\n\\nGot:\\n'+_inspect(_id92));}return _id92;}if(!Node(node)){throw new TypeError('Value of argument \"node\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(node));}if(node._paths&&node._paths.length){return _ref77(node._paths[0]);}else {return _ref77(null);}}function getTypeChecker(id,scope){function _ref78(_id93){if(!(NodePath(_id93)||_id93===false)){throw new TypeError('Function \"getTypeChecker\" return value violates contract.\\n\\nExpected:\\nNodePath | false\\n\\nGot:\\n'+_inspect(_id93));}return _id93;}if(!(Identifier(id)||QualifiedTypeIdentifier(id))){throw new TypeError('Value of argument \"id\" violates contract.\\n\\nExpected:\\nIdentifier | QualifiedTypeIdentifier\\n\\nGot:\\n'+_inspect(id));}if(!Scope(scope)){throw new TypeError('Value of argument \"scope\" violates contract.\\n\\nExpected:\\nScope\\n\\nGot:\\n'+_inspect(scope));}var checker=scope.getData('typechecker:'+id.name);if(checker){return _ref78(checker);}return false;}function isTypeChecker(id,scope){function _ref79(_id94){if(!(typeof _id94==='boolean')){throw new TypeError('Function \"isTypeChecker\" return value violates contract.\\n\\nExpected:\\nbool\\n\\nGot:\\n'+_inspect(_id94));}return _id94;}if(!(Identifier(id)||QualifiedTypeIdentifier(id))){throw new TypeError('Value of argument \"id\" violates contract.\\n\\nExpected:\\nIdentifier | QualifiedTypeIdentifier\\n\\nGot:\\n'+_inspect(id));}if(!Scope(scope)){throw new TypeError('Value of argument \"scope\" violates contract.\\n\\nExpected:\\nScope\\n\\nGot:\\n'+_inspect(scope));}return _ref79(scope.getData('typechecker:'+id.name)!==undefined);}function isPolymorphicType(id,scope){function _ref80(_id95){if(!(typeof _id95==='boolean')){throw new TypeError('Function \"isPolymorphicType\" return value violates contract.\\n\\nExpected:\\nbool\\n\\nGot:\\n'+_inspect(_id95));}return _id95;}if(!(Identifier(id)||QualifiedTypeIdentifier(id))){throw new TypeError('Value of argument \"id\" violates contract.\\n\\nExpected:\\nIdentifier | QualifiedTypeIdentifier\\n\\nGot:\\n'+_inspect(id));}if(!Scope(scope)){throw new TypeError('Value of argument \"scope\" violates contract.\\n\\nExpected:\\nScope\\n\\nGot:\\n'+_inspect(scope));}return _ref80(scope.getData('typeparam:'+id.name)!==undefined);}function getPolymorphicType(id,scope){function _ref81(_id96){if(!(_id96==null||Node(_id96))){throw new TypeError('Function \"getPolymorphicType\" return value violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(_id96));}return _id96;}if(!(Identifier(id)||QualifiedTypeIdentifier(id))){throw new TypeError('Value of argument \"id\" violates contract.\\n\\nExpected:\\nIdentifier | QualifiedTypeIdentifier\\n\\nGot:\\n'+_inspect(id));}if(!Scope(scope)){throw new TypeError('Value of argument \"scope\" violates contract.\\n\\nExpected:\\nScope\\n\\nGot:\\n'+_inspect(scope));}var path=scope.getData('typeparam:'+id.name);if(path){return _ref81(path.node);}}function collectParamChecks(path,context){function _ref82(_id97){if(!(Array.isArray(_id97)&&_id97.every(function(item){return Node(item);}))){throw new TypeError('Function \"collectParamChecks\" return value violates contract.\\n\\nExpected:\\nNode[]\\n\\nGot:\\n'+_inspect(_id97));}return _id97;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument \"context\" violates contract.\\n\\nExpected:\\nVisitorContext\\n\\nGot:\\n'+_inspect(context));}return _ref82(path.get('params').map(function(param){var node=param.node;if(node.type==='AssignmentPattern'){if(node.left.typeAnnotation){return createDefaultParamGuard(param,context);}}else if(node.type==='RestElement'){if(node.typeAnnotation){return createRestParamGuard(param,context);}}else if(node.typeAnnotation){return createParamGuard(param,context);}}).filter(identity));}function createParamGuard(path,context){function _ref83(_id98){if(!(_id98==null||Node(_id98))){throw new TypeError('Function \"createParamGuard\" return value violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(_id98));}return _id98;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument \"context\" violates contract.\\n\\nExpected:\\nVisitorContext\\n\\nGot:\\n'+_inspect(context));}var node=path.node;var scope=path.scope;node.hasBeenTypeChecked=true;node.savedTypeAnnotation=node.typeAnnotation;var checkable=void 0;if(node.type==='ObjectPattern'){node.name=path.key;checkable=t.memberExpression(t.identifier('arguments'),t.numericLiteral(path.key),true);}else {checkable=node;}var check=checkAnnotation(checkable,node.typeAnnotation,scope);if(!check){return;}if(node.optional){check=t.logicalExpression('||',checks.undefined({input:checkable}),check);}var message=paramTypeErrorMessage(checkable,context,node.typeAnnotation);return _ref83(guard({check:check,message:message}));}function createDefaultParamGuard(path,context){function _ref84(_id99){if(!(_id99==null||Node(_id99))){throw new TypeError('Function \"createDefaultParamGuard\" return value violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(_id99));}return _id99;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument \"context\" violates contract.\\n\\nExpected:\\nVisitorContext\\n\\nGot:\\n'+_inspect(context));}var node=path.node;var scope=path.scope;var id=node.left;var value=node.right;var ok=staticCheckAnnotation(path.get('right'),id.typeAnnotation);if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid default value for argument \"'+id.name+'\".',id.typeAnnotation,getAnnotation(path.get('right'))));}return _ref84(createParamGuard(path.get('left'),context));}function createRestParamGuard(path,context){function _ref85(_id100){if(!(_id100==null||Node(_id100))){throw new TypeError('Function \"createRestParamGuard\" return value violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(_id100));}return _id100;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument \"context\" violates contract.\\n\\nExpected:\\nVisitorContext\\n\\nGot:\\n'+_inspect(context));}var node=path.node;var scope=path.scope;var id=node.argument;id.hasBeenTypeChecked=true;node.savedTypeAnnotation=node.typeAnnotation;if(isStrictlyArrayAnnotation(node.typeAnnotation)===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid type annotation for rest argument \"'+id.name+'\".',t.genericTypeAnnotation(t.identifier('Array')),node.typeAnnotation));}var check=checkAnnotation(id,node.typeAnnotation,scope);if(!check){return;}if(node.optional){check=t.logicalExpression('||',checks.undefined({input:id}),check);}var message=paramTypeErrorMessage(id,context,node.typeAnnotation);return _ref85(guard({check:check,message:message}));}function returnTypeErrorMessage(path,fn,id,context){function _ref86(_id101){if(!Node(_id101)){throw new TypeError('Function \"returnTypeErrorMessage\" return value violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(_id101));}return _id101;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(!Node(fn)){throw new TypeError('Value of argument \"fn\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(fn));}if(!(id==null||Identifier(id)||Literal(id))){throw new TypeError('Value of argument \"id\" violates contract.\\n\\nExpected:\\n?Identifier | Literal\\n\\nGot:\\n'+_inspect(id));}if(!VisitorContext(context)){throw new TypeError('Value of argument \"context\" violates contract.\\n\\nExpected:\\nVisitorContext\\n\\nGot:\\n'+_inspect(context));}var node=path.node;var scope=path.scope;var name=fn.id?fn.id.name:'';var annotation=fn.returnType;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(fn.generator&&isGeneratorAnnotation(annotation)&&annotation.typeParameters&&annotation.typeParameters.params.length>1){annotation=annotation.typeParameters.params[1];}var message='Function '+(name?'\"'+name+'\" ':'')+'return value violates contract.\\n\\nExpected:\\n'+humanReadableType(annotation)+'\\n\\nGot:\\n';return _ref86(t.binaryExpression('+',t.stringLiteral(message),id?readableName({inspect:context.inspect,input:id}):node.argument?readableName({inspect:context.inspect,input:node.argument}):t.stringLiteral('undefined')));}function yieldTypeErrorMessage(fn,annotation,id,context){function _ref87(_id102){if(!Node(_id102)){throw new TypeError('Function \"yieldTypeErrorMessage\" return value violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(_id102));}return _id102;}if(!Node(fn)){throw new TypeError('Value of argument \"fn\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(fn));}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}if(!(Identifier(id)||Literal(id))){throw new TypeError('Value of argument \"id\" violates contract.\\n\\nExpected:\\nIdentifier | Literal\\n\\nGot:\\n'+_inspect(id));}if(!VisitorContext(context)){throw new TypeError('Value of argument \"context\" violates contract.\\n\\nExpected:\\nVisitorContext\\n\\nGot:\\n'+_inspect(context));}var name=fn.id?fn.id.name:'';var message='Function '+(name?'\"'+name+'\" ':'')+'yielded an invalid value.\\n\\nExpected:\\n'+humanReadableType(annotation)+'\\n\\nGot:\\n';return _ref87(t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:id})));}function yieldNextTypeErrorMessage(fn,annotation,id,context){function _ref88(_id103){if(!Node(_id103)){throw new TypeError('Function \"yieldNextTypeErrorMessage\" return value violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(_id103));}return _id103;}if(!Node(fn)){throw new TypeError('Value of argument \"fn\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(fn));}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}if(!(Identifier(id)||Literal(id))){throw new TypeError('Value of argument \"id\" violates contract.\\n\\nExpected:\\nIdentifier | Literal\\n\\nGot:\\n'+_inspect(id));}if(!VisitorContext(context)){throw new TypeError('Value of argument \"context\" violates contract.\\n\\nExpected:\\nVisitorContext\\n\\nGot:\\n'+_inspect(context));}var name=fn.id?fn.id.name:'';var message='Generator '+(name?'\"'+name+'\" ':'')+'received an invalid next value.\\n\\nExpected:\\n'+humanReadableType(annotation)+'\\n\\nGot:\\n';return _ref88(t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:id})));}function paramTypeErrorMessage(node,context){var typeAnnotation=arguments.length<=2||arguments[2]===undefined?node.typeAnnotation:arguments[2];function _ref89(_id104){if(!Node(_id104)){throw new TypeError('Function \"paramTypeErrorMessage\" return value violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(_id104));}return _id104;}if(!Node(node)){throw new TypeError('Value of argument \"node\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(node));}if(!VisitorContext(context)){throw new TypeError('Value of argument \"context\" violates contract.\\n\\nExpected:\\nVisitorContext\\n\\nGot:\\n'+_inspect(context));}if(!TypeAnnotation(typeAnnotation)){throw new TypeError('Value of argument \"typeAnnotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(typeAnnotation));}var name=node.name;if(node.type==='MemberExpression'&&node.object.name==='arguments'){name=node.property.value;}var message='Value of '+(node.optional?'optional ':'')+'argument '+JSON.stringify(name)+' violates contract.\\n\\nExpected:\\n'+humanReadableType(typeAnnotation)+'\\n\\nGot:\\n';return _ref89(t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:node})));}function varTypeErrorMessage(node,context){function _ref90(_id105){if(!Node(_id105)){throw new TypeError('Function \"varTypeErrorMessage\" return value violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(_id105));}return _id105;}if(!Node(node)){throw new TypeError('Value of argument \"node\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(node));}if(!VisitorContext(context)){throw new TypeError('Value of argument \"context\" violates contract.\\n\\nExpected:\\nVisitorContext\\n\\nGot:\\n'+_inspect(context));}var annotation=node.typeAnnotation;if(!TypeAnnotation(annotation)){throw new TypeError('Value of variable \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}if(node.type==='Identifier'){var _name3=node.name;var message='Value of variable \"'+_name3+'\" violates contract.\\n\\nExpected:\\n'+humanReadableType(annotation)+'\\n\\nGot:\\n';return _ref90(t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:node})));}else {var _message='Value of \"'+humanReadableType(node)+'\" violates contract.\\n\\nExpected:\\n'+humanReadableType(annotation)+'\\n\\nGot:\\n';return _ref90(t.binaryExpression('+',t.stringLiteral(_message),readableName({inspect:context.inspect,input:node})));}} /**\n   * Create a React property validator\n   */function generatePropType(annotation,scope,context){if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}if(!Scope(scope)){throw new TypeError('Value of argument \"scope\" violates contract.\\n\\nExpected:\\nScope\\n\\nGot:\\n'+_inspect(scope));}if(!VisitorContext(context)){throw new TypeError('Value of argument \"context\" violates contract.\\n\\nExpected:\\nVisitorContext\\n\\nGot:\\n'+_inspect(context));}var prop=t.identifier('prop');var check=checkAnnotation(prop,annotation,scope);if(check){return propType({check:check,prop:prop,expected:t.stringLiteral(humanReadableType(annotation)),got:readableName({inspect:context.inspect,input:prop})});}else {return t.functionExpression(null,[],t.blockStatement([]));}} /**\n   * Determine whether the given node can produce purely boolean results.\n   */function isBooleanExpression(node){if(!Node(node)){throw new TypeError('Value of argument \"node\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(node));}if(node.type==='BinaryExpression'&&BOOLEAN_BINARY_OPERATORS.indexOf(node.operator)>-1){return true;}else if(node.type==='LogicalExpression'){return isBooleanExpression(node.left)&&isBooleanExpression(node.right);}else {return false;}} /**\n   * Convert type specifier to expression.\n   */function createTypeExpression(node){function _ref91(_id106){if(!(_id106 instanceof Object)){throw new TypeError('Function \"createTypeExpression\" return value violates contract.\\n\\nExpected:\\nObject\\n\\nGot:\\n'+_inspect(_id106));}return _id106;}if(!Node(node)){throw new TypeError('Value of argument \"node\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(node));}if(node.type=='Identifier'){return _ref91(node);}else if(node.type=='QualifiedTypeIdentifier'){return _ref91(t.memberExpression(createTypeExpression(node.qualification),createTypeExpression(node.id)));}throw this.errorWithNode('Unsupported type: '+node.type);} /**\n   * Get name of a type as a string.\n   */function getTypeName(node){function _ref92(_id107){if(!(typeof _id107==='string')){throw new TypeError('Function \"getTypeName\" return value violates contract.\\n\\nExpected:\\nstring\\n\\nGot:\\n'+_inspect(_id107));}return _id107;}if(!Node(node)){throw new TypeError('Value of argument \"node\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(node));}if(node.type=='Identifier'){return _ref92(node.name);}else if(node.type=='QualifiedTypeIdentifier'){return _ref92(getTypeName(node.qualification)+'.'+getTypeName(node.id));}throw this.errorWithNode('Unsupported type: '+node.type);} /**\n   * Union two arrays.\n   */function union(arr1,arr2){if(!Array.isArray(arr1)){throw new TypeError('Value of argument \"arr1\" violates contract.\\n\\nExpected:\\nArray\\n\\nGot:\\n'+_inspect(arr1));}if(!Array.isArray(arr2)){throw new TypeError('Value of argument \"arr2\" violates contract.\\n\\nExpected:\\nArray\\n\\nGot:\\n'+_inspect(arr2));}for(var i=0;i<arr2.length;i++){var item=arr2[i];if(arr1.indexOf(item)===-1){arr1.push(item);}}return arr1;} /**\n   * Determine whether the given annotation allows any value.\n   */function allowsAny(annotation){function _ref94(_id109){if(!(typeof _id109==='boolean')){throw new TypeError('Function \"allowsAny\" return value violates contract.\\n\\nExpected:\\nbool\\n\\nGot:\\n'+_inspect(_id109));}return _id109;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument \"annotation\" violates contract.\\n\\nExpected:\\nTypeAnnotation\\n\\nGot:\\n'+_inspect(annotation));}if(annotation.type==='TypeAnnotation'||annotation.type==='NullableTypeAnnotation'){return _ref94(allowsAny(annotation.typeAnnotation));}else if(annotation.type==='AnyTypeAnnotation'||annotation.type==='MixedTypeAnnotation'){return true;}else if(annotation.type==='UnionTypeAnnotation'){return _ref94(annotation.types.some(allowsAny));}else {return false;}} /**\n   * Determine whether a given node is nully (null or undefined).\n   */function isNodeNully(node){if(!(node==null||Node(node))){throw new TypeError('Value of argument \"node\" violates contract.\\n\\nExpected:\\n?Node\\n\\nGot:\\n'+_inspect(node));}if(node==null){return true;}else if(node.type==='Identifier'&&node.name==='undefined'){return true;}else if(node.type==='Literal'&&node.value===null){return true;}else if(node.type==='UnaryExpression'&&node.operator==='void'){return true;}else {return false;}} /**\n   * Determine whether the file should be checked\n   */function mustCheckFile(path,opts){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(path.node.leadingComments&&path.node.leadingComments.length){return opts.only&&!skipEnvironment(path.node.leadingComments,opts);}return false;} /**\n   * Determine whether the file should be skipped, based on the comments attached to the given node.\n   */function maybeSkipFile(path,opts){function _ref97(_id112){if(!(typeof _id112==='boolean')){throw new TypeError('Function \"maybeSkipFile\" return value violates contract.\\n\\nExpected:\\nbool\\n\\nGot:\\n'+_inspect(_id112));}return _id112;}if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}if(path.node.leadingComments&&path.node.leadingComments.length){if(skipEnvironment(path.node.leadingComments,opts)){return true;}return _ref97(path.node.leadingComments.some(function(comment){return PRAGMA_IGNORE_FILE.test(comment.value);}));}return false;} /**\n   * Maybe skip the given path if it has a relevant pragma.\n   */function maybeSkip(path){if(!NodePath(path)){throw new TypeError('Value of argument \"path\" violates contract.\\n\\nExpected:\\nNodePath\\n\\nGot:\\n'+_inspect(path));}var node=path.node;if(node.hasBeenTypeChecked){return true;}if(node.leadingComments&&node.leadingComments.length){var comment=node.leadingComments[node.leadingComments.length-1];if(PRAGMA_IGNORE_STATEMENT.test(comment.value)){path.skip();return true;}}return false;} /**\n   * A function that returns its first argument, useful when filtering.\n   */function identity(input){return input;}function getExpression(node){function _ref100(_id115){if(!Node(_id115)){throw new TypeError('Function \"getExpression\" return value violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(_id115));}return _id115;}if(!Node(node)){throw new TypeError('Value of argument \"node\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(node));}return _ref100(t.isExpressionStatement(node)?node.expression:node);}function expression(input){function _ref101(_id116){if(!(typeof _id116==='function')){throw new TypeError('Function \"expression\" return value violates contract.\\n\\nExpected:\\nFunction\\n\\nGot:\\n'+_inspect(_id116));}return _id116;}if(!(typeof input==='string')){throw new TypeError('Value of argument \"input\" violates contract.\\n\\nExpected:\\nstring\\n\\nGot:\\n'+_inspect(input));}var fn=template(input);if(!(typeof fn==='function')){throw new TypeError('Value of variable \"fn\" violates contract.\\n\\nExpected:\\nFunction\\n\\nGot:\\n'+_inspect(fn));}return _ref101(function(){var node=fn.apply(undefined,arguments);if(!Node(node)){throw new TypeError('Value of variable \"node\" violates contract.\\n\\nExpected:\\nNode\\n\\nGot:\\n'+_inspect(node));}return getExpression(node);});}};var _babelGenerator=require('babel-generator');var _babelGenerator2=_interopRequireDefault(_babelGenerator);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else {return Array.from(arr);}}var Node=function(){function Node(input){return input!=null&&typeof input.type==='string';};Object.defineProperty(Node,Symbol.hasInstance,{value:function value(input){return Node(input);}});return Node;}();var Literal=function(){function Literal(input){return input!=null&&(input.type==='StringLiteral'||input.type==='BooleanLiteral'||input.type==='NumericLiteral'||input.type==='NullLiteral'||input.type==='RegExpLiteral');};Object.defineProperty(Literal,Symbol.hasInstance,{value:function value(input){return Literal(input);}});return Literal;}();var Identifier=function(){function Identifier(input){return input!=null&&typeof input.type==='string'&&typeof input.name==='string';};Object.defineProperty(Identifier,Symbol.hasInstance,{value:function value(input){return Identifier(input);}});return Identifier;}();var QualifiedTypeIdentifier=function(){function QualifiedTypeIdentifier(input){return input!=null&&Identifier(input.id)&&(Identifier(input.qualification)||QualifiedTypeIdentifier(input.qualification));};Object.defineProperty(QualifiedTypeIdentifier,Symbol.hasInstance,{value:function value(input){return QualifiedTypeIdentifier(input);}});return QualifiedTypeIdentifier;}();var TypeAnnotation=function(){function TypeAnnotation(input){return input!=null&&typeof input.type==='string';};Object.defineProperty(TypeAnnotation,Symbol.hasInstance,{value:function value(input){return TypeAnnotation(input);}});return TypeAnnotation;}();var VisitorContext=function(){function VisitorContext(input){return input!=null&&Identifier(input.inspect);};Object.defineProperty(VisitorContext,Symbol.hasInstance,{value:function value(input){return VisitorContext(input);}});return VisitorContext;}();var StringLiteralTypeAnnotation=function(){function StringLiteralTypeAnnotation(input){return input!=null&&input.type==='StringLiteralTypeAnnotation'&&TypeAnnotation(input);};Object.defineProperty(StringLiteralTypeAnnotation,Symbol.hasInstance,{value:function value(input){return StringLiteralTypeAnnotation(input);}});return StringLiteralTypeAnnotation;}();var NumericLiteralTypeAnnotation=function(){function NumericLiteralTypeAnnotation(input){return input!=null&&input.type==='NumericLiteralTypeAnnotation'&&TypeAnnotation(input);};Object.defineProperty(NumericLiteralTypeAnnotation,Symbol.hasInstance,{value:function value(input){return NumericLiteralTypeAnnotation(input);}});return NumericLiteralTypeAnnotation;}();var BooleanLiteralTypeAnnotation=function(){function BooleanLiteralTypeAnnotation(input){return input!=null&&input.type==='BooleanLiteralTypeAnnotation'&&TypeAnnotation(input);};Object.defineProperty(BooleanLiteralTypeAnnotation,Symbol.hasInstance,{value:function value(input){return BooleanLiteralTypeAnnotation(input);}});return BooleanLiteralTypeAnnotation;}();var Scope=function(){function Scope(input){return input!=null&&(typeof input==='undefined'?'undefined':_typeof(input))==='object';};Object.defineProperty(Scope,Symbol.hasInstance,{value:function value(input){return Scope(input);}});return Scope;}();var NodePath=function(){function NodePath(input){return input!=null&&typeof input.type==='string'&&Node(input.node)&&Scope(input.scope);};Object.defineProperty(NodePath,Symbol.hasInstance,{value:function value(input){return NodePath(input);}});return NodePath;}(); /**\n * # Typecheck Transformer\n */function _inspect(input,depth){var maxDepth=4;var maxKeys=15;if(depth===undefined){depth=0;}depth+=1;if(input===null){return 'null';}else if(input===undefined){return 'void';}else if(typeof input==='string'||typeof input==='number'||typeof input==='boolean'){return typeof input==='undefined'?'undefined':_typeof(input);}else if(Array.isArray(input)){if(input.length>0){var _ret=function(){if(depth>maxDepth)return {v:'[...]'};var first=_inspect(input[0],depth);if(input.every(function(item){return _inspect(item,depth)===first;})){return {v:first.trim()+'[]'};}else {return {v:'['+input.slice(0,maxKeys).map(function(item){return _inspect(item,depth);}).join(', ')+(input.length>=maxKeys?', ...':'')+']'};}}();if((typeof _ret==='undefined'?'undefined':_typeof(_ret))===\"object\")return _ret.v;}else {return 'Array';}}else {var keys=Object.keys(input);if(!keys.length){if(input.constructor&&input.constructor.name&&input.constructor.name!=='Object'){return input.constructor.name;}else {return 'Object';}}if(depth>maxDepth)return '{...}';var indent='  '.repeat(depth-1);var entries=keys.slice(0,maxKeys).map(function(key){return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key)?key:JSON.stringify(key))+': '+_inspect(input[key],depth)+';';}).join('\\n  '+indent);if(keys.length>=maxKeys){entries+='\\n  '+indent+'...';}if(input.constructor&&input.constructor.name&&input.constructor.name!=='Object'){return input.constructor.name+' {\\n  '+indent+entries+'\\n'+indent+'}';}else {return '{\\n  '+indent+entries+'\\n'+indent+'}';}}}","/home/travis/build/npmtest/node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/inferers.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.default = make;\n/**\n * Register the builtin type inferers and return a function which can infer the type of\n * a given node path.\n */\nfunction make(_ref) {\n  var t = _ref.types;\n  var template = _ref.template;\n\n  var INFERENCE_TYPES = {};\n\n  /**\n   * Register a new type inference for the given node type.\n   */\n  function register(type, fn) {\n    INFERENCE_TYPES[type] = fn;\n  }\n\n  /**\n   * Infer the type of the given node path and return an annotation.\n   */\n  function inferType(path) {\n    var inferer = INFERENCE_TYPES[path.type];\n    if (inferer) {\n      return inferer(path);\n    } else {\n      console.log('Unsupported Type: ' + path.type);\n      return path.getTypeAnnotation() || t.anyTypeAnnotation();\n    }\n  }\n\n  function lookupGlobalIdentifier(name) {\n    switch (name) {\n      case 'Symbol':\n        return t.functionTypeAnnotation(null, [], null, t.anyTypeAnnotation());\n        return t.functionTypeAnnotation(null, [t.functionTypeParam(t.identifier('key'), t.stringTypeAnnotation())], null, t.anyTypeAnnotation() //t.genericTypeAnnotation(t.identifier('Symbol'))\n        );\n      default:\n        return t.anyTypeAnnotation();\n    }\n  }\n\n  register('ObjectExpression', function (path) {\n    var _path$get$reduce = path.get('properties').reduce(function (_ref2, prop) {\n      var _ref3 = _slicedToArray(_ref2, 2);\n\n      var properties = _ref3[0];\n      var indexers = _ref3[1];\n\n      if (prop.node.computed) {\n        var keyType = inferType(prop.get('key'));\n        if (keyType.type === 'AnyTypeAnnotation') {\n          keyType = t.stringTypeAnnotation();\n        }\n        indexers.push(t.objectTypeIndexer(t.identifier('key'), keyType, inferType(prop.get('value'))));\n      } else {\n        properties.push(t.objectTypeProperty(prop.node.key, inferType(prop.get('value'))));\n      }\n      return [properties, indexers];\n    }, [[], []]);\n\n    var _path$get$reduce2 = _slicedToArray(_path$get$reduce, 2);\n\n    var properties = _path$get$reduce2[0];\n    var indexers = _path$get$reduce2[1];\n\n\n    return t.objectTypeAnnotation(properties, indexers);\n  });\n\n  register('CallExpression', function (path) {\n    var callee = path.get('callee');\n    var annotation = inferType(callee);\n    dump(annotation);\n    return t.anyTypeAnnotation();\n  });\n\n  register('Identifier', function (path) {\n    var binding = path.scope.getBinding(path.node.name);\n    if (!binding) {\n      return lookupGlobalIdentifier(path.node.name);\n    } else {\n      console.log(binding);\n    }\n  });\n\n  return inferType;\n}","/home/travis/build/npmtest/node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/old_index.js":"'use strict';Object.defineProperty(exports,\"__esModule\",{value:true});var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally {try{if(!_n&&_i[\"return\"])_i[\"return\"]();}finally {if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else {throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");}};}(); /**\n * # Typecheck Transformer\n */exports.default=function(_ref){var t=_ref.types;var template=_ref.template; /**\n   * Binary Operators that can only produce boolean results.\n   */var BOOLEAN_BINARY_OPERATORS=['==','===','>=','<=','>','<','instanceof'];var checks=createChecks();var staticChecks=createStaticChecks();var checkIsArray=expression('Array.isArray(input)');var checkIsMap=expression('input instanceof Map');var checkIsSet=expression('input instanceof Set');var checkIsClass=expression('typeof input === \\'function\\' && input.prototype && input.prototype.constructor === input');var checkIsGenerator=expression('typeof input === \\'function\\' && input.generator');var checkIsIterable=expression('input && (typeof input[Symbol.iterator] === \\'function\\' || Array.isArray(input))');var checkIsObject=expression('input != null && typeof input === \\'object\\'');var checkNotNull=expression('input != null');var checkEquals=expression('input === expected');var declareTypeChecker=template('\\n    const id = (function () {\\n      function id (input) {\\n        return check;\\n      };\\n      Object.defineProperty(id, Symbol.hasInstance, {\\n        value: function (input) {\\n          return id(input);\\n        }\\n      });\\n      return id;\\n    })();\\n  ');var guard=template('\\n    if (!check) {\\n      throw new TypeError(message);\\n    }\\n  ');var thrower=template('\\n    if (check) {\\n      ret;\\n    }\\n    else {\\n      throw new TypeError(message);\\n    }\\n  ');var guardInline=expression('\\n    (id => {\\n      if (!check) {\\n        throw new TypeError(message);\\n      }\\n      return id;\\n    })(input)\\n  ');var guardFn=expression('\\n    function name (id) {\\n      if (!check) {\\n        throw new TypeError(message);\\n      }\\n      return id;\\n    }\\n  ');var readableName=expression('\\n    inspect(input)\\n  ');var checkMapKeys=expression('\\n    input instanceof Map && Array.from(input.keys()).every(key => keyCheck)\\n  ');var checkMapValues=expression('\\n    input instanceof Map && Array.from(input.values()).every(value => valueCheck)\\n  ');var checkMapEntries=expression('\\n    input instanceof Map && Array.from(input).every(([key, value]) => keyCheck && valueCheck)\\n  ');var checkSetEntries=expression('\\n    input instanceof Set && Array.from(input).every(value => valueCheck)\\n  ');var checkObjectIndexers=expression('\\n    Object.keys(input).every(key => {\\n      const value = input[key];\\n      if (~fixedKeys.indexOf(key)) {\\n        return true;\\n      }\\n      else {\\n        return check;\\n      }\\n    });\\n  ');var checkObjectIndexersNoFixed=expression('\\n    Object.keys(input).every(key => {\\n      const value = input[key];\\n      return check;\\n    });\\n  ');var propType=expression('\\n    (function(props, name, component) {\\n      var prop = props[name];\\n      if(!check) {\\n        return new Error(\\n          \"Invalid prop `\" + name + \"` supplied to `\" + component\\n          + \"`.\\\\n\\\\nExpected:\\\\n\" + expected + \"\\\\n\\\\nGot:\\\\n\" + got + \"\\\\n\\\\n\"\\n        );\\n      }\\n    })\\n  ');var PRAGMA_IGNORE_STATEMENT=/typecheck:\\s*ignore\\s+statement/i;var PRAGMA_IGNORE_FILE=/typecheck:\\s*ignore\\s+file/i;function skipEnvironment(comments,opts){if(!opts.only){return false;}var envs=pragmaEnvironments(comments);return !opts.only.some(function(env){return envs[env];});}function pragmaEnvironments(comments){var pragma=/@typecheck:\\s*(.+)/;var environments={};comments.forEach(function(comment){var m=comment.value.match(pragma);if(m){m[1].split(',').forEach(function(env){return environments[env.trim()]=true;});}});return environments;}var visitors={Statement:function Statement(path){maybeSkip(path);},TypeAlias:function TypeAlias(path){if(maybeSkip(path)){return;}path.replaceWith(createTypeAliasChecks(path));},InterfaceDeclaration:function InterfaceDeclaration(path){if(maybeSkip(path)){return;}path.replaceWith(createInterfaceChecks(path));},ExportNamedDeclaration:function ExportNamedDeclaration(path){if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;if(node.declaration&&node.declaration.type==='TypeAlias'){path.replaceWith(t.exportNamedDeclaration(createTypeAliasChecks(path.get('declaration')),[],null));}},ImportDeclaration:function ImportDeclaration(path){if(maybeSkip(path)){return;}if(path.node.importKind!=='type'){return;}var _path$get$map$reduce=path.get('specifiers').map(function(specifier){var local=specifier.get('local');var tmpId=path.scope.generateUidIdentifierBasedOnNode(local.node);var replacement=t.importSpecifier(tmpId,specifier.node.imported);var id=t.identifier(local.node.name);id.isTypeChecker=true;var declarator=t.variableDeclarator(id,tmpId);declarator.isTypeChecker=true;return [declarator,replacement];}).reduce(function(_ref2,_ref3){var _ref5=_slicedToArray(_ref2,2);var declarators=_ref5[0];var specifiers=_ref5[1];var _ref4=_slicedToArray(_ref3,2);var declarator=_ref4[0];var specifier=_ref4[1];declarators.push(declarator);specifiers.push(specifier);return [declarators,specifiers];},[[],[]]);var _path$get$map$reduce2=_slicedToArray(_path$get$map$reduce,2);var declarators=_path$get$map$reduce2[0];var specifiers=_path$get$map$reduce2[1];var declaration=t.variableDeclaration('var',declarators);declaration.isTypeChecker=true;path.replaceWithMultiple([t.importDeclaration(specifiers,path.node.source),declaration]);},ArrowFunctionExpression:function ArrowFunctionExpression(path){ // Look for destructuring args with annotations.\nvar params=path.get('params');var _iteratorNormalCompletion=true;var _didIteratorError=false;var _iteratorError=undefined;try{for(var _iterator=params[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){var param=_step.value;if(param.isObjectPattern()&&param.node.typeAnnotation){var _path$get=path.get('body');var _scope=_path$get.scope;var _id=_scope.generateUidIdentifier('arg'+param.key);var pattern=param.node;param.replaceWith(_id);if(path.node.expression){var block=t.blockStatement([t.variableDeclaration('var',[t.variableDeclarator(pattern,_id)]),t.returnStatement(path.get('body').node)]);path.node.body=block;path.node.expression=false;}else {path.get('body.body')[0].insertBefore(t.variableDeclaration('var',[t.variableDeclarator(pattern,_id)]));}}}}catch(err){_didIteratorError=true;_iteratorError=err;}finally {try{if(!_iteratorNormalCompletion&&_iterator.return){_iterator.return();}}finally {if(_didIteratorError){throw _iteratorError;}}}},Function:{enter:function enter(path,context){var _node$body$body;if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;var paramChecks=collectParamChecks(path,context);if(node.type===\"ArrowFunctionExpression\"&&node.expression){node.expression=false;node.body=t.blockStatement([t.returnStatement(node.body)]);}if(node.returnType){createFunctionReturnGuard(path,context);createFunctionYieldGuards(path,context);}(_node$body$body=node.body.body).unshift.apply(_node$body$body,_toConsumableArray(paramChecks));node.savedTypeAnnotation=node.returnType;node.returnCount=0;node.yieldCount=0;},exit:function exit(path){var node=path.node;var scope=path.scope;var isVoid=node.savedTypeAnnotation?maybeNullableAnnotation(node.savedTypeAnnotation):null;if(!node.returnCount&&isVoid===false){var annotation=node.savedTypeAnnotation;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(node.generator&&isGeneratorAnnotation(annotation)&&annotation.typeParameters&&annotation.typeParameters.params.length>1){annotation=annotation.typeParameters.params[1];}throw path.buildCodeFrameError(buildErrorMessage('Function '+(node.id?'\"'+node.id.name+'\" ':'')+'did not return a value.',annotation));}if(node.nextGuardCount){path.get('body').get('body')[0].insertBefore(node.nextGuard);}if(node.yieldGuardCount){path.get('body').get('body')[0].insertBefore(node.yieldGuard);}if(node.returnGuardCount){path.get('body').get('body')[0].insertBefore(node.returnGuard);}}},YieldExpression:function YieldExpression(path,context){var fn=path.getFunctionParent();if(!fn){return;}fn.node.yieldCount++;if(!isGeneratorAnnotation(fn.node.returnType)||maybeSkip(path)){return;}var node=path.node;var parent=path.parent;var scope=path.scope;var annotation=fn.node.returnType;if(annotation.type==='NullableTypeAnnotation'||annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(!annotation.typeParameters||annotation.typeParameters.params.length===0){return;}var yieldType=annotation.typeParameters.params[0];var nextType=annotation.typeParameters.params[2];var ok=staticCheckAnnotation(path.get(\"argument\"),yieldType);if(ok===true&&!nextType){return;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'\"'+fn.node.id.name+'\" ':'')+'yielded an invalid type.',yieldType,getAnnotation(path.get('argument'))));}fn.node.yieldGuardCount++;if(fn.node.yieldGuard){var _yielder=t.yieldExpression(t.callExpression(fn.node.yieldGuardName,[node.argument||t.identifier('undefined')]));_yielder.hasBeenTypeChecked=true;if(fn.node.nextGuard){fn.node.nextGuardCount++;path.replaceWith(t.callExpression(fn.node.nextGuardName,[_yielder]));}else {path.replaceWith(_yielder);}}else if(fn.node.nextGuard){fn.node.nextGuardCount++;path.replaceWith(t.callExpression(fn.node.nextGuardName,[yielder]));}},ReturnStatement:function ReturnStatement(path,context){var fn=path.getFunctionParent();if(!fn){return;}fn.node.returnCount++;if(maybeSkip(path)){return;}var node=path.node;var parent=path.parent;var scope=path.scope;var _fn$node=fn.node;var returnType=_fn$node.returnType;var returnGuardName=_fn$node.returnGuardName;if(!returnType||!returnGuardName){return;}if(!node.argument){if(maybeNullableAnnotation(returnType)===false){throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'\"'+fn.node.id.name+'\" ':'')+'did not return a value.',returnType));}return;}var annotation=returnType;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(isGeneratorAnnotation(annotation)){annotation=annotation.typeParameters&&annotation.typeParameters.params.length>1?annotation.typeParameters.params[1]:t.anyTypeAnnotation();}else if(node.async&&annotation.type==='GenericTypeAnnotation'&&annotation.id.name==='Promise'){annotation=annotation.typeParameters&&annotation.typeParameters[0]||t.anyTypeAnnotation();}var ok=staticCheckAnnotation(path.get(\"argument\"),annotation);if(ok===true){return;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'\"'+fn.node.id.name+'\" ':'')+'returned an invalid type.',annotation,getAnnotation(path.get('argument'))));}fn.node.returnGuardCount++;var returner=t.returnStatement(t.callExpression(fn.node.returnGuardName,[node.argument]));returner.hasBeenTypeChecked=true;path.replaceWith(returner);},VariableDeclaration:function VariableDeclaration(path,context){if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;var collected=[];var declarations=path.get(\"declarations\");for(var i=0;i<node.declarations.length;i++){var declaration=node.declarations[i];var _id2=declaration.id;var init=declaration.init;if(!_id2.typeAnnotation||_id2.hasBeenTypeChecked){continue;}_id2.savedTypeAnnotation=_id2.typeAnnotation;_id2.hasBeenTypeChecked=true;var ok=staticCheckAnnotation(declarations[i],_id2.typeAnnotation);if(ok===true){continue;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid assignment value for \"'+_id2.name+'\".',_id2.typeAnnotation,getAnnotation(declarations[i])));}var check=checkAnnotation(_id2,_id2.typeAnnotation,scope);if(check){collected.push(guard({check:check,message:varTypeErrorMessage(_id2,context)}));}}if(collected.length>0){var _check=collected.reduce(function(check,branch){branch.alternate=check;return branch;});if(path.parent.type==='Program'||path.parent.type==='BlockStatement'){path.insertAfter(_check);}else if(path.parentPath.isForXStatement()||path.parentPath.isForStatement()||path.parentPath.isForInStatement()){var body=path.parentPath.get('body');if(body.type!=='BlockStatement'){var block=t.blockStatement([body.node]);body.replaceWith(block);body=path.parentPath.get('body');}var children=body.get('body');if(children.length===0){body.replaceWith(_check);}else {children[0].insertBefore(_check);}}else if(path.parent.type==='ExportNamedDeclaration'||path.parent.type==='ExportDefaultDeclaration'||path.parent.type==='ExportAllDeclaration'){path.parentPath.insertAfter(_check);}else {path.replaceWith(t.blockStatement([node,_check]));}}},AssignmentExpression:function AssignmentExpression(path,context){if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;var left=path.get('left');var annotation=void 0;if(node.hasBeenTypeChecked||node.left.hasBeenTypeChecked){return;}else if(left.isMemberExpression()){annotation=getAnnotation(left);}else if(t.isIdentifier(node.left)){var binding=scope.getBinding(node.left.name);if(!binding){return;}else if(binding.path.type!=='VariableDeclarator'){return;}annotation=left.getTypeAnnotation();if(annotation.type==='AnyTypeAnnotation'){var item=binding.path.get('id');annotation=item.node.savedTypeAnnotation||item.getTypeAnnotation();}}else {return;}node.hasBeenTypeChecked=true;node.left.hasBeenTypeChecked=true;var id=node.left;var right=path.get('right');if(annotation.type==='AnyTypeAnnotation'){return;}var ok=staticCheckAnnotation(right,annotation);if(ok===true){return;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid assignment value for \"'+humanReadableType(id)+'\".',annotation,getAnnotation(right)));}var check=checkAnnotation(id,annotation,scope);if(!id.typeAnnotation){id.typeAnnotation=annotation;}id.hasBeenTypeChecked=true;if(check){var parent=path.getStatementParent();parent.insertAfter(guard({check:check,message:varTypeErrorMessage(id,context)}));}},TypeCastExpression:function TypeCastExpression(path){var node=path.node;var target=void 0;switch(node.expression.type){case 'Identifier':target=node.expression;break;case 'AssignmentExpression':target=node.expression.left;break;default: // unsupported.\nreturn;}var id=path.scope.getBindingIdentifier(target.name);if(!id){return;}id.savedTypeAnnotation=path.getTypeAnnotation();},ForOfStatement:function ForOfStatement(path,context){if(maybeSkip(path)){return;}var left=path.get('left');var right=path.get('right');var rightAnnotation=getAnnotation(right);var leftAnnotation=left.isVariableDeclaration()?getAnnotation(left.get('declarations')[0].get('id')):getAnnotation(left);if(rightAnnotation.type!=='VoidTypeAnnotation'&&rightAnnotation.type!=='NullLiteralTypeAnnotation'){var ok=maybeIterableAnnotation(rightAnnotation);if(ok===false){throw path.buildCodeFrameError('Cannot iterate '+humanReadableType(rightAnnotation)+'.');}}var id=void 0;if(right.isIdentifier()){id=right.node;}else {id=path.scope.generateUidIdentifierBasedOnNode(right.node);path.scope.push({id:id});var replacement=t.expressionStatement(t.assignmentExpression('=',id,right.node));path.insertBefore(replacement);right.replaceWith(id);}path.insertBefore(guard({check:checks.iterable({input:id}),message:t.binaryExpression('+',t.stringLiteral('Expected '+humanReadableType(right.node)+' to be iterable, got '),readableName({inspect:context.inspect,input:id}))}));if(rightAnnotation.type!=='GenericTypeAnnotation'||rightAnnotation.id.name!=='Iterable'||!rightAnnotation.typeParameters||!rightAnnotation.typeParameters.params.length){return;}var annotation=rightAnnotation.typeParameters.params[0];if(compareAnnotations(annotation,leftAnnotation)===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid iterator type.',annotation,leftAnnotation));}},ClassDeclaration:function ClassDeclaration(path,context){ // Convert React props to propTypes\nif(!path.node.superClass){return;}var props=void 0;var hasRenderMethod=false;var _iteratorNormalCompletion2=true;var _didIteratorError2=false;var _iteratorError2=undefined;try{for(var _iterator2=path.get('body.body')[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=true){var memberPath=_step2.value;var classMember=memberPath.node;if(t.isClassProperty(classMember)){if(classMember.key.name==='propTypes'&&classMember.static){return;}else if(classMember.key.name==='props'&&!classMember.static){props=memberPath;}}if(t.isClassMethod(classMember)&&classMember.key.name==='render'){hasRenderMethod=true;}}}catch(err){_didIteratorError2=true;_iteratorError2=err;}finally {try{if(!_iteratorNormalCompletion2&&_iterator2.return){_iterator2.return();}}finally {if(_didIteratorError2){throw _iteratorError2;}}}var type=void 0;if(path.node.superTypeParameters){if(path.node.superTypeParameters.params.length!==3){return;}type=path.node.superTypeParameters.params[1];}if(props){type=props.node.typeAnnotation.typeAnnotation;}if(!type||!hasRenderMethod){return;}if(t.isGenericTypeAnnotation(type)){var binding=path.scope.getBinding(type.id.name);type=getAnnotation(binding.path);}if(!t.isObjectTypeAnnotation(type)){return;} // Now we have a class that has a superclass, an instance method called 'render'\n// and some property type annotations. We can be reasonably sure it's a React component.\nvar propTypes=t.objectExpression(type.properties.map(function(prop){return t.objectProperty(t.identifier(prop.key.name),generatePropType(prop.value,path.scope,context));}));if(path.node.decorators){var property=t.classProperty(t.identifier('propTypes'),propTypes);property.static=true;props.insertAfter(property);}else {var root=path.parentPath.isExportDeclaration()?path.parentPath:path;root.insertAfter(t.expressionStatement(t.assignmentExpression(\"=\",t.memberExpression(path.node.id,t.identifier(\"propTypes\")),propTypes)));}}}; /**\n   * Collect all the type declarations in the given path and add references to them for retreival later.\n   */function collectTypes(path){path.traverse({TypeAlias:function TypeAlias(path){path.scope.setData('typechecker:'+path.node.id.name,path.node);},ImportDeclaration:function ImportDeclaration(path){if(path.node.importKind!=='type'){return;}path.get('specifiers').forEach(function(specifier){var local=specifier.get('local');path.scope.setData('typechecker:'+local.node.id.name,specifier.node);});}});}return {visitor:{Program:function Program(path,_ref6){var opts=_ref6.opts;if(opts&&opts.disable&&opts.disable[process.env.NODE_ENV]){return;}var checkFile=false;var _iteratorNormalCompletion3=true;var _didIteratorError3=false;var _iteratorError3=undefined;try{for(var _iterator3=path.get('body')[Symbol.iterator](),_step3;!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=true){var _child=_step3.value;if(mustCheckFile(_child,opts)){checkFile=true;break;}}}catch(err){_didIteratorError3=true;_iteratorError3=err;}finally {try{if(!_iteratorNormalCompletion3&&_iterator3.return){_iterator3.return();}}finally {if(_didIteratorError3){throw _iteratorError3;}}}if(!checkFile){var _iteratorNormalCompletion4=true;var _didIteratorError4=false;var _iteratorError4=undefined;try{for(var _iterator4=path.get('body')[Symbol.iterator](),_step4;!(_iteratorNormalCompletion4=(_step4=_iterator4.next()).done);_iteratorNormalCompletion4=true){var child=_step4.value;if(maybeSkipFile(child,opts)){return;}}}catch(err){_didIteratorError4=true;_iteratorError4=err;}finally {try{if(!_iteratorNormalCompletion4&&_iterator4.return){_iterator4.return();}}finally {if(_didIteratorError4){throw _iteratorError4;}}}}collectTypes(path);var inspect=path.scope.generateUidIdentifier('inspect');var requiresHelpers={inspect:false};var context={get inspect(){requiresHelpers.inspect=true;return inspect;}};path.traverse(visitors,context);if(requiresHelpers.inspect){var body=path.get('body');body[body.length-1].insertAfter(template('\\n            function id (input, depth) {\\n              const maxDepth = 4;\\n              const maxKeys = 15;\\n              if (depth === undefined) {\\n                depth = 0;\\n              }\\n              depth += 1;\\n              if (input === null) {\\n                return \\'null\\';\\n              }\\n              else if (input === undefined) {\\n                return \\'void\\';\\n              }\\n              else if (typeof input === \\'string\\' || typeof input === \\'number\\' || typeof input === \\'boolean\\') {\\n                return typeof input;\\n              }\\n              else if (Array.isArray(input)) {\\n                if (input.length > 0) {\\n                  if (depth > maxDepth) return \\'[...]\\';\\n                  const first = id(input[0], depth);\\n                  if (input.every(item => id(item, depth) === first)) {\\n                    return first.trim() + \\'[]\\';\\n                  }\\n                  else {\\n                    return \\'[\\' + input.slice(0, maxKeys).map(item => id(item, depth)).join(\\', \\') + (input.length >= maxKeys ? \\', ...\\' : \\'\\') + \\']\\';\\n                  }\\n                }\\n                else {\\n                  return \\'Array\\';\\n                }\\n              }\\n              else {\\n                const keys = Object.keys(input);\\n                if (!keys.length) {\\n                  if (input.constructor && input.constructor.name && input.constructor.name !== \\'Object\\') {\\n                    return input.constructor.name;\\n                  }\\n                  else {\\n                    return \\'Object\\';\\n                  }\\n                }\\n                if (depth > maxDepth) return \\'{...}\\';\\n                const indent = \\'  \\'.repeat(depth - 1);\\n                let entries = keys.slice(0, maxKeys).map(key => {\\n                  return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key) ? key : JSON.stringify(key)) + \\': \\' + id(input[key], depth) + \\';\\';\\n                }).join(\\'\\\\n  \\' + indent);\\n                if (keys.length >= maxKeys) {\\n                  entries += \\'\\\\n  \\' + indent + \\'...\\';\\n                }\\n                if (input.constructor && input.constructor.name && input.constructor.name !== \\'Object\\') {\\n                  return input.constructor.name + \\' {\\\\n  \\' + indent + entries + \\'\\\\n\\' + indent + \\'}\\';\\n                }\\n                else {\\n                  return \\'{\\\\n  \\' + indent + entries + \\'\\\\n\\' + indent + \\'}\\';\\n                }\\n              }\\n            }\\n          ')({id:inspect}));}}}}; /**\n   * Create a function which can verify the return type for a function.\n   */function createFunctionReturnGuard(path,context){var node=path.node;var scope=path.scope;var annotation=node.returnType;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(isGeneratorAnnotation(annotation)){annotation=annotation.typeParameters&&annotation.typeParameters.params.length>1?annotation.typeParameters.params[1]:t.anyTypeAnnotation();}else if(node.async&&annotation.type==='GenericTypeAnnotation'&&annotation.id.name==='Promise'){annotation=annotation.typeParameters&&annotation.typeParameters[0]||t.anyTypeAnnotation();}var name=scope.generateUidIdentifierBasedOnNode(node);var id=scope.generateUidIdentifier('id');var check=checkAnnotation(id,annotation,scope);if(check){node.returnGuard=guardFn({id:id,name:name,check:check,message:returnTypeErrorMessage(path,path.node,id,context)});node.returnGuard.hasBeenTypeChecked=true;node.returnGuardName=name;node.returnGuardCount=0;}}function createFunctionYieldGuards(path,context){var node=path.node;var scope=path.scope;var annotation=node.returnType;if(annotation.type==='NullableTypeAnnotation'||annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(!annotation.typeParameters||annotation.typeParameters.params.length===0){return;}if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(!isGeneratorAnnotation(annotation)){return;}var yieldType=annotation.typeParameters.params[0];var nextType=annotation.typeParameters.params[2];if(yieldType){var _name=scope.generateUidIdentifier('check'+(node.id?node.id.name.slice(0,1).toUpperCase()+node.id.name.slice(1):'')+'Yield');var _id3=scope.generateUidIdentifier('id');var check=checkAnnotation(_id3,yieldType,scope);if(check){node.yieldGuard=guardFn({id:_id3,name:_name,check:check,message:yieldTypeErrorMessage(node,yieldType,_id3,context)});node.yieldGuardName=_name;node.yieldGuardCount=0;}}if(nextType){var _name2=scope.generateUidIdentifier('check'+(node.id?node.id.name.slice(0,1).toUpperCase()+node.id.name.slice(1):'')+'Next');var _id4=scope.generateUidIdentifier('id');var _check2=checkAnnotation(_id4,nextType,scope);if(_check2){node.nextGuard=guardFn({id:_id4,name:_name2,check:_check2,message:yieldNextTypeErrorMessage(node,nextType,_id4,context)});node.nextGuardName=_name2;node.nextGuardCount=0;}}}function isThisMemberExpression(path){var node=path.node;if(node.type==='ThisExpression'){return true;}else if(node.type==='MemberExpression'){return isThisMemberExpression(path.get('object'));}else {return false;}}function isGeneratorAnnotation(annotation){if(!annotation){return false;}if(annotation.type==='TypeAnnotation'||annotation.type==='NullableTypeAnnotation'){annotation=annotation.typeAnnotation;}return annotation.type==='GenericTypeAnnotation'&&annotation.id.name==='Generator';}function buildErrorMessage(message,expected,got){if(got){return message+'\\n\\nExpected:\\n'+humanReadableType(expected)+'\\n\\nGot:\\n'+humanReadableType(got);}else {return message+'\\n\\nExpected:\\n'+humanReadableType(expected);}}function createChecks(){return {number:expression('typeof input === \\'number\\''),numericLiteral:checkNumericLiteral,boolean:expression('typeof input === \\'boolean\\''),booleanLiteral:checkBooleanLiteral,class:checkClass,function:expression('typeof input === \\'function\\''),string:expression('typeof input === \\'string\\''),stringLiteral:checkStringLiteral,symbol:expression('typeof input === \\'symbol\\''),undefined:expression('input === undefined'),null:expression('input === null'),void:expression('input == null'),instanceof:expression('input instanceof type'),type:expression('type(input)'),mixed:function mixed(){return null;},any:function any(){return null;},union:checkUnion,intersection:checkIntersection,array:checkArray,map:checkMap,set:checkSet,generator:checkGenerator,iterable:checkIterable,tuple:checkTuple,object:checkObject,nullable:checkNullable,typeof:checkTypeof,int8:expression('typeof input === \\'number\\' && !isNaN(input) && input >= -128 && input <= 127 && input === Math.floor(input)'),uint8:expression('typeof input === \\'number\\' && !isNaN(input) && input >= 0 && input <= 255 && input === Math.floor(input)'),int16:expression('typeof input === \\'number\\' && !isNaN(input) && input >= -32768 && input <= 32767 && input === Math.floor(input)'),uint16:expression('typeof input === \\'number\\' && !isNaN(input) && input >= 0 && input <= 65535 && input === Math.floor(input)'),int32:expression('typeof input === \\'number\\' && !isNaN(input) && input >= -2147483648 && input <= 2147483647 && input === Math.floor(input)'),uint32:expression('typeof input === \\'number\\' && !isNaN(input) && input >= 0 && input <= 4294967295 && input === Math.floor(input)'),float32:expression('typeof input === \\'number\\' && !isNaN(input) && input >= -3.40282347e+38 && input <= 3.40282347e+38'),float64:expression('typeof input === \\'number\\' && !isNaN(input)'),double:expression('typeof input === \\'number\\' && !isNaN(input)')};}function createStaticChecks(){return {symbol:function symbol(path){return maybeSymbolAnnotation(getAnnotation(path));},instanceof:function _instanceof(_ref7){var path=_ref7.path;var annotation=_ref7.annotation;var type=createTypeExpression(annotation.id);var node=path.node;var scope=path.scope;if(type.name==='Object'&&node.type==='ObjectExpression'&&!scope.getBinding('Object')){return true;}else if(type.name==='Map'&&!scope.getBinding('Map')){return null;}else if(type.name==='Set'&&!scope.getBinding('Set')){return null;}else if(type.name==='Class'&&!scope.hasBinding('Class')){return null;}else if(type.name==='int8'&&!scope.hasBinding('int8')){return null;}else if(type.name==='uint8'&&!scope.hasBinding('uint8')){return null;}else if(type.name==='int16'&&!scope.hasBinding('int16')){return null;}else if(type.name==='uint16'&&!scope.hasBinding('uint16')){return null;}else if(type.name==='int32'&&!scope.hasBinding('int32')){return null;}else if(type.name==='uint32'&&!scope.hasBinding('uint32')){return null;}else if(type.name==='float32'&&!scope.hasBinding('float32')){return null;}else if(type.name==='float64'&&!scope.hasBinding('float64')){return null;}else if(type.name==='double'&&!scope.hasBinding('double')){return null;}return maybeInstanceOfAnnotation(getAnnotation(path),type,annotation.typeParameters?annotation.typeParameters.params:[]);},type:function(_type){function type(_x){return _type.apply(this,arguments);}type.toString=function(){return _type.toString();};return type;}(function(_ref8){var path=_ref8.path;var type=_ref8.type;return null;})};}function compareAnnotations(a,b){if(a.type==='TypeAnnotation'){a=a.typeAnnotation;}if(b.type==='TypeAnnotation'){b=b.typeAnnotation;}switch(a.type){case 'StringTypeAnnotation':return maybeStringAnnotation(b);case 'StringLiteral':case 'StringLiteralTypeAnnotation':return compareStringLiteralAnnotations(a,b);case 'NumberTypeAnnotation':return maybeNumberAnnotation(b);case 'NumericLiteral':case 'NumericLiteralTypeAnnotation':return compareNumericLiteralAnnotations(a,b);case 'BooleanTypeAnnotation':return maybeBooleanAnnotation(b);case 'BooleanLiteral':case 'BooleanLiteralTypeAnnotation':return compareBooleanLiteralAnnotations(a,b);case 'FunctionTypeAnnotation':return maybeFunctionAnnotation(b);case 'AnyTypeAnnotation':return null;case 'MixedTypeAnnotation':return null;case 'ObjectTypeAnnotation':return compareObjectAnnotation(a,b);case 'ArrayTypeAnnotation':return compareArrayAnnotation(a,b);case 'GenericTypeAnnotation':return compareGenericAnnotation(a,b);case 'TupleTypeAnnotation':return compareTupleAnnotation(a,b);case 'UnionTypeAnnotation':return compareUnionAnnotation(a,b);case 'IntersectionTypeAnnotation':return compareIntersectionAnnotation(a,b);case 'NullableTypeAnnotation':return compareNullableAnnotation(a,b);default:return null;}}function compareStringLiteralAnnotations(a,b){if(b.type==='StringLiteralTypeAnnotation'||b.type==='StringLiteral'){return a.value===b.value;}else {return maybeStringAnnotation(b)===false?false:null;}}function compareBooleanLiteralAnnotations(a,b){if(b.type==='BooleanLiteralTypeAnnotation'||b.type==='BooleanLiteral'){return a.value===b.value;}else {return maybeBooleanAnnotation(b)===false?false:null;}}function compareNumericLiteralAnnotations(a,b){if(b.type==='NumericLiteralTypeAnnotation'||b.type==='NumericLiteral'){return a.value===b.value;}else {return maybeNumberAnnotation(b)===false?false:null;}}function unionComparer(a,b,comparator){if(!a.types||a.types.length===0){return null;}var falseCount=0;var trueCount=0;if(!a.types){return null;}var _iteratorNormalCompletion5=true;var _didIteratorError5=false;var _iteratorError5=undefined;try{for(var _iterator5=a.types[Symbol.iterator](),_step5;!(_iteratorNormalCompletion5=(_step5=_iterator5.next()).done);_iteratorNormalCompletion5=true){var _type2=_step5.value;var result=comparator(_type2,b);if(result===true){if(b.type!=='UnionTypeAnnotation'){return true;}trueCount++;}else if(result===false){if(b.type==='UnionTypeAnnotation'){return false;}falseCount++;}}}catch(err){_didIteratorError5=true;_iteratorError5=err;}finally {try{if(!_iteratorNormalCompletion5&&_iterator5.return){_iterator5.return();}}finally {if(_didIteratorError5){throw _iteratorError5;}}}if(falseCount===a.types.length){return false;}else if(trueCount===a.types.length){return true;}else {return null;}}function intersectionComparer(a,b,comparator){var falseCount=0;var trueCount=0;if(!a.types){return null;}var _iteratorNormalCompletion6=true;var _didIteratorError6=false;var _iteratorError6=undefined;try{for(var _iterator6=a.types[Symbol.iterator](),_step6;!(_iteratorNormalCompletion6=(_step6=_iterator6.next()).done);_iteratorNormalCompletion6=true){var _type3=_step6.value;var result=comparator(_type3,b);if(result===true){trueCount++;}else if(result===false){return false;}}}catch(err){_didIteratorError6=true;_iteratorError6=err;}finally {try{if(!_iteratorNormalCompletion6&&_iterator6.return){_iterator6.return();}}finally {if(_didIteratorError6){throw _iteratorError6;}}}if(trueCount===a.types.length){return true;}else {return null;}}function compareObjectAnnotation(a,b){switch(b.type){case 'ObjectTypeAnnotation':break;case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return compareObjectAnnotation(a,b.typeAnnotation);case 'UnionTypeAnnotation':return unionComparer(a,b,compareObjectAnnotation);case 'IntersectionTypeAnnotation':return intersectionComparer(a,b,compareObjectAnnotation);case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':return false;default:return null;} // We're comparing two object annotations.\nvar allTrue=true;var _iteratorNormalCompletion7=true;var _didIteratorError7=false;var _iteratorError7=undefined;try{for(var _iterator7=a.properties[Symbol.iterator](),_step7;!(_iteratorNormalCompletion7=(_step7=_iterator7.next()).done);_iteratorNormalCompletion7=true){var aprop=_step7.value;var found=false;var _iteratorNormalCompletion8=true;var _didIteratorError8=false;var _iteratorError8=undefined;try{for(var _iterator8=b.properties[Symbol.iterator](),_step8;!(_iteratorNormalCompletion8=(_step8=_iterator8.next()).done);_iteratorNormalCompletion8=true){var bprop=_step8.value;if(bprop.key.name===aprop.key.name){var result=compareAnnotations(aprop.value,bprop.value);if(result===false&&!(aprop.optional&&(bprop.optional||maybeNullableAnnotation(bprop.value)===true))){return false;}else {found=result;}break;}}}catch(err){_didIteratorError8=true;_iteratorError8=err;}finally {try{if(!_iteratorNormalCompletion8&&_iterator8.return){_iterator8.return();}}finally {if(_didIteratorError8){throw _iteratorError8;}}}if(found===false&&!aprop.optional){return false;}allTrue=allTrue&&found===true;}}catch(err){_didIteratorError7=true;_iteratorError7=err;}finally {try{if(!_iteratorNormalCompletion7&&_iterator7.return){_iterator7.return();}}finally {if(_didIteratorError7){throw _iteratorError7;}}}return allTrue?true:null;}function compareArrayAnnotation(a,b){switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return compareArrayAnnotation(a,b.typeAnnotation);case 'UnionTypeAnnotation':return unionComparer(a,b,compareArrayAnnotation);case 'IntersectionTypeAnnotation':return intersectionComparer(a,b,compareArrayAnnotation);case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':return false;default:return null;}}function compareGenericAnnotation(a,b){switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return compareGenericAnnotation(a,b.typeAnnotation);case 'GenericTypeAnnotation':if(b.id.name===a.id.name){return true;}else {return null;}case 'UnionTypeAnnotation':return unionComparer(a,b,compareGenericAnnotation);case 'IntersectionTypeAnnotation':return intersectionComparer(a,b,compareGenericAnnotation);default:return null;}}function compareTupleAnnotation(a,b){if(b.type==='TupleTypeAnnotation'){if(b.types.length===0){return null;}else if(b.types.length<a.types.length){return false;}return a.types.every(function(type,index){return compareAnnotations(type,b.types[index]);});}switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return compareTupleAnnotation(a,b.typeAnnotation);case 'UnionTypeAnnotation':return unionComparer(a,b,compareTupleAnnotation);case 'IntersectionTypeAnnotation':return intersectionComparer(a,b,compareTupleAnnotation);case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':return false;default:return null;}}function compareUnionAnnotation(a,b){switch(b.type){case 'NullableTypeAnnotation':return compareUnionAnnotation(a,b.typeAnnotation);case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':return null;default:return unionComparer(a,b,compareAnnotations);}}function compareNullableAnnotation(a,b){switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':return compareNullableAnnotation(a,b.typeAnnotation);case 'NullableTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':return null;}if(compareAnnotations(a.typeAnnotation,b)===true){return true;}else {return null;}}function arrayExpressionToTupleAnnotation(path){var elements=path.get('elements');return t.tupleTypeAnnotation(elements.map(function(element){return getAnnotation(element);}));}function checkNullable(_ref9){var input=_ref9.input;var type=_ref9.type;var scope=_ref9.scope;var check=checkAnnotation(input,type,scope);if(!check){return;}return t.logicalExpression(\"||\",checks.void({input:input}),check);}function checkTypeof(_ref10){var input=_ref10.input;var annotation=_ref10.annotation;var scope=_ref10.scope;switch(annotation.type){case 'GenericTypeAnnotation':var id=annotation.id;var path=Object.assign({},input,{type:id.type,node:id,scope:scope});return checkAnnotation(input,getAnnotation(path),scope);default:return checkAnnotation(input,annotation,scope);}}function checkStringLiteral(_ref11){var input=_ref11.input;var annotation=_ref11.annotation;return checkEquals({input:input,expected:t.stringLiteral(annotation.value)});}function checkNumericLiteral(_ref12){var input=_ref12.input;var annotation=_ref12.annotation;return checkEquals({input:input,expected:t.numericLiteral(annotation.value)});}function checkBooleanLiteral(_ref13){var input=_ref13.input;var annotation=_ref13.annotation;return checkEquals({input:input,expected:t.booleanLiteral(annotation.value)});}function checkUnion(_ref14){var input=_ref14.input;var types=_ref14.types;var scope=_ref14.scope;var checks=types.map(function(type){return checkAnnotation(input,type,scope);}).filter(identity);return checks.reduce(function(last,check,index){if(last==null){return check;}return t.logicalExpression(\"||\",last,check);},null);}function checkIntersection(_ref15){var input=_ref15.input;var types=_ref15.types;var scope=_ref15.scope;var checks=types.map(function(type){return checkAnnotation(input,type,scope);}).filter(identity);return checks.reduce(function(last,check,index){if(last==null){return check;}return t.logicalExpression(\"&&\",last,check);},null);}function checkMap(_ref16){var input=_ref16.input;var types=_ref16.types;var scope=_ref16.scope;var _types=_slicedToArray(types,2);var keyType=_types[0];var valueType=_types[1];var key=t.identifier('key');var value=t.identifier('value');var keyCheck=keyType?checkAnnotation(key,keyType,scope):null;var valueCheck=valueType?checkAnnotation(value,valueType,scope):null;if(!keyCheck){if(!valueCheck){return checkIsMap({input:input});}else {return checkMapValues({input:input,value:value,valueCheck:valueCheck});}}else {if(!valueCheck){return checkMapKeys({input:input,key:key,keyCheck:keyCheck});}else {return checkMapEntries({input:input,key:key,value:value,keyCheck:keyCheck,valueCheck:valueCheck});}}}function checkSet(_ref17){var input=_ref17.input;var types=_ref17.types;var scope=_ref17.scope;var _types2=_slicedToArray(types,1);var valueType=_types2[0];var value=t.identifier('value');var valueCheck=valueType?checkAnnotation(value,valueType,scope):null;if(!valueCheck){return checkIsSet({input:input});}else {return checkSetEntries({input:input,value:value,valueCheck:valueCheck});}}function checkGenerator(_ref18){var input=_ref18.input;var types=_ref18.types;var scope=_ref18.scope;return checkIsGenerator({input:input});}function checkIterable(_ref19){var input=_ref19.input;var types=_ref19.types;var scope=_ref19.scope;return checkIsIterable({input:input});}function checkClass(_ref20){var input=_ref20.input;var types=_ref20.types;var scope=_ref20.scope;return checkIsClass({input:input});}function checkArray(_ref21){var input=_ref21.input;var types=_ref21.types;var scope=_ref21.scope;if(!types||types.length===0){return checkIsArray({input:input});}else if(types.length===1){var item=t.identifier('item');var _type4=types[0];var check=checkAnnotation(item,_type4,scope);if(!check){return checkIsArray({input:input});}return t.logicalExpression('&&',checkIsArray({input:input}),t.callExpression(t.memberExpression(input,t.identifier('every')),[t.functionExpression(null,[item],t.blockStatement([t.returnStatement(check)]))]));}else { // This is a tuple\nvar _checks=types.map(function(type,index){return checkAnnotation(t.memberExpression(input,t.numericLiteral(index),true),type,scope);}).filter(identity);var checkLength=t.binaryExpression('>=',t.memberExpression(input,t.identifier('length')),t.numericLiteral(types.length));return _checks.reduce(function(last,check,index){return t.logicalExpression(\"&&\",last,check);},t.logicalExpression('&&',checkIsArray({input:input}),checkLength));}}function checkTuple(_ref22){var input=_ref22.input;var types=_ref22.types;var scope=_ref22.scope;if(types.length===0){return checkIsArray({input:input});} // This is a tuple\nvar checks=types.map(function(type,index){return checkAnnotation(t.memberExpression(input,t.numericLiteral(index),true),type,scope);}).filter(identity);var checkLength=t.binaryExpression('>=',t.memberExpression(input,t.identifier('length')),t.numericLiteral(types.length));return checks.reduce(function(last,check,index){return t.logicalExpression(\"&&\",last,check);},t.logicalExpression('&&',checkIsArray({input:input}),checkLength));}function checkObject(_ref23){var input=_ref23.input;var properties=_ref23.properties;var indexers=_ref23.indexers;var scope=_ref23.scope;if(input.type==='ObjectPattern'){return checkObjectPattern({input:input,properties:properties,scope:scope});}var propNames=[];var check=properties.length===0?checkIsObject({input:input}):properties.reduce(function(expr,prop,index){var target=prop.key.type==='Identifier'?t.memberExpression(input,prop.key):t.memberExpression(input,prop.key,true);propNames.push(prop.key.type==='Identifier'?t.stringLiteral(prop.key.name):prop.key);var check=checkAnnotation(target,prop.value,scope);if(check){if(prop.optional){check=t.logicalExpression('||',checks.undefined({input:target}),check);}return t.logicalExpression(\"&&\",expr,check);}else {return expr;}},checkNotNull({input:input}));if(indexers.length){return indexers.reduceRight(function(expr,indexer){if(indexer.value.type==='AnyTypeAnnotation'){return expr;}var value=scope.generateUidIdentifier(indexer.id.name);var check=checkAnnotation(value,indexer.value,scope);var fixedKeys=t.arrayExpression(propNames);if(check){if(propNames.length){return t.logicalExpression('&&',expr,checkObjectIndexers({input:input,value:value,check:check,fixedKeys:fixedKeys}));}else {return t.logicalExpression('&&',expr,checkObjectIndexersNoFixed({input:input,value:value,check:check,fixedKeys:fixedKeys}));}}else {return expr;}},check);}return check;}function checkObjectPattern(_ref24){var input=_ref24.input;var properties=_ref24.properties;var scope=_ref24.scope;var propNames=properties.reduce(function(names,prop){names[prop.key.name]=prop;return names;},{});var propChecks={};var _iteratorNormalCompletion9=true;var _didIteratorError9=false;var _iteratorError9=undefined;try{for(var _iterator9=input.properties[Symbol.iterator](),_step9;!(_iteratorNormalCompletion9=(_step9=_iterator9.next()).done);_iteratorNormalCompletion9=true){var item=_step9.value;var key=item.key;var _id5=item.value;var prop=propNames[key.name];if(!prop){continue;}var check=checkAnnotation(_id5,prop.value,scope);if(check){propChecks[key.name]=check;}}}catch(err){_didIteratorError9=true;_iteratorError9=err;}finally {try{if(!_iteratorNormalCompletion9&&_iterator9.return){_iterator9.return();}}finally {if(_didIteratorError9){throw _iteratorError9;}}}return Object.keys(propChecks).reduce(function(last,name){var check=propChecks[name];if(last===null){return check;}else {return t.logicalExpression('&&',last,check);}},null);}function createTypeAliasChecks(path){var node=path.node;var scope=path.scope;var id=node.id;var annotation=node.right;var input=t.identifier('input');var check=checkAnnotation(input,annotation,scope)||t.booleanLiteral(true);var declaration=declareTypeChecker({id:id,check:check});declaration.isTypeChecker=true;declaration.savedTypeAnnotation=annotation;declaration.declarations[0].savedTypeAnnotation=annotation;return declaration;}function createInterfaceChecks(path){var node=path.node;var scope=path.scope;var id=node.id;var annotation=node.body;var input=t.identifier('input');var check=node.extends.reduce(function(check,extender){return t.logicalExpression('&&',check,checkAnnotation(input,t.genericTypeAnnotation(extender.id),path.scope));return check;},checkAnnotation(input,annotation,scope)||t.booleanLiteral(true));var declaration=declareTypeChecker({id:id,check:check});declaration.isTypeChecker=true;return declaration;}function checkAnnotation(input,annotation,scope){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':return checkAnnotation(input,annotation.typeAnnotation,scope);case 'TypeofTypeAnnotation':return checks.typeof({input:input,annotation:annotation.argument,scope:scope});case 'GenericTypeAnnotation':if(annotation.id.name==='Array'){return checks.array({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}else if(annotation.id.name==='Generator'&&!scope.hasBinding('Generator')){return checks.generator({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}else if(annotation.id.name==='Iterable'&&!scope.hasBinding('Iterable')){return checks.iterable({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}else if(annotation.id.name==='Map'&&!scope.getBinding('Map')){return checks.map({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}else if(annotation.id.name==='Set'&&!scope.getBinding('Set')){return checks.set({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}else if(annotation.id.name==='Function'){return checks.function({input:input});}else if(annotation.id.name==='Class'&&!scope.hasBinding('Class')){return checks.class({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}else if(annotation.id.name==='int8'&&!scope.hasBinding('int8')){return checks.int8({input:input});}else if(annotation.id.name==='uint8'&&!scope.hasBinding('uint8')){return checks.uint8({input:input});}else if(annotation.id.name==='int16'&&!scope.hasBinding('int16')){return checks.int16({input:input});}else if(annotation.id.name==='uint16'&&!scope.hasBinding('uint16')){return checks.uint16({input:input});}else if(annotation.id.name==='int32'&&!scope.hasBinding('int32')){return checks.int32({input:input});}else if(annotation.id.name==='uint32'&&!scope.hasBinding('uint32')){return checks.uint32({input:input});}else if(annotation.id.name==='float32'&&!scope.hasBinding('float32')){return checks.float32({input:input});}else if(annotation.id.name==='float64'&&!scope.hasBinding('float64')){return checks.float64({input:input});}else if(annotation.id.name==='double'&&!scope.hasBinding('double')){return checks.double({input:input});}else if(annotation.id.name==='Symbol'&&!scope.getBinding('Symbol')){return checks.symbol({input:input});}else if(isTypeChecker(annotation.id,scope)){return checks.type({input:input,type:annotation.id});}else if(isPolymorphicType(annotation.id,scope)){return;}else {return checks.instanceof({input:input,type:createTypeExpression(annotation.id)});}case 'TupleTypeAnnotation':return checks.tuple({input:input,types:annotation.types,scope:scope});case 'NumberTypeAnnotation':return checks.number({input:input});case 'NumericLiteralTypeAnnotation':return checks.numericLiteral({input:input,annotation:annotation});case 'BooleanTypeAnnotation':return checks.boolean({input:input});case 'BooleanLiteralTypeAnnotation':return checks.booleanLiteral({input:input,annotation:annotation});case 'StringTypeAnnotation':return checks.string({input:input});case 'StringLiteralTypeAnnotation':return checks.stringLiteral({input:input,annotation:annotation});case 'UnionTypeAnnotation':return checks.union({input:input,types:annotation.types,scope:scope});case 'IntersectionTypeAnnotation':return checks.intersection({input:input,types:annotation.types,scope:scope});case 'ObjectTypeAnnotation':return checks.object({input:input,properties:annotation.properties||[],indexers:annotation.indexers,scope:scope});case 'ArrayTypeAnnotation':return checks.array({input:input,types:[annotation.elementType||t.anyTypeAnnotation()],scope:scope});case 'FunctionTypeAnnotation':return checks.function({input:input,params:annotation.params,returnType:annotation.returnType});case 'MixedTypeAnnotation':return checks.mixed({input:input});case 'AnyTypeAnnotation':case 'ExistentialTypeParam':return checks.any({input:input});case 'NullableTypeAnnotation':return checks.nullable({input:input,type:annotation.typeAnnotation,scope:scope});case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':return checks.void({input:input});}}function staticCheckAnnotation(path,annotation){var other=getAnnotation(path);switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':return staticCheckAnnotation(path,annotation.typeAnnotation);case 'GenericTypeAnnotation':if(isTypeChecker(annotation.id,path.scope)){return staticChecks.type({path:path,type:annotation.id});}else if(isPolymorphicType(annotation.id,path.scope)){return;}else if(annotation.id.name==='Symbol'){return staticChecks.symbol(path);}else {return staticChecks.instanceof({path:path,annotation:annotation});}}return compareAnnotations(annotation,other);} /**\n   * Get the type annotation for a given node.\n   */function getAnnotation(path){var annotation=void 0;try{annotation=getAnnotationShallow(path);}catch(e){if(e instanceof SyntaxError){throw e;}if(process.env.TYPECHECK_DEBUG){console.error(e.stack);}}while(annotation&&annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}return annotation||t.anyTypeAnnotation();}function getAnnotationShallow(path){if(!path||!path.node){return t.voidTypeAnnotation();}var node=path.node;var scope=path.scope;if(node.type==='TypeAlias'){return node.right;}else if(node.type==='ClassProperty'&&node.typeAnnotation){return getClassPropertyAnnotation(path);}else if(node.type==='ClassMethod'&&node.returnType){return getClassMethodAnnotation(path);}else if(node.type==='ObjectProperty'&&node.typeAnnotation){return getObjectPropertyAnnotation(path);}else if(node.type==='SpreadProperty'&&node.typeAnnotation){return getSpreadPropertyAnnotation(path);}else if(node.type==='ObjectMethod'&&node.returnType){return getObjectMethodAnnotation(path);}else if(!node.typeAnnotation&&!node.savedTypeAnnotation&&!node.returnType){switch(path.type){case 'Identifier':var binding=scope.getBinding(node.name);if(!binding||!binding.identifier){return path.getTypeAnnotation();}var id=binding.identifier;if(binding.path.type==='ObjectPattern'){return getObjectPatternAnnotation(binding.path,node.name);}if(id.savedTypeAnnotation){return id.savedTypeAnnotation;}else if(id.returnType){return id.returnType;}else if(id.typeAnnotation){return id.typeAnnotation;}else if(isPolymorphicType(id,scope)){return t.anyTypeAnnotation();}return binding.constant?binding.path.getTypeAnnotation():path.getTypeAnnotation();case 'StringLiteral':case 'NumericLiteral':case 'BooleanLiteral':return createLiteralTypeAnnotation(path);case 'CallExpression':var callee=path.get('callee');if(callee.type==='Identifier'){if(callee.name==='Symbol'){return t.genericTypeAnnotation('Symbol');}var fn=getFunctionForIdentifier(callee);if(fn){return getAnnotation(fn);}}break;case 'ThisExpression':return getThisExpressionAnnotation(path);case 'AssignmentExpression':return getAssignmentExpressionAnnotation(path);case 'MemberExpression':return getMemberExpressionAnnotation(path);case 'ArrayExpression':return getArrayExpressionAnnotation(path);case 'ObjectExpression':return getObjectExpressionAnnotation(path);case 'BinaryExpression':return getBinaryExpressionAnnotation(path);case 'LogicalExpression':return getLogicalExpressionAnnotation(path);case 'ConditionalExpression':return getConditionalExpressionAnnotation(path);case 'ObjectMethod':return getObjectMethodAnnotation(path);case 'SpreadProperty':return getSpreadPropertyAnnotation(path);case 'ObjectProperty':return getObjectPropertyAnnotation(path);case 'ClassDeclaration':return getClassDeclarationAnnotation(path);case 'ClassMethod':return getClassMethodAnnotation(path);case 'ClassProperty':return getClassPropertyAnnotation(path);default:return path.getTypeAnnotation();}}return node.savedTypeAnnotation||node.returnType||node.typeAnnotation||path.getTypeAnnotation();}function createLiteralTypeAnnotation(path){var annotation=void 0;if(path.isStringLiteral()){annotation=t.stringLiteralTypeAnnotation();}else if(path.isNumericLiteral()){annotation=t.numericLiteralTypeAnnotation();}else if(path.isBooleanLiteral()){annotation=t.booleanLiteralTypeAnnotation();}else {return path.getTypeAnnotation();}annotation.value=path.node.value;return annotation;}function getObjectPatternAnnotation(path,name){var annotation=keyByName(getAnnotation(path),name);var found=void 0;if(!path.node.properties){return;}var _iteratorNormalCompletion10=true;var _didIteratorError10=false;var _iteratorError10=undefined;try{for(var _iterator10=path.get('properties')[Symbol.iterator](),_step10;!(_iteratorNormalCompletion10=(_step10=_iterator10.next()).done);_iteratorNormalCompletion10=true){var prop=_step10.value;if(prop.node.value&&prop.node.value.name===name){found=prop.get('key');break;}else if(prop.node.key.type==='Identifier'&&prop.node.key.name===name){found=prop.get('key');break;}}}catch(err){_didIteratorError10=true;_iteratorError10=err;}finally {try{if(!_iteratorNormalCompletion10&&_iterator10.return){_iterator10.return();}}finally {if(_didIteratorError10){throw _iteratorError10;}}}if(!annotation||!found){return;}if(found.type==='Identifier'){annotation.value.authoritative=false;return annotation.value;}}function keyByName(node,name){if(!node.properties){return;}var _iteratorNormalCompletion11=true;var _didIteratorError11=false;var _iteratorError11=undefined;try{for(var _iterator11=node.properties[Symbol.iterator](),_step11;!(_iteratorNormalCompletion11=(_step11=_iterator11.next()).done);_iteratorNormalCompletion11=true){var prop=_step11.value;if(prop.key&&prop.key.name===name){return prop;}}}catch(err){_didIteratorError11=true;_iteratorError11=err;}finally {try{if(!_iteratorNormalCompletion11&&_iterator11.return){_iterator11.return();}}finally {if(_didIteratorError11){throw _iteratorError11;}}}}function valueByName(node,name){if(!node.properties){return;}var _iteratorNormalCompletion12=true;var _didIteratorError12=false;var _iteratorError12=undefined;try{for(var _iterator12=node.properties[Symbol.iterator](),_step12;!(_iteratorNormalCompletion12=(_step12=_iterator12.next()).done);_iteratorNormalCompletion12=true){var prop=_step12.value;if(prop.value&&prop.value.name===name){return prop;}}}catch(err){_didIteratorError12=true;_iteratorError12=err;}finally {try{if(!_iteratorNormalCompletion12&&_iterator12.return){_iterator12.return();}}finally {if(_didIteratorError12){throw _iteratorError12;}}}}function getSpreadPropertyAnnotation(path){var node=path.node;var annotation=node.typeAnnotation||node.savedTypeAnnotation;if(!annotation){annotation=getAnnotation(path.get('argument'));}return annotation;}function getObjectPropertyAnnotation(path){var node=path.node;var annotation=node.typeAnnotation||node.savedTypeAnnotation;if(!annotation){if(node.value){if(node.value.typeAnnotation||node.value.savedTypeAnnotation){annotation=node.value.typeAnnotation||node.value.savedTypeAnnotation;}else if(node.value.type==='BooleanLiteral'||node.value.type==='NumericLiteral'||node.value.type==='StringLiteral'){annotation=t[node.value.type](node.value.value);}else {annotation=t.anyTypeAnnotation();}}else {annotation=t.anyTypeAnnotation();}}return t.objectTypeProperty(node.key,annotation);}function getObjectMethodAnnotation(path){var node=path.node;return t.objectTypeProperty(t.identifier(node.key.name),t.functionTypeAnnotation(null,node.params.map(function(param){return param.savedTypeAnnotation||param.typeAnnotation;}),null,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation()));}function getThisExpressionAnnotation(path){var parent=path.parentPath;loop: while(parent){switch(parent.type){case 'ClassDeclaration':return getAnnotation(parent);case 'ClassBody':return getAnnotation(parent.parentPath);case 'ClassMethod':case 'ClassProperty':return getAnnotation(parent.parentPath.parentPath);case 'ObjectProperty':return getAnnotation(parent.parentPath);case 'ObjectMethod':return getAnnotation(parent.parentPath);case 'FunctionExpression':if(parent.parentPath.type==='ObjectProperty'){return getAnnotation(parent.parentPath.parentPath);}break loop;case 'ArrowFunctionExpression':parent=parent.parentPath;continue;}if(parent.isFunction()){break;}parent=parent.parentPath;}return t.objectTypeAnnotation([]);}function getClassDeclarationAnnotation(path){var body=path.get('body').get('body').map(getAnnotation).filter(function(annotation){return annotation&&annotation.type!=='AnyTypeAnnotation';});return t.objectTypeAnnotation(body);}function getAssignmentExpressionAnnotation(path){if(path.node.operator==='='){return getAnnotation(path.get('right'));}}function getClassPropertyAnnotation(path){var node=path.node;if(node.computed){return;}var annotation=node.typeAnnotation||(node.value?node.value.savedTypeAnnotation||node.value.typeAnnotation:t.anyTypeAnnotation());return t.objectTypeProperty(node.key,annotation||t.anyTypeAnnotation());}function getClassMethodAnnotation(path){var node=path.node;if(node.computed){return;}if(node.kind==='get'){return t.objectTypeProperty(node.key,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation());}else if(node.kind==='set'){return t.objectTypeProperty(node.key,node.params.map(function(param){return param.savedTypeAnnotation||param.typeAnnotation;}).shift()||t.anyTypeAnnotation());}else {return t.objectTypeProperty(node.key,t.functionTypeAnnotation(null,node.params.map(function(param){return param.savedTypeAnnotation||param.typeAnnotation||t.anyTypeAnnotation();}),null,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation()));}}function getBinaryExpressionAnnotation(path){var node=path.node;if(isBooleanExpression(node)){return t.booleanTypeAnnotation();}else {return t.anyTypeAnnotation();}}function getLogicalExpressionAnnotation(path){var node=path.node;if(isBooleanExpression(node)){return t.booleanTypeAnnotation();}else {var left=path.get('left');var right=path.get('right');switch(node.operator){case '&&':case '||':var _ref25=[getAnnotation(left),getAnnotation(right)];left=_ref25[0];right=_ref25[1];if(t.isUnionTypeAnnotation(left)){if(t.isUnionTypeAnnotation(right)){return t.unionTypeAnnotation(left.types.concat(right.types));}else {return t.unionTypeAnnotation(left.types.concat(right));}}else {return t.unionTypeAnnotation([left,right]);}}return t.anyTypeAnnotation();}}function getConditionalExpressionAnnotation(path){var node=path.node;var consequent=getAnnotation(path.get('consequent'));var alternate=getAnnotation(path.get('alternate'));if(t.isUnionTypeAnnotation(consequent)){if(t.isUnionTypeAnnotation(alternate)){return t.unionTypeAnnotation(consequent.types.concat(alternate.types));}else {return t.unionTypeAnnotation(consequent.types.concat(alternate));}}else {return t.unionTypeAnnotation([consequent,alternate]);}}function getArrayExpressionAnnotation(path){return t.genericTypeAnnotation(t.identifier('Array'),t.typeParameterDeclaration(path.get('elements').map(getAnnotation)));}function getObjectExpressionAnnotation(path){var annotation=t.objectTypeAnnotation(path.get('properties').filter(function(prop){return !prop.node.computed;}).map(getAnnotation).reduce(function(properties,prop){if(t.isObjectTypeProperty(prop)){properties.push(prop);}else if(t.isObjectTypeAnnotation(prop)){properties.push.apply(properties,_toConsumableArray(prop.properties));}return properties;},[]).filter(function(annotation){return !t.isAnyTypeAnnotation(annotation.value);}));return annotation;}function getMemberExpressionAnnotation(path){if(path.node.computed){return getComputedMemberExpressionAnnotation(path);}var stack=[];var target=path;while(target.isMemberExpression()){stack.push(target);if(target.node.computed){break;}target=target.get('object');}var objectAnnotation=stack.reduceRight(function(last,target){var annotation=last;if(annotation==null){if(stack.length===1){annotation=getAnnotation(target.get('object'));}else {return getAnnotation(target);}}switch(annotation.type){case 'AnyTypeAnnotation':return annotation;case 'NullableTypeAnnotation':case 'TypeAnnotation':annotation=annotation.typeAnnotation;}if(annotation.type==='GenericTypeAnnotation'){var typeChecker=getTypeChecker(annotation.id,path.scope);if(typeChecker){annotation=getAnnotation(typeChecker);}else {var binding=path.scope.getBinding(annotation.id.name);if(binding){annotation=getAnnotation(binding.path);}}}switch(annotation.type){case 'AnyTypeAnnotation':return annotation;case 'ObjectTypeAnnotation':var id=target.get('property').node;var _iteratorNormalCompletion13=true;var _didIteratorError13=false;var _iteratorError13=undefined;try{for(var _iterator13=(annotation.properties||[])[Symbol.iterator](),_step13;!(_iteratorNormalCompletion13=(_step13=_iterator13.next()).done);_iteratorNormalCompletion13=true){var _step13$value=_step13.value;var key=_step13$value.key;var value=_step13$value.value;if(key.name===id.name){return value.type==='VoidTypeAnnotation'||value.type==='NullLiteralTypeAnnotation'?t.anyTypeAnnotation():value;}}}catch(err){_didIteratorError13=true;_iteratorError13=err;}finally {try{if(!_iteratorNormalCompletion13&&_iterator13.return){_iterator13.return();}}finally {if(_didIteratorError13){throw _iteratorError13;}}}}return t.anyTypeAnnotation();},null);return objectAnnotation||path.getTypeAnnotation();}function getComputedMemberExpressionAnnotation(path){var object=path.get('object');var property=path.get('property');var objectAnnotation=getAnnotation(object);if(objectAnnotation.type==='TypeAnnotation'||objectAnnotation.type==='NullableTypeAnnotation'){objectAnnotation=objectAnnotation.typeAnnotation;}var propertyAnnotation=getAnnotation(property);if(propertyAnnotation.type==='TypeAnnotation'||propertyAnnotation.type==='NullableTypeAnnotation'){propertyAnnotation=propertyAnnotation.typeAnnotation;}var _property$evaluate=property.evaluate();var confident=_property$evaluate.confident;var value=_property$evaluate.value;if(!confident){return path.getTypeAnnotation();}switch(objectAnnotation.type){case 'TupleTypeAnnotation':if(objectAnnotation.types.length===0){break;}else if(typeof value==='number'){if(!objectAnnotation.types[value]){throw path.buildCodeFrameError('Invalid computed member expression for tuple: '+humanReadableType(objectAnnotation));}return objectAnnotation.types[value];}else {throw path.buildCodeFrameError('Invalid computed member expression for tuple: '+humanReadableType(objectAnnotation));}break;}return path.getTypeAnnotation();}function getFunctionForIdentifier(path){if(path.type!=='Identifier'){return false;}var ref=path.scope.getBinding(path.node.name);if(!ref){return false;}return t.isFunction(ref.path.parent)&&ref.path.parentPath;} /**\n   * Determine whether the given annotation is for an array.\n   */function isStrictlyArrayAnnotation(annotation){switch(annotation.type){case 'ArrayTypeAnnotation':case 'TupleTypeAnnotation':return true;case 'TypeAnnotation':case 'FunctionTypeParam':return isStrictlyArrayAnnotation(annotation.typeAnnotation);case 'GenericTypeAnnotation':return annotation.id.name==='Array'?true:null;case 'UnionTypeAnnotation':return annotation.types.every(isStrictlyArrayAnnotation);default:return false;}}function compareMaybeUnion(annotation,comparator){var falseCount=0;var _iteratorNormalCompletion14=true;var _didIteratorError14=false;var _iteratorError14=undefined;try{for(var _iterator14=annotation.types[Symbol.iterator](),_step14;!(_iteratorNormalCompletion14=(_step14=_iterator14.next()).done);_iteratorNormalCompletion14=true){var _type5=_step14.value;var result=comparator(_type5);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError14=true;_iteratorError14=err;}finally {try{if(!_iteratorNormalCompletion14&&_iterator14.return){_iterator14.return();}}finally {if(_didIteratorError14){throw _iteratorError14;}}}if(falseCount===annotation.types.length){return false;}else {return null;}} /**\n   * Returns `true` if the annotation is compatible with a number,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeNumberAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeNumberAnnotation(annotation.typeAnnotation);case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'NumericLiteral':return true;case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':return false;default:return null;}case 'UnionTypeAnnotation':return compareMaybeUnion(annotation,maybeNumberAnnotation);case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}} /**\n   * Returns `true` if the annotation is compatible with a string,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeStringAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeStringAnnotation(annotation.typeAnnotation);case 'StringTypeAnnotation':case 'StringLiteral':return true;case 'StringLiteralTypeAnnotation':return null;case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'Number':case 'Boolean':case 'Date':case 'RegExp':return false;default:return null;}case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion15=true;var _didIteratorError15=false;var _iteratorError15=undefined;try{for(var _iterator15=annotation.types[Symbol.iterator](),_step15;!(_iteratorNormalCompletion15=(_step15=_iterator15.next()).done);_iteratorNormalCompletion15=true){var _type6=_step15.value;var result=maybeStringAnnotation(_type6);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError15=true;_iteratorError15=err;}finally {try{if(!_iteratorNormalCompletion15&&_iterator15.return){_iterator15.return();}}finally {if(_didIteratorError15){throw _iteratorError15;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}} /**\n   * Returns `true` if the annotation is compatible with a symbol,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeSymbolAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeSymbolAnnotation(annotation.typeAnnotation);case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'Number':case 'Boolean':case 'Date':case 'RegExp':return false;case 'Symbol':return true;default:return null;}case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion16=true;var _didIteratorError16=false;var _iteratorError16=undefined;try{for(var _iterator16=annotation.types[Symbol.iterator](),_step16;!(_iteratorNormalCompletion16=(_step16=_iterator16.next()).done);_iteratorNormalCompletion16=true){var _type7=_step16.value;var result=maybeSymbolAnnotation(_type7);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError16=true;_iteratorError16=err;}finally {try{if(!_iteratorNormalCompletion16&&_iterator16.return){_iterator16.return();}}finally {if(_didIteratorError16){throw _iteratorError16;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}} /**\n   * Returns `true` if the annotation is compatible with a boolean,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeBooleanAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeBooleanAnnotation(annotation.typeAnnotation);case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'BooleanLiteral':return true;case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'String':case 'Number':case 'Date':case 'RegExp':return false;default:return null;}case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion17=true;var _didIteratorError17=false;var _iteratorError17=undefined;try{for(var _iterator17=annotation.types[Symbol.iterator](),_step17;!(_iteratorNormalCompletion17=(_step17=_iterator17.next()).done);_iteratorNormalCompletion17=true){var _type8=_step17.value;var result=maybeBooleanAnnotation(_type8);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError17=true;_iteratorError17=err;}finally {try{if(!_iteratorNormalCompletion17&&_iterator17.return){_iterator17.return();}}finally {if(_didIteratorError17){throw _iteratorError17;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}} /**\n   * Returns `true` if the annotation is compatible with a function,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeFunctionAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeFunctionAnnotation(annotation.typeAnnotation);case 'FunctionTypeAnnotation':return true;case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Number':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':return false;default:return null;}case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion18=true;var _didIteratorError18=false;var _iteratorError18=undefined;try{for(var _iterator18=annotation.types[Symbol.iterator](),_step18;!(_iteratorNormalCompletion18=(_step18=_iterator18.next()).done);_iteratorNormalCompletion18=true){var _type9=_step18.value;var result=maybeFunctionAnnotation(_type9);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError18=true;_iteratorError18=err;}finally {try{if(!_iteratorNormalCompletion18&&_iterator18.return){_iterator18.return();}}finally {if(_didIteratorError18){throw _iteratorError18;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}} /**\n   * Returns `true` if the annotation is compatible with an undefined or null type,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeNullableAnnotation(annotation){switch(annotation.type){case 'NullableTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'MixedTypeAnnotation':return true;case 'TypeAnnotation':case 'FunctionTypeParam':return maybeNullableAnnotation(annotation.typeAnnotation);case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Number':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':return false;case 'Generator':if(annotation.typeParameters&&annotation.typeParameters.params.length>1){return maybeNullableAnnotation(annotation.typeParameters.params[1]);}else {return null;}default:return null;}case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion19=true;var _didIteratorError19=false;var _iteratorError19=undefined;try{for(var _iterator19=annotation.types[Symbol.iterator](),_step19;!(_iteratorNormalCompletion19=(_step19=_iterator19.next()).done);_iteratorNormalCompletion19=true){var _type10=_step19.value;var result=maybeNullableAnnotation(_type10);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError19=true;_iteratorError19=err;}finally {try{if(!_iteratorNormalCompletion19&&_iterator19.return){_iterator19.return();}}finally {if(_didIteratorError19){throw _iteratorError19;}}}if(falseCount===annotation.types.length){return false;}else {return null;}default:return false;}} /**\n   * Returns `true` if the annotation is compatible with an object type,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeInstanceOfAnnotation(annotation,expected,typeParameters){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeInstanceOfAnnotation(annotation.typeAnnotation,expected,typeParameters);case 'GenericTypeAnnotation':if(annotation.id.name===expected.name){if(typeParameters.length===0){return true;}if(annotation.typeParameters&&annotation.typeParameters.params.length){var trueCount=0;var nullCount=0;for(var i=0;i<typeParameters.length&&i<annotation.typeParameters.params.length;i++){var result=compareAnnotations(typeParameters[i],annotation.typeParameters.params[i]);if(result===false){return false;}else if(result===true){trueCount++;}else {nullCount++;}}return trueCount>0&&nullCount===0?true:null;}}return null;case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion20=true;var _didIteratorError20=false;var _iteratorError20=undefined;try{for(var _iterator20=annotation.types[Symbol.iterator](),_step20;!(_iteratorNormalCompletion20=(_step20=_iterator20.next()).done);_iteratorNormalCompletion20=true){var _type11=_step20.value;var _result=maybeInstanceOfAnnotation(_type11,expected,typeParameters);if(_result===true){return true;}else if(_result===false){falseCount++;}}}catch(err){_didIteratorError20=true;_iteratorError20=err;}finally {try{if(!_iteratorNormalCompletion20&&_iterator20.return){_iterator20.return();}}finally {if(_didIteratorError20){throw _iteratorError20;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':if(expected.name==='Array'||expected.name==='RegExp'||expected.name==='Error'||expected.name==='Function'||expected.name==='String'||expected.name==='Object'){return false;}else {return null;}case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':if(expected.name==='Array'||expected.name==='RegExp'||expected.name==='Error'||expected.name==='Function'){return false;}else {return null;}case 'FunctionTypeAnnotation':if(expected.name==='Function'){return true;}else {return null;}default:return null;}} /**\n   * Returns `true` if the annotation is compatible with an array,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeArrayAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeArrayAnnotation(annotation.typeAnnotation);case 'TupleTypeAnnotation':case 'ArrayTypeAnnotation':return true;case 'GenericTypeAnnotation':return annotation.id.name==='Array'?true:null;case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion21=true;var _didIteratorError21=false;var _iteratorError21=undefined;try{for(var _iterator21=annotation.types[Symbol.iterator](),_step21;!(_iteratorNormalCompletion21=(_step21=_iterator21.next()).done);_iteratorNormalCompletion21=true){var _type12=_step21.value;var result=maybeArrayAnnotation(_type12);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError21=true;_iteratorError21=err;}finally {try{if(!_iteratorNormalCompletion21&&_iterator21.return){_iterator21.return();}}finally {if(_didIteratorError21){throw _iteratorError21;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}} /**\n   * Returns `true` if the annotation is compatible with an iterable,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeIterableAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeIterableAnnotation(annotation.typeAnnotation);case 'TupleTypeAnnotation':case 'ArrayTypeAnnotation':return true;case 'GenericTypeAnnotation':return annotation.id.name==='Iterable'?true:null;case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion22=true;var _didIteratorError22=false;var _iteratorError22=undefined;try{for(var _iterator22=annotation.types[Symbol.iterator](),_step22;!(_iteratorNormalCompletion22=(_step22=_iterator22.next()).done);_iteratorNormalCompletion22=true){var _type13=_step22.value;var result=maybeIterableAnnotation(_type13);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError22=true;_iteratorError22=err;}finally {try{if(!_iteratorNormalCompletion22&&_iterator22.return){_iterator22.return();}}finally {if(_didIteratorError22){throw _iteratorError22;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':return false;default:return null;}} /**\n   * Returns `true` if the annotation is compatible with a tuple,\n   * `false` if it definitely isn't, or `null` if we're not sure.\n   */function maybeTupleAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeTupleAnnotation(annotation.typeAnnotation);case 'TupleTypeAnnotation':return true;case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion23=true;var _didIteratorError23=false;var _iteratorError23=undefined;try{for(var _iterator23=annotation.types[Symbol.iterator](),_step23;!(_iteratorNormalCompletion23=(_step23=_iterator23.next()).done);_iteratorNormalCompletion23=true){var _type14=_step23.value;var result=maybeTupleAnnotation(_type14);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError23=true;_iteratorError23=err;}finally {try{if(!_iteratorNormalCompletion23&&_iterator23.return){_iterator23.return();}}finally {if(_didIteratorError23){throw _iteratorError23;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'GenericTypeAnnotation':case 'AnyTypeAnnotation':case 'ArrayTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}}function humanReadableType(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':return humanReadableType(annotation.typeAnnotation);case 'FunctionTypeAnnotation': // @fixme babel doesn't seem to like generating FunctionTypeAnnotations yet\nreturn '('+annotation.params.map(humanReadableType).join(', ')+') => '+humanReadableType(annotation.returnType);case 'GenericTypeAnnotation':var path=getNodePath(annotation);var checker=path&&getTypeChecker(annotation.id,path.scope);if(checker&&checker.node.savedTypeAnnotation){return humanReadableType(checker.node.savedTypeAnnotation);}else {return (0,_babelGenerator2.default)(annotation).code;}default:return (0,_babelGenerator2.default)(annotation).code;}} /**\n   * Get the path directly from a node.\n   */function getNodePath(node){if(node._paths&&node._paths.length){return node._paths[0];}else {return null;}}function getTypeChecker(id,scope){var checker=scope.getData('typechecker:'+id.name);if(checker){return checker;}var binding=scope.getBinding(id.name);if(binding===undefined){return false;}var path=binding.path;if(path==null){return false;}else if(path.type==='TypeAlias'){return path;}else if(path.type==='VariableDeclaration'&&path.node.isTypeChecker){return path.get('declarations')[0];}else if(path.isImportSpecifier()&&path.parent.importKind==='type'){return path;}return false;}function isTypeChecker(id,scope){return scope.getData('typechecker:'+id.name)!==undefined;}function isPolymorphicType(id,scope){var binding=scope.getBinding(id.name);if(binding!==undefined){return false;}var path=scope.path;while(path&&path.type!=='Program'){var _path=path;var _node=_path.node;if((t.isFunction(_node)||t.isClass(_node))&&_node.typeParameters){var _iteratorNormalCompletion24=true;var _didIteratorError24=false;var _iteratorError24=undefined;try{for(var _iterator24=_node.typeParameters.params[Symbol.iterator](),_step24;!(_iteratorNormalCompletion24=(_step24=_iterator24.next()).done);_iteratorNormalCompletion24=true){var param=_step24.value;param.isPolymorphicType=true;if(param.name===id.name){return true;}}}catch(err){_didIteratorError24=true;_iteratorError24=err;}finally {try{if(!_iteratorNormalCompletion24&&_iterator24.return){_iterator24.return();}}finally {if(_didIteratorError24){throw _iteratorError24;}}}}path=path.parentPath;}return false;}function getPolymorphicType(id,scope){var binding=scope.getBinding(id.name);if(binding!==undefined){return false;}var path=scope.path;while(path&&path.type!=='Program'){var _path2=path;var _node2=_path2.node;if(t.isFunction(_node2)&&_node2.typeParameters){var _iteratorNormalCompletion25=true;var _didIteratorError25=false;var _iteratorError25=undefined;try{for(var _iterator25=_node2.typeParameters.params[Symbol.iterator](),_step25;!(_iteratorNormalCompletion25=(_step25=_iterator25.next()).done);_iteratorNormalCompletion25=true){var param=_step25.value;param.isPolymorphicType=true;if(param.name===id.name){return param;}}}catch(err){_didIteratorError25=true;_iteratorError25=err;}finally {try{if(!_iteratorNormalCompletion25&&_iterator25.return){_iterator25.return();}}finally {if(_didIteratorError25){throw _iteratorError25;}}}}path=path.parent;}return null;}function collectParamChecks(path,context){return path.get('params').map(function(param){var node=param.node;if(node.type==='AssignmentPattern'){if(node.left.typeAnnotation){return createDefaultParamGuard(param,context);}}else if(node.type==='RestElement'){if(node.typeAnnotation){return createRestParamGuard(param,context);}}else if(node.typeAnnotation){return createParamGuard(param,context);}}).filter(identity);}function createParamGuard(path,context){var node=path.node;var scope=path.scope;node.hasBeenTypeChecked=true;node.savedTypeAnnotation=node.typeAnnotation;var checkable=void 0;if(node.type==='ObjectPattern'){node.name=path.key;checkable=t.memberExpression(t.identifier('arguments'),t.numericLiteral(path.key),true);}else {checkable=node;}var check=checkAnnotation(checkable,node.typeAnnotation,scope);if(!check){return;}if(node.optional){check=t.logicalExpression('||',checks.undefined({input:checkable}),check);}var message=paramTypeErrorMessage(checkable,context,node.typeAnnotation);return guard({check:check,message:message});}function createDefaultParamGuard(path,context){var node=path.node;var scope=path.scope;var id=node.left;var value=node.right;var ok=staticCheckAnnotation(path.get('right'),id.typeAnnotation);if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid default value for argument \"'+id.name+'\".',id.typeAnnotation,getAnnotation(path.get('right'))));}return createParamGuard(path.get('left'),context);}function createRestParamGuard(path,context){var node=path.node;var scope=path.scope;var id=node.argument;id.hasBeenTypeChecked=true;node.savedTypeAnnotation=node.typeAnnotation;if(isStrictlyArrayAnnotation(node.typeAnnotation)===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid type annotation for rest argument \"'+id.name+'\".',t.genericTypeAnnotation(t.identifier('Array')),node.typeAnnotation));}var check=checkAnnotation(id,node.typeAnnotation,scope);if(!check){return;}if(node.optional){check=t.logicalExpression('||',checks.undefined({input:id}),check);}var message=paramTypeErrorMessage(id,context,node.typeAnnotation);return guard({check:check,message:message});}function returnTypeErrorMessage(path,fn,id,context){var node=path.node;var scope=path.scope;var name=fn.id?fn.id.name:'';var annotation=fn.returnType;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(fn.generator&&isGeneratorAnnotation(annotation)&&annotation.typeParameters&&annotation.typeParameters.params.length>1){annotation=annotation.typeParameters.params[1];}var message='Function '+(name?'\"'+name+'\" ':'')+'return value violates contract.\\n\\nExpected:\\n'+humanReadableType(annotation)+'\\n\\nGot:\\n';return t.binaryExpression('+',t.stringLiteral(message),id?readableName({inspect:context.inspect,input:id}):node.argument?readableName({inspect:context.inspect,input:node.argument}):t.stringLiteral('undefined'));}function yieldTypeErrorMessage(fn,annotation,id,context){var name=fn.id?fn.id.name:'';var message='Function '+(name?'\"'+name+'\" ':'')+'yielded an invalid value.\\n\\nExpected:\\n'+humanReadableType(annotation)+'\\n\\nGot:\\n';return t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:id}));}function yieldNextTypeErrorMessage(fn,annotation,id,context){var name=fn.id?fn.id.name:'';var message='Generator '+(name?'\"'+name+'\" ':'')+'received an invalid next value.\\n\\nExpected:\\n'+humanReadableType(annotation)+'\\n\\nGot:\\n';return t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:id}));}function paramTypeErrorMessage(node,context){var typeAnnotation=arguments.length<=2||arguments[2]===undefined?node.typeAnnotation:arguments[2];var name=node.name;if(node.type==='MemberExpression'&&node.object.name==='arguments'){name=node.property.value;}var message='Value of '+(node.optional?'optional ':'')+'argument '+JSON.stringify(name)+' violates contract.\\n\\nExpected:\\n'+humanReadableType(typeAnnotation)+'\\n\\nGot:\\n';return t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:node}));}function varTypeErrorMessage(node,context){var annotation=node.typeAnnotation;if(node.type==='Identifier'){var _name3=node.name;var message='Value of variable \"'+_name3+'\" violates contract.\\n\\nExpected:\\n'+humanReadableType(annotation)+'\\n\\nGot:\\n';return t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:node}));}else {var _message='Value of \"'+humanReadableType(node)+'\" violates contract.\\n\\nExpected:\\n'+humanReadableType(annotation)+'\\n\\nGot:\\n';return t.binaryExpression('+',t.stringLiteral(_message),readableName({inspect:context.inspect,input:node}));}} /**\n   * Create a React property validator\n   */function generatePropType(annotation,scope,context){var prop=t.identifier('prop');var check=checkAnnotation(prop,annotation,scope);if(check){return propType({check:check,prop:prop,expected:t.stringLiteral(humanReadableType(annotation)),got:readableName({inspect:context.inspect,input:prop})});}else {return t.functionExpression(null,[],t.blockStatement([]));}} /**\n   * Determine whether the given node can produce purely boolean results.\n   */function isBooleanExpression(node){if(node.type==='BinaryExpression'&&BOOLEAN_BINARY_OPERATORS.indexOf(node.operator)>-1){return true;}else if(node.type==='LogicalExpression'){return isBooleanExpression(node.left)&&isBooleanExpression(node.right);}else {return false;}} /**\n   * Convert type specifier to expression.\n   */function createTypeExpression(node){if(node.type=='Identifier'){return node;}else if(node.type=='QualifiedTypeIdentifier'){return t.memberExpression(createTypeExpression(node.qualification),createTypeExpression(node.id));}throw this.errorWithNode('Unsupported type: '+node.type);} /**\n   * Get name of a type as a string.\n   */function getTypeName(node){if(node.type=='Identifier'){return node.name;}else if(node.type=='QualifiedTypeIdentifier'){return getTypeName(node.qualification)+'.'+getTypeName(node.id);}throw this.errorWithNode('Unsupported type: '+node.type);} /**\n   * Union two arrays.\n   */function union(arr1,arr2){for(var i=0;i<arr2.length;i++){var item=arr2[i];if(arr1.indexOf(item)===-1){arr1.push(item);}}return arr1;} /**\n   * Determine whether the given annotation allows any value.\n   */function allowsAny(annotation){if(annotation.type==='TypeAnnotation'||annotation.type==='NullableTypeAnnotation'){return allowsAny(annotation.typeAnnotation);}else if(annotation.type==='AnyTypeAnnotation'||annotation.type==='MixedTypeAnnotation'){return true;}else if(annotation.type==='UnionTypeAnnotation'){return annotation.types.some(allowsAny);}else {return false;}} /**\n   * Determine whether a given node is nully (null or undefined).\n   */function isNodeNully(node){if(node==null){return true;}else if(node.type==='Identifier'&&node.name==='undefined'){return true;}else if(node.type==='Literal'&&node.value===null){return true;}else if(node.type==='UnaryExpression'&&node.operator==='void'){return true;}else {return false;}} /**\n   * Determine whether the file should be checked\n   */function mustCheckFile(path,opts){if(path.node.leadingComments&&path.node.leadingComments.length){return opts.only&&!skipEnvironment(path.node.leadingComments,opts);}return false;} /**\n   * Determine whether the file should be skipped, based on the comments attached to the given node.\n   */function maybeSkipFile(path,opts){if(path.node.leadingComments&&path.node.leadingComments.length){if(skipEnvironment(path.node.leadingComments,opts)){return true;}return path.node.leadingComments.some(function(comment){return PRAGMA_IGNORE_FILE.test(comment.value);});}return false;} /**\n   * Maybe skip the given path if it has a relevant pragma.\n   */function maybeSkip(path){var node=path.node;if(node.hasBeenTypeChecked){return true;}if(node.leadingComments&&node.leadingComments.length){var comment=node.leadingComments[node.leadingComments.length-1];if(PRAGMA_IGNORE_STATEMENT.test(comment.value)){path.skip();return true;}}return false;} /**\n   * A function that returns its first argument, useful when filtering.\n   */function identity(input){return input;}function getExpression(node){return t.isExpressionStatement(node)?node.expression:node;}function expression(input){var fn=template(input);return function(){var node=fn.apply(undefined,arguments);return getExpression(node);};}};var _babelGenerator=require('babel-generator');var _babelGenerator2=_interopRequireDefault(_babelGenerator);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else {return Array.from(arr);}}","/home/travis/build/npmtest/node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/type-checks.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = make;\nvar INVALID = exports.INVALID = 0;\nvar NEEDS_CHECK = exports.NEEDS_CHECK = 1;\nvar STATICALLY_VERIFIED = exports.STATICALLY_VERIFIED = 3;\n\nfunction make(_ref) {\n  var t = _ref.types;\n\n  var ANNOTATION_TYPES = {};\n\n  registerAnnotationType('VoidTypeAnnotation', {\n    compatible: ['VoidTypeAnnotation', 'NullableTypeAnnotation'],\n    checkAnnotation: function checkAnnotation(expected, candidate) {\n      if (candidate.type === 'VoidTypeAnnotation') {\n        return STATICALLY_VERIFIED;\n      } else {\n        return NEEDS_CHECK;\n      }\n    },\n    checkValue: function checkValue(expected, candidate) {\n      if (t.isIdentifier(candidate) && candidate.node.name === 'undefined') {\n        return STATICALLY_VERIFIED;\n      } else {\n        switch (candidate.type) {\n          case 'NullLiteral':\n          case 'ThisExpression':\n          case 'NewExpression':\n          case 'ObjectExpression':\n          case 'ArrayExpression':\n          case 'FunctionExpression':\n          case 'ArrowFunctionExpression':\n          case 'BooleanLiteral':\n          case 'NumericLiteral':\n          case 'StringLiteral':\n          case 'RegExpLiteral':\n            return INVALID;\n          case 'Identifier':\n            return candidate.node.name === 'undefined' ? INVALID : NEEDS_CHECK;\n          default:\n            return NEEDS_CHECK;\n        }\n      }\n    },\n    runtime: function runtime(expected, id) {\n      return id + ' === undefined';\n    }\n  });\n\n  registerAnnotationType('NullLiteralTypeAnnotation', {\n    compatible: ['NullLiteralTypeAnnotation', 'NullableTypeAnnotation'],\n    checkAnnotation: function checkAnnotation(expected, candidate) {\n      if (candidate.type === 'NullLiteralTypeAnnotation') {\n        return STATICALLY_VERIFIED;\n      } else {\n        return NEEDS_CHECK;\n      }\n    },\n    checkValue: function checkValue(expected, candidate) {\n      if (candidate.type === 'Identifier' && candidate.node.name === 'undefined') {\n        return INVALID;\n      } else if (candidate.type === 'NullLiteral') {\n        return STATICALLY_VERIFIED;\n      } else {\n        switch (candidate.type) {\n          case 'ThisExpression':\n          case 'NewExpression':\n          case 'ObjectExpression':\n          case 'ArrayExpression':\n          case 'FunctionExpression':\n          case 'ArrowFunctionExpression':\n          case 'BooleanLiteral':\n          case 'NumericLiteral':\n          case 'StringLiteral':\n          case 'RegExpLiteral':\n            return INVALID;\n          default:\n            return NEEDS_CHECK;\n        }\n      }\n    },\n    runtime: function runtime(expected, id) {\n      return id + ' === null';\n    }\n  });\n\n  registerLiteralAnnotationType('Boolean');\n  registerLiteralAnnotationType('Numeric');\n  registerLiteralAnnotationType('String');\n\n  registerAnnotationType('NullableTypeAnnotation', {\n    compatible: ['NullableTypeAnnotation', 'NullLiteralTypeAnnotation', 'VoidTypeAnnotation']\n\n  });\n\n  /**\n   * Register an annotation type with the given name / config.\n   */\n  function registerAnnotationType(name, config) {\n    ANNOTATION_TYPES[name] = config;\n  }\n\n  /**\n   * Register a literal annotation type.\n   */\n  function registerLiteralAnnotationType(shortName) {\n\n    var typeName = shortName + 'Literal';\n    var annotationName = shortName + 'TypeAnnotation';\n    var literalAnnotationName = typeName + 'TypeAnnotation';\n\n    registerAnnotationType(literalAnnotationName, {\n      compatible: [literalAnnotationName, annotationName],\n      checkAnnotation: function checkAnnotation(expected, candidate) {\n        if (candidate.type === literalAnnotationName) {\n          if (candidate.value === expected.value) {\n            return STATICALLY_VERIFIED;\n          } else {\n            return INVALID;\n          }\n        } else {\n          return NEEDS_CHECK;\n        }\n      },\n      checkValue: function checkValue(expected, candidate) {\n        if (candidate.type === typeName) {\n          if (candidate.value === expected.value) {\n            return STATICALLY_VERIFIED;\n          } else {\n            return INVALID;\n          }\n        } else {\n          switch (candidate.type) {\n            case 'NullLiteral':\n            case 'ThisExpression':\n            case 'NewExpression':\n            case 'ObjectExpression':\n            case 'ArrayExpression':\n            case 'FunctionExpression':\n            case 'ArrowFunctionExpression':\n            case 'BooleanLiteral':\n            case 'NumericLiteral':\n            case 'StringLiteral':\n            case 'RegExpLiteral':\n              return INVALID;\n            case 'Identifier':\n              return candidate.node.name === 'undefined' ? INVALID : NEEDS_CHECK;\n            default:\n              return NEEDS_CHECK;\n          }\n        }\n      },\n      runtime: function runtime(expected, id) {\n        return [id + ' === value', { value: expected.value }];\n      }\n    });\n\n    registerAnnotationType(annotationName, {\n      compatible: [annotationName, literalAnnotationName],\n      checkAnnotation: function checkAnnotation(expected, candidate) {\n        if (candidate.type === literalAnnotationName) {\n          return STATICALLY_VERIFIED;\n        } else {\n          return NEEDS_CHECK;\n        }\n      },\n      checkValue: function checkValue(expected, candidate) {\n        if (candidate.type === typeName) {\n          return STATICALLY_VERIFIED;\n        } else {\n          switch (candidate.type) {\n            case 'NullLiteral':\n            case 'ThisExpression':\n            case 'NewExpression':\n            case 'ObjectExpression':\n            case 'ArrayExpression':\n            case 'FunctionExpression':\n            case 'ArrowFunctionExpression':\n            case 'BooleanLiteral':\n            case 'NumericLiteral':\n            case 'StringLiteral':\n            case 'RegExpLiteral':\n              return INVALID;\n            case 'Identifier':\n              return candidate.node.name === 'undefined' ? INVALID : NEEDS_CHECK;\n            default:\n              return NEEDS_CHECK;\n          }\n        }\n      },\n      runtime: function runtime(expected, id) {\n        switch (shortName) {\n          case 'String':\n            return 'typeof ' + id + ' === \\'string\\'';\n          case 'Numeric':\n            return 'typeof ' + id + ' === \\'number\\'';\n          case 'Boolean':\n            return 'typeof ' + id + ' === \\'boolean\\'';\n        }\n      }\n    });\n  }\n\n  function checkStatic(path) {}\n\n  function checkRuntime(path) {}\n\n  return { checkStatic: checkStatic, checkRuntime: checkRuntime };\n}","/home/travis/build/npmtest/node-npmtest-babel-plugin-typecheck/node_modules/babel-plugin-typecheck/lib/types.js":"\"use strict\";"}